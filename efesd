// ==================== CONFIGURACIÓN ====================
// General
BE_AI_Debug = false;              // Mostrar mensajes de depuración
BE_AI_SystemActive = true;        // Sistema activo
BE_AI_PerformanceMode = 2;        // 1: Equilibrado, 2: Alto rendimiento, 3: Ultra

// Módulos activos
BE_AI_UseDirector = true;         // Sistema Director
BE_AI_UseProxies = true;          // Sistema de Proxies
BE_AI_UseStreamingBehavior = true; // Streaming de comportamiento
BE_AI_UsePathCache = true;        // Cacheo de pathfinding
BE_AI_UseShadowAI = true;         // Sistema Shadow AI

// Director de IA
BE_AI_MaxFullAI = 30;             // Máximo de unidades con IA completa
BE_AI_MaxMediumAI = 30;           // Máximo de unidades con IA media
BE_AI_DirectorInterval = 3;       // Segundos entre actualizaciones

// Streaming de Comportamiento
BE_AI_LOD_CloseRange = 300;       // Distancia para comportamiento completo
BE_AI_LOD_MediumRange = 600;      // Distancia para comportamiento medio
BE_AI_LOD_FarRange = 1000;        // Distancia para comportamiento básico

// Sistema de Proxies
BE_AI_ProxyGroupSize = 5;         // Unidades por grupo proxy
BE_AI_ProxyMinDistance = 400;     // Distancia mínima para aplicar proxies
BE_AI_ProxyUpdateInterval = 0.2;  // Intervalo de actualización (segundos)

// Shadow AI
BE_AI_ShadowMinDistance = 600;    // Distancia mínima para sombras
BE_AI_ShadowUpdateInterval = 1;   // Intervalo de actualización

// Cacheo de Rutas
BE_AI_PathCacheSize = 50;         // Máximo de rutas en caché
BE_AI_PathCacheMaxAge = 300;      // Tiempo máximo de caché (segundos)

// Sistema de Alertas de Combate
BE_AI_AlertPropagationDistance = 800; // Radio de propagación de alertas
BE_AI_AlertResponseTime = 30;         // Tiempo de respuesta a alertas
BE_AI_AlertProcessInterval = 3;       // Intervalo de procesamiento

// ==== SISTEMA DE COMPORTAMIENTOS TÁCTICOS AVANZADOS ====
BE_AI_UseTacticalBehaviors = true;   // Sistema táctico activo
BE_AI_BuildingSearchDistance = 35;   // Distancia para buscar edificios
BE_AI_CoverSearchDistance = 25;      // Distancia para buscar cobertura
BE_AI_MaxUnitsPerBuilding = 5;       // Máximo de unidades por edificio

// ==== SISTEMA DE INTELIGENCIA DE ARMAMENTO ANTITANQUE ====
BE_AI_UseATWeaponSystem = true;     // Activar/desactivar sistema
BE_AI_ATWeaponCheckInterval = 5;    // Intervalo de comprobación (segundos)
BE_AI_ATWeaponDetectionRange = 30;  // Distancia para detectar armas tiradas
BE_AI_GroupSizeThreshold = 3;       // Número mínimo de enemigos agrupados para usar AT

// ==== SISTEMA DE GESTIÓN DE VEHÍCULOS DE COMBATE ====
BE_AI_UseVehicleSystem = true;        // Activar sistema
BE_AI_VehicleUpdateInterval = 3;      // Segundos entre actualizaciones
BE_AI_VehiclePriority = true;         // Dar siempre alta prioridad a vehículos

// ==== SISTEMA DE COMUNICACIÓN TÁCTICA DE EQUIPO ====
BE_AI_UseTeamComms = true;           // Activar sistema
BE_AI_CommsRange = 300;              // Rango de comunicación entre unidades
BE_AI_KnowledgeShareInterval = 4;    // Intervalo de compartir información

// Variables globales
BE_AI_ManagedVehicles = [];
BE_AI_VehicleTargets = [];

// Lista de lanzamisiles/armas antitanque a reconocer
BE_AI_ATWeapons = [
    "launch_RPG7_F", "launch_RPG32_F", "launch_NLAW_F", "launch_B_Titan_F", 
    "launch_O_Titan_F", "launch_I_Titan_F", "launch_MRAWS_green_F",
    "launch_MRAWS_olive_F", "launch_MRAWS_sand_F", "launch_O_Vorona_brown_F",
    "launch_O_Vorona_green_F", "launch_B_Titan_short_F", "launch_O_Titan_short_F", 
    "launch_I_Titan_short_F"
];

// ==================== INICIALIZACIÓN GLOBAL ====================
if (!isNil "BE_AI_Initialized") exitWith {};
BE_AI_Initialized = false;
BE_AI_Version = "1.2";

// Variables globales
BE_AI_AllSystems = [];
BE_AI_TrackedUnits = [];
BE_AI_ProxyGroups = [];
BE_AI_PathCache = createHashMap;
BE_AI_ShadowUnits = [];
BE_AI_UnitLODLevels = createHashMap;
BE_AI_CombatAlerts = [];
BE_AI_UnitKnowledge = createHashMap;

// Contador de estadísticas
BE_AI_Stats = createHashMap;
BE_AI_Stats set ["ProxiesCreated", 0];
BE_AI_Stats set ["PathCacheHits", 0];
BE_AI_Stats set ["PathCacheMisses", 0];
BE_AI_Stats set ["ShadowsCreated", 0];
BE_AI_Stats set ["DirectorCycles", 0];

// ==================== FUNCIONES DE UTILIDAD ====================
// Función: Obtener distancia al jugador más cercano
BE_AI_GetNearestPlayerDistance = {
    params ["_position"];
    private _minDist = 999999;
    {
        if (isPlayer _x) then {
            private _dist = _position distance _x;
            if (_dist < _minDist) then {_minDist = _dist};
        };
    } forEach allUnits;
    _minDist
};

// Función: Registrar unidad para seguimiento
BE_AI_RegisterUnit = {
    params ["_unit"];
    if (!alive _unit || isPlayer _unit) exitWith {};
    if (_unit in BE_AI_TrackedUnits) exitWith {};
    
    // Guardar configuración original
    _unit setVariable ["BE_AI_OriginalSkill", skill _unit];
    _unit setVariable ["BE_AI_OriginalSide", side _unit];
    
    // Skills específicos
    _unit setVariable ["BE_AI_OriginalAccuracy", _unit skill "aimingAccuracy"];
    _unit setVariable ["BE_AI_OriginalSpeed", _unit skill "aimingSpeed"];
    _unit setVariable ["BE_AI_OriginalShake", _unit skill "aimingShake"];
    _unit setVariable ["BE_AI_OriginalSpotDist", _unit skill "spotDistance"];
    _unit setVariable ["BE_AI_OriginalSpotTime", _unit skill "spotTime"];
    
    // Registrar
    BE_AI_TrackedUnits pushBack _unit;
    BE_AI_UnitLODLevels set [str _unit, 0];
};

// Función: Limpiar unidades muertas
BE_AI_CleanupDeadUnits = {
    // Limpiar unidades trackeadas
    BE_AI_TrackedUnits = BE_AI_TrackedUnits select {alive _x};
    
    // Limpiar proxies
    BE_AI_ProxyGroups = BE_AI_ProxyGroups select {
        (_x select 1) params ["_group", "_leader", "_units"];
        alive _leader && {count (_units select {alive _x}) > 0}
    };
    
    // Limpiar sombras
    BE_AI_ShadowUnits = BE_AI_ShadowUnits select {
        (_x select 0) params ["_dummy", "_data"];
        !isNull _dummy
    };
};

// Función: Mostrar estadísticas
BE_AI_ShowStats = {
    if (!BE_AI_Debug) exitWith {};
    private _statsText = "BE Advanced AI: ";
    _statsText = _statsText + format ["Units: %1 | ", count BE_AI_TrackedUnits];
    _statsText = _statsText + format ["Proxies: %1 | ", BE_AI_Stats getOrDefault ["ProxiesCreated", 0]];
    _statsText = _statsText + format ["Shadows: %1 | ", BE_AI_Stats getOrDefault ["ShadowsCreated", 0]];
    _statsText = _statsText + format ["Cache: %1/%2", 
        BE_AI_Stats getOrDefault ["PathCacheHits", 0],
        BE_AI_Stats getOrDefault ["PathCacheMisses", 0]
    ];
};

// ==================== SISTEMA DIRECTOR DE IA ====================
// Inicializar Director
BE_AI_InitDirector = {
    // Bucle principal del director
    [] spawn {
        while {BE_AI_SystemActive && BE_AI_UseDirector} do {
            call BE_AI_DirectorCycle;
            sleep BE_AI_DirectorInterval;
        };
    };
};

// Ciclo principal del Director
BE_AI_DirectorCycle = {
    // Verificar si hay unidades para gestionar
    if (count BE_AI_TrackedUnits == 0) exitWith {};
    
    // Obtener todas las unidades AI no jugador
    private _allAI = BE_AI_TrackedUnits;
    
    // Calcular puntuación de relevancia para cada unidad
    private _scoredUnits = [];
    {
        private _unit = _x;
        private _relevanceScore = 0;
        
        // 1. Distancia al jugador más cercano (inversa)
        private _minPlayerDist = [getPosATL _unit] call BE_AI_GetNearestPlayerDistance;
        _relevanceScore = _relevanceScore + (1000 / (_minPlayerDist max 1));
        
        // 2. En combate (bonus)
        if (behaviour _unit == "COMBAT") then {_relevanceScore = _relevanceScore + 50};
        
        // 3. Líder de grupo (bonus)
        if (_unit == leader group _unit) then {_relevanceScore = _relevanceScore + 20};
        
        // 4. Visible para jugadores (bonus enorme)
        private _isVisible = false;
        {
            if (isPlayer _x) then {
                if ([_x, "VIEW"] checkVisibility [eyePos _x, eyePos _unit] > 0.1) exitWith {_isVisible = true};
            };
        } forEach allUnits;
        if (_isVisible) then {_relevanceScore = _relevanceScore + 200};
        
        // 5. Unidad especial (AT, MG, etc.)
        private _unitType = typeOf _unit;
        if (_unitType find "MG" > -1 || _unitType find "Sniper" > -1 || _unitType find "AT" > -1) then {
            _relevanceScore = _relevanceScore + 30;
        };
        
        // Añadir a la lista con su puntuación
        _scoredUnits pushBack [_unit, _relevanceScore];
    } forEach _allAI;
    
    // Ordenar por relevancia (mayor a menor)
    _scoredUnits sort false;
    
    // Asignar niveles de AI basados en relevancia
    for "_i" from 0 to (count _scoredUnits - 1) do {
        private _data = _scoredUnits select _i;
        _data params ["_unit", "_score"];
        
        if (_i < BE_AI_MaxFullAI) then {
            // IA completa para unidades de alta relevancia
            [_unit, "FULL"] call BE_AI_SetUnitLevel;
        } else {
            if (_i < (BE_AI_MaxFullAI + BE_AI_MaxMediumAI)) then {
                // IA media para relevancia moderada
                [_unit, "MEDIUM"] call BE_AI_SetUnitLevel;
            } else {
                // IA básica para el resto
                [_unit, "BASIC"] call BE_AI_SetUnitLevel;
            };
        };
    };
    
    // Actualizar estadísticas
    BE_AI_Stats set ["DirectorCycles", (BE_AI_Stats getOrDefault ["DirectorCycles", 0]) + 1];
};

// Establecer nivel de IA para una unidad
BE_AI_SetUnitLevel = {
    params ["_unit", "_level"];
    
    // Ignorar si ya tiene este nivel
    if (_unit getVariable ["BE_AI_Level", ""] == _level) exitWith {};
    
    // Aplicar configuración según nivel
    switch (_level) do {
        case "FULL": {
            // IA completa - todos los sistemas activos
            _unit enableAI "ALL";
            _unit setSkill (_unit getVariable ["BE_AI_OriginalSkill", 0.7]);
            
            // Restaurar skills específicos
            _unit setSkill ["aimingAccuracy", _unit getVariable ["BE_AI_OriginalAccuracy", 0.5]];
            _unit setSkill ["aimingSpeed", _unit getVariable ["BE_AI_OriginalSpeed", 0.5]];
            _unit setSkill ["aimingShake", _unit getVariable ["BE_AI_OriginalShake", 0.5]];
            _unit setSkill ["spotDistance", _unit getVariable ["BE_AI_OriginalSpotDist", 0.7]];
            _unit setSkill ["spotTime", _unit getVariable ["BE_AI_OriginalSpotTime", 0.5]];
            
            BE_AI_UnitLODLevels set [str _unit, 0];
        };
        case "MEDIUM": {
            // IA media - algunos sistemas desactivados o optimizados
            _unit enableAI "TARGET";
            _unit enableAI "AUTOTARGET";
            _unit enableAI "MOVE";
            _unit enableAI "ANIM";
            _unit enableAI "PATH";
            
            // Reducir skills que consumen más CPU
            _unit setSkill ["spotDistance", (_unit getVariable ["BE_AI_OriginalSpotDist", 0.7]) * 0.7];
            _unit setSkill ["spotTime", (_unit getVariable ["BE_AI_OriginalSpotTime", 0.5]) * 0.6];
            _unit setSkill ["aimingAccuracy", (_unit getVariable ["BE_AI_OriginalAccuracy", 0.5]) * 0.7];
            
            BE_AI_UnitLODLevels set [str _unit, 1];
        };
        case "BASIC": {
            // IA básica - mínimo necesario para funcionar
            _unit disableAI "FSM";
            _unit disableAI "TARGET";
            _unit disableAI "AUTOTARGET";
            _unit enableAI "MOVE";
            _unit enableAI "ANIM";
            
            // Skills mínimas
            _unit setSkill ["spotDistance", (_unit getVariable ["BE_AI_OriginalSpotDist", 0.7]) * 0.3];
            _unit setSkill ["spotTime", (_unit getVariable ["BE_AI_OriginalSpotTime", 0.5]) * 0.3];
            _unit setSkill ["aimingAccuracy", (_unit getVariable ["BE_AI_OriginalAccuracy", 0.5]) * 0.3];
            
            BE_AI_UnitLODLevels set [str _unit, 2];
        };
    };
    
    // Guardar nivel actual
    _unit setVariable ["BE_AI_Level", _level];
};

// ==================== SISTEMA DE PROXIES ====================
// Inicializar sistema de proxies
BE_AI_InitProxies = {
    // Bucle principal de detección de grupos para proxies
    [] spawn {
        while {BE_AI_SystemActive && BE_AI_UseProxies} do {
            call BE_AI_CheckGroupsForProxy;
            sleep 5;
        };
    };
};

// Verificar grupos para convertir a proxies
BE_AI_CheckGroupsForProxy = {
    // Obtener todos los grupos AI
    private _allGroups = allGroups select {
        !isNull _x && 
        {count units _x > 0} && 
        {!isPlayer leader _x} &&
        {!(_x getVariable ["BE_AI_IsProxy", false])} &&
        {!(_x getVariable ["BE_AI_NoProxy", false])}
    };
    
    {
        private _group = _x;
        private _leader = leader _group;
        private _units = units _group;
        
        // Verificar distancia al jugador más cercano
        private _playerDist = [getPosATL _leader] call BE_AI_GetNearestPlayerDistance;
        
        // Solo aplicar a grupos distantes y lo suficientemente grandes
        if (_playerDist > BE_AI_ProxyMinDistance && {count _units >= 3}) then {
            // Verificar si el grupo ya es un proxy
            if (!(_group getVariable ["BE_AI_IsProxy", false])) then {
                // Convertir a proxy
                [_group] call BE_AI_ConvertToProxy;
            };
        };
    } forEach _allGroups;
};

// Convertir grupo a representación proxy
BE_AI_ConvertToProxy = {
    params ["_group"];
    
    private _leader = leader _group;
    private _units = units _group;
    private _position = getPosATL _leader;
    private _side = side _group;
    
    // Información básica para reconstrucción
    private _unitTypes = _units apply {typeOf _x};
    private _unitPositions = _units apply {getPosATL _x};
    private _unitDirections = _units apply {getDir _x};
    
    // Guardar waypoints
    private _waypoints = waypoints _group apply {
        [waypointPosition _x, waypointType _x, waypointBehaviour _x, waypointCombatMode _x]
    };
    
    // Almacenar datos de combate
    private _inCombat = behaviour _leader == "COMBAT";
    private _knownEnemies = [];
    
    if (_inCombat) then {
        private _enemy = _leader findNearestEnemy _leader;
        if (!isNull _enemy) then {_knownEnemies = [getPosATL _enemy]};
    };
    
    // Crear datos de proxy
    private _proxyData = [
        _position,          // Posición central
        _unitTypes,         // Tipos de unidades
        _unitPositions,     // Posiciones originales
        _unitDirections,    // Direcciones originales
        _waypoints,         // Waypoints
        _side,              // Bando
        _inCombat,          // En combate
        _knownEnemies,      // Enemigos conocidos
        time                // Tiempo de creación
    ];
    
    // Crear unidad dummy
    private _dummyGroup = createGroup [_side, true];
    private _dummy = _dummyGroup createUnit [_unitTypes select 0, _position, [], 0, "NONE"];
    
    // Configurar unidad dummy como representante visual
    _dummy allowDamage false;
    _dummy disableAI "ALL";
    _dummy setBehaviour (behaviour _leader);
    
    // Crear estructura de proxy
    private _proxy = [
        _dummyGroup,        // Grupo dummy
        _dummy,             // Unidad representante
        _proxyData,         // Datos originales
        time,               // Tiempo de última actualización
        false               // Bandera de conversión pendiente
    ];
    
    // Registrar proxy
    BE_AI_ProxyGroups pushBack [_group, _proxy];
    
    // Marcar el grupo como proxy
    _group setVariable ["BE_AI_IsProxy", true];
    
    // Eliminar unidades originales
    {deleteVehicle _x} forEach _units;
    
    // Eliminar grupo original
    deleteGroup _group;
    
    // Iniciar bucle de comportamiento
    [_proxy] spawn BE_AI_UpdateProxyBehavior;
    
    // Actualizar estadísticas
    BE_AI_Stats set ["ProxiesCreated", (BE_AI_Stats getOrDefault ["ProxiesCreated", 0]) + 1];
};

// Actualizar comportamiento de proxy
BE_AI_UpdateProxyBehavior = {
    params ["_proxy"];
    
    _proxy params ["_dummyGroup", "_dummy", "_proxyData", "_lastUpdate", "_pendingConversion"];
    
    // Bucle de comportamiento mientras el proxy exista
    while {alive _dummy && BE_AI_SystemActive && BE_AI_UseProxies} do {
        // Verificar si debe reconvertirse a grupo real
        private _playerDist = [getPosATL _dummy] call BE_AI_GetNearestPlayerDistance;
        
        if (_playerDist < BE_AI_ProxyMinDistance * 0.8) then {
            // Marcar para conversión
            _proxy set [4, true];
            [_proxy] spawn BE_AI_ConvertFromProxy;
            break;
        };
        
        // Comportamiento simple según estado
        private _inCombat = _proxyData select 6;
        private _knownEnemies = _proxyData select 7;
        
        if (_inCombat && count _knownEnemies > 0) then {
            // Simular combate
            if (random 1 > 0.7) then {
                private _enemyPos = _knownEnemies select 0;
                private _dir = [getPosATL _dummy, _enemyPos] call BIS_fnc_dirTo;
                _dummy setDir _dir;
                
                // Efectos de combate ocasionales
                if (random 1 > 0.8) then {
                    private _tracerPos = getPosATL _dummy;
                    private _tracer = "F_20mm_Red" createVehicle _tracerPos;
                    _tracer setVelocity [sin(_dir) * 200, cos(_dir) * 200, 5 + random 10];
                };
            };
        } else {
            // Movimiento de patrulla
            private _waypoints = _proxyData select 4;
            if (count _waypoints > 0 && random 1 > 0.9) then {
                private _wp = selectRandom _waypoints;
                private _wPos = _wp select 0;
                
                // Mover dummy hacia waypoint
                _dummy setPosATL [
                    getPosATL _dummy select 0 + ((_wPos select 0) - (getPosATL _dummy select 0)) * 0.1,
                    getPosATL _dummy select 1 + ((_wPos select 1) - (getPosATL _dummy select 1)) * 0.1,
                    getPosATL _dummy select 2
                ];
                
                // Actualizar dirección
                _dummy setDir ([getPosATL _dummy, _wPos] call BIS_fnc_dirTo);
            };
        };
        
        sleep BE_AI_ProxyUpdateInterval;
    };
    
    // Si el bucle termina y no se está convirtiendo, limpiar
    if (!(_proxy select 4)) then {
        deleteVehicle _dummy;
        deleteGroup _dummyGroup;
    };
};

// Convertir de proxy a grupo real
BE_AI_ConvertFromProxy = {
    params ["_proxy"];
    
    _proxy params ["_dummyGroup", "_dummy", "_proxyData", "_lastUpdate", "_pendingConversion"];
    
    if (_pendingConversion) then {
        _proxyData params [
            "_position", "_unitTypes", "_unitPositions", "_unitDirections", 
            "_waypoints", "_side", "_inCombat", "_knownEnemies", "_createTime"
        ];
        
        // Crear nuevo grupo
        private _newGroup = createGroup [_side, true];
        
        // Crear unidades
        private _newUnits = [];
        for "_i" from 0 to ((count _unitTypes) - 1) do {
            private _pos = _unitPositions select _i;
            private _dir = _unitDirections select _i;
            private _type = _unitTypes select _i;
            
            // Ajustar posición a la actual del proxy
            private _deltaPos = [
                (_pos select 0) - (_position select 0),
                (_pos select 1) - (_position select 1),
                (_pos select 2) - (_position select 2)
            ];
            
            private _newPos = [
                (getPosATL _dummy select 0) + (_deltaPos select 0),
                (getPosATL _dummy select 1) + (_deltaPos select 1),
                (getPosATL _dummy select 2) + (_deltaPos select 2)
            ];
            
            private _unit = _newGroup createUnit [_type, _newPos, [], 0, "NONE"];
            _unit setDir _dir;
            
            // Registrar para gestión avanzada
            [_unit] call BE_AI_RegisterUnit;
            
            _newUnits pushBack _unit;
        };
        
        // Restaurar waypoints
        {
            _x params ["_wpPos", "_wpType", "_wpBehaviour", "_wpCombatMode"];
            private _wp = _newGroup addWaypoint [_wpPos, 0];
            _wp setWaypointType _wpType;
            _wp setWaypointBehaviour _wpBehaviour;
            _wp setWaypointCombatMode _wpCombatMode;
        } forEach _waypoints;
        
        // Configurar estado de combate
        if (_inCombat) then {
            _newGroup setBehaviour "COMBAT";
            _newGroup setCombatMode "RED";
            
            if (count _knownEnemies > 0) then {
                (_newUnits select 0) doWatch (_knownEnemies select 0);
            };
        };
        
        // Eliminar proxy
        deleteVehicle _dummy;
        deleteGroup _dummyGroup;
        
        // Quitar de la lista de proxies
        BE_AI_ProxyGroups = BE_AI_ProxyGroups select {(_x select 1) select 1 != _dummy};
    };
};

// ==================== SISTEMA SHADOW AI ====================
// Inicializar sistema Shadow AI
BE_AI_InitShadowAI = {
    // Bucle principal para gestionar sombras
    [] spawn {
        while {BE_AI_SystemActive && BE_AI_UseShadowAI} do {
            call BE_AI_CheckUnitsForShadow;
            sleep 5;
        };
    };
    
    // Bucle de actualización
    [] spawn {
        while {BE_AI_SystemActive && BE_AI_UseShadowAI} do {
            call BE_AI_UpdateShadowUnits;
            sleep BE_AI_ShadowUpdateInterval;
        };
    };
};

// Verificar unidades para conversión a shadow
BE_AI_CheckUnitsForShadow = {
    // Solo aplicar a unidades muy lejanas y en baja relevancia
    {
        private _unit = _x;
        private _playerDist = [getPosATL _unit] call BE_AI_GetNearestPlayerDistance;
        private _level = BE_AI_UnitLODLevels getOrDefault [str _unit, 0];
        
        if (_playerDist > BE_AI_ShadowMinDistance && _level >= 2 && !(_unit getVariable ["BE_AI_IsShadow", false])) then {
            // Convertir a shadow si es unidad de baja relevancia y muy lejana
            [_unit] call BE_AI_ConvertToShadow;
        };
    } forEach BE_AI_TrackedUnits;
};

// Convertir unidad a shadow
BE_AI_ConvertToShadow = {
    params ["_unit"];
    
    if (!alive _unit) exitWith {};
    
    // Crear datos de shadow
    private _position = getPosATL _unit;
    private _direction = getDir _unit;
    private _type = typeOf _unit;
    private _side = side _unit;
    private _group = group _unit;
    private _behaviour = behaviour _unit;
    private _combatMode = combatMode _unit;
    private _unitPos = unitPos _unit;
    
    // Crear objeto shadow (marker o similar)
    private _dummy = "Land_HelipadEmpty_F" createVehicle _position;
    
    // Guardar datos de shadow
    private _shadowData = [
        _position,      // Posición
        _direction,     // Dirección
        _type,          // Tipo de unidad
        _side,          // Bando
        _group,         // Grupo original
        _behaviour,     // Comportamiento
        _combatMode,    // Modo de combate
        _unitPos,       // Postura
        time            // Tiempo de creación
    ];
    
    // Registrar shadow
    BE_AI_ShadowUnits pushBack [_dummy, _shadowData, _unit];
    
    // Marcar unidad
    _unit setVariable ["BE_AI_IsShadow", true];
    
    // Desactivar completamente
    _unit enableSimulation false;
    _unit hideObject true;
    
    // Actualizar estadísticas
    BE_AI_Stats set ["ShadowsCreated", (BE_AI_Stats getOrDefault ["ShadowsCreated", 0]) + 1];
};

// Actualizar todas las unidades shadow
BE_AI_UpdateShadowUnits = {
    {
        _x params ["_dummy", "_shadowData", "_unit"];
        
        if (isNull _dummy || !alive _unit) then {
            continue;
        };
        
        // Verificar si debe reactivarse
        private _playerDist = [getPosATL _dummy] call BE_AI_GetNearestPlayerDistance;
        
        if (_playerDist < BE_AI_ShadowMinDistance * 0.8) then {
            // Reactivar unidad real
            [_x] call BE_AI_ConvertFromShadow;
        } else {
            // Actualización ligera de comportamiento
            _shadowData params ["_position", "_direction", "_type", "_side", "_group", 
                "_behaviour", "_combatMode", "_unitPos", "_createTime"];
            
            // Solo hacer movimientos ocasionales para aparentar actividad
            if (random 1 > 0.7) then {
                // Pequeño movimiento aleatorio
                private _newPos = [
                    (_position select 0) + (random 10 - 5),
                    (_position select 1) + (random 10 - 5),
                    _position select 2
                ];
                
                // Actualizar posición
                _dummy setPosATL _newPos;
                _shadowData set [0, _newPos];
                _unit setPosATL _newPos;
                
                // Actualizar dirección ocasionalmente
                if (random 1 > 0.5) then {
                    private _newDir = (_direction + (random 40) - 20) % 360;
                    _shadowData set [1, _newDir];
                };
            };
        };
    } forEach BE_AI_ShadowUnits;
    
    // Limpiar lista
    BE_AI_ShadowUnits = BE_AI_ShadowUnits select {!isNull (_x select 0) && alive (_x select 2)};
};

// Convertir de shadow a unidad normal
BE_AI_ConvertFromShadow = {
    params ["_shadowInfo"];
    
    _shadowInfo params ["_dummy", "_shadowData", "_unit"];
    
    if (!alive _unit) exitWith {};
    
    // Restaurar posición y estado
    _shadowData params ["_position", "_direction", "_type", "_side", "_group", 
        "_behaviour", "_combatMode", "_unitPos", "_createTime"];
    
    // Reactivar unidad
    _unit enableSimulation true;
    _unit hideObject false;
    
    // Actualizar posición y dirección
    _unit setPosATL _position;
    _unit setDir _direction;
    
    // Restaurar comportamiento
    _unit setBehaviour _behaviour;
    _unit setCombatMode _combatMode;
    _unit setUnitPos _unitPos;
    
    // Desmarcar
    _unit setVariable ["BE_AI_IsShadow", false];
    
    // Eliminar dummy
    deleteVehicle _dummy;
    
    // Quitar de la lista
    BE_AI_ShadowUnits = BE_AI_ShadowUnits - [_shadowInfo];
};

// ==================== SISTEMA DE CACHEO DE PATHFINDING ====================
// Inicializar sistema de caché de rutas
BE_AI_InitPathCache = {
    // Definir nuestra versión optimizada del comando doMove
    BE_AI_OptimizedDoMove = {
        params ["_unit", "_position"];
        
        if (!BE_AI_UsePathCache || !alive _unit || isPlayer _unit) exitWith {
            _unit doMove _position;
        };
        
        // Verificar distancia
        private _unitPos = getPosATL _unit;
        private _distance = _unitPos distance _position;
        
        // Para distancias cortas, usar doMove nativo
        if (_distance < 50) exitWith {
            _unit doMove _position;
        };
        
        // Buscar en caché
        private _key = format ["%1_%2", 
            [floor(_unitPos select 0), floor(_unitPos select 1)], 
            [floor(_position select 0), floor(_position select 1)]
        ];
        
        private _cachedPath = BE_AI_PathCache getOrDefault [_key, []];
        
        // Si hay ruta en caché y no es muy antigua
        if (count _cachedPath > 0) then {
            _cachedPath params ["_path", "_timestamp"];
            
            // Verificar edad
            if (time - _timestamp < BE_AI_PathCacheMaxAge) then {
                // Usar ruta cacheada
                {
                    _unit doMove _x;
                } forEach _path;
                
                // Actualizar estadísticas
                BE_AI_Stats set ["PathCacheHits", (BE_AI_Stats getOrDefault ["PathCacheHits", 0]) + 1];
            } else {
                // Caché expirada, usar nativo y actualizar
                _unit doMove _position;
                
                // Actualizar caché
                private _path = [_unitPos, _position];
                BE_AI_PathCache set [_key, [_path, time]];
                
                // Actualizar estadísticas
                BE_AI_Stats set ["PathCacheMisses", (BE_AI_Stats getOrDefault ["PathCacheMisses", 0]) + 1];
            };
        } else {
            // No hay caché, usar nativo y almacenar
            _unit doMove _position;
            
            // Crear nueva entrada en caché
            private _path = [_unitPos, _position];
            BE_AI_PathCache set [_key, [_path, time]];
            
            // Actualizar estadísticas
            BE_AI_Stats set ["PathCacheMisses", (BE_AI_Stats getOrDefault ["PathCacheMisses", 0]) + 1];
        };
    };
    
    // Crear una función global para que otras partes del código puedan usarla
    missionNamespace setVariable ["BE_doMove", BE_AI_OptimizedDoMove];
    
    // Limpieza periódica de caché
    [] spawn {
        while {BE_AI_SystemActive && BE_AI_UsePathCache} do {
            // Limpiar entradas antiguas
            private _keysToRemove = [];
            {
                private _key = _x;
                private _data = BE_AI_PathCache getOrDefault [_key, []];
                
                if (count _data > 0) then {
                    _data params ["_path", "_timestamp"];
                    
                    if (time - _timestamp > BE_AI_PathCacheMaxAge) then {
                        _keysToRemove pushBack _key;
                    };
                };
            } forEach keys BE_AI_PathCache;
            
            // Eliminar entradas antiguas
            {
                BE_AI_PathCache deleteAt _x;
            } forEach _keysToRemove;
            
            // Limitar tamaño de caché
            while {count keys BE_AI_PathCache > BE_AI_PathCacheSize} do {
                private _oldestKey = "";
                private _oldestTime = time;
                
                {
                    private _key = _x;
                    private _data = BE_AI_PathCache getOrDefault [_key, []];
                    
                    if (count _data > 0) then {
                        _data params ["_path", "_timestamp"];
                        
                        if (_timestamp < _oldestTime) then {
                            _oldestTime = _timestamp;
                            _oldestKey = _key;
                        };
                    };
                } forEach keys BE_AI_PathCache;
                
                if (_oldestKey != "") then {
                    BE_AI_PathCache deleteAt _oldestKey;
                } else {
                    break;
                };
            };
            
            sleep 60;
        };
    };
};

// ==================== STREAMING DE COMPORTAMIENTO ====================
// Inicializar streaming de comportamiento
BE_AI_InitStreamingBehavior = {
    // Bucle principal de streaming
    [] spawn {
        while {BE_AI_SystemActive && BE_AI_UseStreamingBehavior} do {
            {
                private _unit = _x;
                
                // Aplicar streaming solo a unidades vivas y no jugadores
                if (alive _unit && !isPlayer _unit) then {
                    [_unit] call BE_AI_UpdateUnitBehaviorLOD;
                };
                
                // Pequeña pausa entre unidades para distribuir carga
                sleep 0.01;
            } forEach BE_AI_TrackedUnits;
            
            sleep 2;
        };
    };
};

// Actualizar LOD de comportamiento para una unidad
BE_AI_UpdateUnitBehaviorLOD = {
    params ["_unit"];
    
    // Determinar LOD basado en distancia
    private _playerDist = [getPosATL _unit] call BE_AI_GetNearestPlayerDistance;
    
    private _lod = 0;
    if (_playerDist > BE_AI_LOD_FarRange) then {
        _lod = 3;
    } else {
        if (_playerDist > BE_AI_LOD_MediumRange) then {
            _lod = 2;
        } else {
            if (_playerDist > BE_AI_LOD_CloseRange) then {
                _lod = 1;
            } else {
                _lod = 0;
            };
        };
    };
    
    // Si el LOD no ha cambiado, salir
    private _currentLOD = BE_AI_UnitLODLevels getOrDefault [str _unit, 0];
    if (_lod == _currentLOD) exitWith {};
    
    // Actualizar LOD
    BE_AI_UnitLODLevels set [str _unit, _lod];
    
    // Aplicar configuración según LOD
    switch (_lod) do {
        case 0: {
            // LOD 0: Comportamiento completo
            _unit enableAI "ALL";
            
            // Restaurar skills
            _unit setSkill (_unit getVariable ["BE_AI_OriginalSkill", 0.7]);
            _unit setSkill ["aimingAccuracy", _unit getVariable ["BE_AI_OriginalAccuracy", 0.5]];
            _unit setSkill ["spotDistance", _unit getVariable ["BE_AI_OriginalSpotDist", 0.7]];
            _unit setSkill ["spotTime", _unit getVariable ["BE_AI_OriginalSpotTime", 0.5]];
            
            // Comportamiento de combate completo
            _unit setVariable ["BE_AI_UseComplexTactics", true];
        };
        case 1: {
            // LOD 1: Comportamiento medio
            _unit enableAI "TARGET";
            _unit enableAI "AUTOTARGET";
            _unit enableAI "MOVE";
            _unit enableAI "ANIM";
            _unit enableAI "PATH";
            
            // Reducir skills
            _unit setSkill ["aimingAccuracy", (_unit getVariable ["BE_AI_OriginalAccuracy", 0.5]) * 0.8];
            _unit setSkill ["spotDistance", (_unit getVariable ["BE_AI_OriginalSpotDist", 0.7]) * 0.7];
            _unit setSkill ["spotTime", (_unit getVariable ["BE_AI_OriginalSpotTime", 0.5]) * 0.7];
            
            // Tácticas simplificadas
            _unit setVariable ["BE_AI_UseComplexTactics", false];
        };
        case 2: {
            // LOD 2: Comportamiento básico
            _unit enableAI "MOVE";
            _unit enableAI "ANIM";
            _unit disableAI "FSM";
            _unit disableAI "TARGET";
            _unit disableAI "AUTOTARGET";
            
            // Skills mínimas
            _unit setSkill ["aimingAccuracy", (_unit getVariable ["BE_AI_OriginalAccuracy", 0.5]) * 0.5];
            _unit setSkill ["spotDistance", (_unit getVariable ["BE_AI_OriginalSpotDist", 0.7]) * 0.5];
            _unit setSkill ["spotTime", (_unit getVariable ["BE_AI_OriginalSpotTime", 0.5]) * 0.5];
            
            // Sin tácticas avanzadas
            _unit setVariable ["BE_AI_UseComplexTactics", false];
        };
        case 3: {
            // LOD 3: Comportamiento mínimo
            _unit disableAI "FSM";
            _unit disableAI "TARGET";
            _unit disableAI "AUTOTARGET";
            _unit disableAI "MOVE";
            _unit enableAI "ANIM";
            
            // Skills mínimas
            _unit setSkill ["aimingAccuracy", 0.1];
            _unit setSkill ["spotDistance", 0.1];
            _unit setSkill ["spotTime", 0.1];
            
            // Candidato para shadow
            if (BE_AI_UseShadowAI && _playerDist > BE_AI_ShadowMinDistance) then {
                if (!(_unit getVariable ["BE_AI_IsShadow", false])) then {
                    [_unit] call BE_AI_ConvertToShadow;
                };
            };
        };
    };
};

// ==================== SISTEMA DE PROPAGACIÓN DE ALERTAS DE COMBATE ====================
// Inicializar sistema de alertas
BE_AI_InitAlertSystem = {
    // Bucle principal de detección de combate
    [] spawn {
        while {BE_AI_SystemActive} do {
            call BE_AI_DetectCombatEvents;
            sleep BE_AI_AlertProcessInterval;
        };
    };
    
    // Bucle de procesamiento de alertas
    [] spawn {
        while {BE_AI_SystemActive} do {
            call BE_AI_ProcessCombatAlerts;
            sleep 1;
        };
    };
};

// Detectar eventos de combate
BE_AI_DetectCombatEvents = {
    // Detectar disparos y explosiones
    {
        private _unit = _x;
        
        // Solo procesar unidades en combate activo
        if (alive _unit && behaviour _unit == "COMBAT" && _unit getVariable ["BE_AI_Level", ""] == "FULL") then {
            private _pos = getPosATL _unit;
            private _side = side _unit;
            
            // Verificar si hay enemigos conocidos
            private _enemy = _unit findNearestEnemy _unit;
            private _enemyPos = if (!isNull _enemy) then {getPosATL _enemy} else {_pos};
            
            // Crear evento de alerta en la posición entre la unidad y su enemigo
            private _alertPos = [
                (_pos select 0) + ((_enemyPos select 0) - (_pos select 0)) * 0.5,
                (_pos select 1) + ((_enemyPos select 1) - (_pos select 1)) * 0.5,
                (_pos select 2) + ((_enemyPos select 2) - (_pos select 2)) * 0.5
            ];
            
            // Registrar alerta
            BE_AI_CombatAlerts pushBack [_alertPos, _side, time, "COMBAT"];
            
            // Limitar cantidad de alertas para evitar spam
            if (count BE_AI_CombatAlerts > 20) then {BE_AI_CombatAlerts deleteAt 0};
        };
    } forEach BE_AI_TrackedUnits;
};

// Procesar alertas de combate para notificar unidades lejanas
BE_AI_ProcessCombatAlerts = {
    private _currentTime = time;
    private _alertsToProcess = BE_AI_CombatAlerts select {_currentTime - (_x select 2) < BE_AI_AlertResponseTime};
    
    // Si no hay alertas recientes, salir
    if (count _alertsToProcess == 0) exitWith {};
    
    // Procesar cada unidad para ver si debe responder
    {
        private _unit = _x;
        
        // Solo procesar unidades vivas que no estén ya en combate
        if (alive _unit && behaviour _unit != "COMBAT") then {
            private _unitPos = getPosATL _unit;
            private _unitSide = side _unit;
            
            // Verificar alertas relevantes para esta unidad
            {
                _x params ["_alertPos", "_alertSide", "_alertTime", "_alertType"];
                
                // Comprobar si la alerta es para el mismo bando y está dentro del rango
                if (_unitSide == _alertSide && _unitPos distance _alertPos < BE_AI_AlertPropagationDistance) then {
                    // Calcular tiempo de reacción basado en distancia y rango
                    private _reactionDelay = (_unitPos distance _alertPos) / 100;
                    
                    // Si la unidad es una shadow o proxy, reactivarla
                    if (_unit getVariable ["BE_AI_IsShadow", false]) then {
                        // Encontrar la entrada shadow
                        {
                            _x params ["_dummy", "_shadowData", "_shadowUnit"];
                            if (_shadowUnit == _unit) exitWith {[_x] call BE_AI_ConvertFromShadow};
                        } forEach BE_AI_ShadowUnits;
                    };
                    
                    // Mejorar temporalmente la IA
                    private _currentLevel = _unit getVariable ["BE_AI_Level", "BASIC"];
                    if (_currentLevel != "FULL") then {
                        [_unit, "MEDIUM"] call BE_AI_SetUnitLevel;
                        
                        // Habilitar IA de combate
                        _unit enableAI "TARGET";
                        _unit enableAI "AUTOTARGET";
                        
                        // Programar vuelta a nivel original después de un tiempo
                        [_unit, _currentLevel, _currentTime + BE_AI_AlertResponseTime] spawn {
                            params ["_unit", "_originalLevel", "_endTime"];
                            waitUntil {time > _endTime || !alive _unit || behaviour _unit == "COMBAT"};
                            
                            // Si no entró en combate real, volver a nivel original
                            if (alive _unit && behaviour _unit != "COMBAT") then {
                                [_unit, _originalLevel] call BE_AI_SetUnitLevel;
                            };
                        };
                    };
                    
                    // Establecer comportamiento de alerta
                    _unit setBehaviour "AWARE";
                    _unit setCombatMode "YELLOW";
                    
                    // Hacer que el grupo responda a la alerta
                    private _group = group _unit;
                    if (_unit == leader _group) then {
                        // Si es líder, mover grupo hacia la alerta
                        private _wp = _group addWaypoint [_alertPos, 0];
                        _wp setWaypointType "MOVE";
                        _wp setWaypointBehaviour "AWARE";
                        _wp setWaypointCombatMode "YELLOW";
                        _wp setWaypointSpeed "NORMAL";
                    };
                    
                    // Mirar hacia la alerta
                    _unit doWatch _alertPos;
                };
            } forEach _alertsToProcess;
        };
    } forEach (allUnits select {!isPlayer _x});
    
    // También procesar grupos proxy
    {
        _x params ["_originalGroup", "_proxy"];
        _proxy params ["_dummyGroup", "_dummy", "_proxyData", "_lastUpdate", "_pendingConversion"];
        
        if (alive _dummy && !_pendingConversion) then {
            private _proxyPos = getPosATL _dummy;
            private _proxySide = _proxyData select 5; // Lado del proxy
            
            // Verificar alertas relevantes
            {
                _x params ["_alertPos", "_alertSide", "_alertTime", "_alertType"];
                
                // Comprobar si la alerta es para el mismo bando y está dentro del rango
                if (_proxySide == _alertSide && _proxyPos distance _alertPos < BE_AI_AlertPropagationDistance) then {
                    // Reconvertir proxy a grupo real para responder
                    _proxy set [4, true]; // Marcar para conversión
                    [_proxy] spawn BE_AI_ConvertFromProxy;
                };
            } forEach _alertsToProcess;
        };
    } forEach BE_AI_ProxyGroups;
};
