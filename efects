/*
    üåü Script: Efectos
    üë®‚Äçüíª Autor: Vianna & Enkeli
    üìÖ Creaci√≥n: 2025-05-18
    üé® Descripci√≥n: Sistema efectos para Arma 3
*/

// ======================================================
// MODIFICADORES GLOBALES DE PART√çCULAS
// ======================================================

// Valores multiplicadores para mejorar los efectos
#define PARTICLE_SIZE_MULT 1.2      // Multiplicador de tama√±o de part√≠culas
#define PARTICLE_LIFE_MULT 2.15     // Multiplicador de vida de part√≠culas
#define PARTICLE_COUNT_MULT 2.25    // Multiplicador de cantidad de part√≠culas
#define PARTICLE_DETAIL_LEVEL 1.0   // Multiplicador de detalle general
#define SPARKLE_COUNT_MULT 5        // Multiplicador de cantidad
#define SPARKLE_SIZE_MULT 1.4       // Multiplicador de tama√±o
#define SPARKLE_LIFE_MULT 2.5       // Multiplicador de vida
#define SPARKLE_BRIGHTNESS 1.9      // Brillo de las chispas
#define SMOKE_LIFE_MULT 20          // Multiplicador de duraci√≥n del humo (era 1.0)
#define SMOKE_DENSITY_MULT 1.8      // Multiplicador de densidad del humo
#define SMOKE_SIZE_MULT 1.5         // Multiplicador de tama√±o del humo
#define SMOKE_WIND_RESISTANCE 0.01  // Factor de resistencia al viento (menor = menos afectado)
#define MISSILE_TRAIL_LIFE 1.5
#define MISSILE_TRAIL_SIZE 1.2
#define MISSILE_SPARK_CHANCE 0.3
#define MISSILE_TYPES ["R_PG32V_F", "M_NLAW_AT_F", "R_80mm_HE", "M_Titan_AT", "R_PG7_F", "M_RPG32_F", "M_Scalpel_AT", "R_TBG32V_F", "M_NLAW_AT_F", "M_SPG9_HE", "M_Vorona_HEAT", "R_MRAAWS_HE_F", "R_MRAAWS_HEAT_F"]


// Configuraci√≥n para todos los humos blancos en la misi√≥n
{
    if (_x isKindOf "SmokeShellWhite") then {
        // Modificar tama√±o de las part√≠culas (mejorado)
        _x setParticleParams [
            ["\A3\data_f\ParticleEffects\Universal\smokeshell_white", 16, 12, 10],
            "", "Billboard", 1, 14, [0, 0, 0], 1, 1.5, "", "", [1.0, 10.0, 40],
            [0.8, 0.95, 0.8], 1, 1, 0.12, [0.25, 0.6, 0.15], 0.6, 1, 0.25, "", "", "", 0
        ];
    };
} forEach allMissionObjects "SmokeShellWhite";
private _gameVersion = productVersion select 2;
private _isNewEngine = _gameVersion >= 2.0;

// ======================================================
// EFECTOS DE buchedegatito WAVE / ONDA DE CHOQUE
// ======================================================

// buchedegatito Wave b√°sico
blastWave = {
    params [["_particlePos", [0,0,0], [[]]]]; 
    
    private _strength = 1.2; // Aumentado de 1.0
    
    private _particleSource = createSimpleObject ["Land_HelipadEmpty_F", AGLtoASL _particlePos, true];
    
    drop [
        ["\A3\data_f\ParticleEffects\Universal\Refract", 1, 0, 1, 0],
        "", "Billboard", 1, 0.4 * _strength,
        [0,0,0],
        [0,0,0],
        0, 10, 7.9000001, 0.1, [2.4,2.4,29,72,126,180,252], // Tama√±os incrementados
        [
            [0.15,0.15,0.15,1],
            [0.3,0.3,0.3,1],
            [0.6,0.6,0.6,1],
            [0,0,0,1],
            [0,0,0,0.6],
            [0,0,0,0.4]
        ],
        [1],
        0.25, 0.25,
        "", "",
        _particleSource,
        1, false,
        -1, [],
        [0,1,0]
    ];
    
    deleteVehicle _particleSource;
    true;
};

// buchedegatito Wave configurable con tama√±o
blastWaveConfigurable = {
    params [["_particlePos", [0,0,0], [[]]], ["_size", "medium", [""]]];
    
    private _strength = 1.2; // Aumentado de 1.0
    
    private _particleSource = createSimpleObject ["Land_HelipadEmpty_F", AGLtoASL _particlePos, true];
    
    private _dropParams = switch (_size) do {
        case "huge": {
            [
                0.6 * _strength,
                [3.6,7.2,14.4,28.8,57.6,76.8,115.2] // Aumentados 20%
            ]
        };
        case "medium": {
            [
                0.36 * _strength,
                [1.2,1.2,7.2,14.4,28.8,38.4,57.6] // Aumentados 20%
            ]
        };
        case "small": {
            [
                0.15 * _strength,
                [1.2,2.4,6.0,9.6,14.4,20.4] // Aumentados 20%
            ]
        };
        case "tiny": {
            [
                0.12 * _strength,
                [0.6,1.2,3.0,4.8,7.2,10.2] // Aumentados 20%
            ]
        };
        case "large": {
            [
                0.48 * _strength,
                [2.4,2.4,28.8,72,126,180,252] // Aumentados 20%
            ]
        };
        default {
            [0.24 * _strength, [1.2,1.2,7.2,14.4,28.8,38.4,57.6]]
        };
    };
    
    private _lifeTime = _dropParams select 0;
    private _sizeArray = _dropParams select 1;
    
    // Crear efecto
    drop [
        ["\A3\data_f\ParticleEffects\Universal\Refract", 1, 0, 1, 0],
        "", "Billboard", 1, _lifeTime,
        [0,0,0],
        [0,0,0],
        0, 10, 7.9, 0.1,
        _sizeArray,
        [
            [0.15,0.15,0.15,1],
            [0.3,0.3,0.3,1],
            [0.6,0.6,0.6,1],
            [0,0,0,1],
            [0,0,0,0.6],
            [0,0,0,0.4]
        ],
        [1],
        0.25, 0.25,
        "", "",
        _particleSource,
        1, false,
        -1, [],
        [0,1,0]
    ];
    
    deleteVehicle _particleSource;
    true;
};

// ======================================================
// EFECTOS DE EXPLOSI√ìN COMPLETA
// ======================================================

// Versi√≥n b√°sica de la explosi√≥n
explosionBasic = {
    params ["_pos"];
    
    // --- CLOUDLETS (Part√≠culas) ---
// Chispas 1 - M√°s numerosas y brillantes
private _spark1 = "#particlesource" createVehicleLocal _pos;
_spark1 setParticleParams [
    ["\\A3\\data_f\\ParticleEffects\\Universal\\Universal.p3d",16,2,32,0],"","Billboard",
    0.003, 8.0 * SPARKLE_LIFE_MULT, [0,0,0], [0,15,0], 0,28,9,0,
    [0.12 * SPARKLE_SIZE_MULT, 0.06 * SPARKLE_SIZE_MULT],    // Tama√±os m√°s variados
    [[1,1,1,1 * SPARKLE_BRIGHTNESS], [1,0.7,0.5,0.8 * SPARKLE_BRIGHTNESS], [1,0.5,0.3,0]], // Colores m√°s atractivos
    [1000],0,0,"","",_spark1
];
_spark1 setDropInterval 0.005; // M√°s frecuente

// Chispas 2 - M√°s brillantes y duraderas
private _spark2 = "#particlesource" createVehicleLocal _pos;
_spark2 setParticleParams [
    ["\\A3\\data_f\\ParticleEffects\\Universal\\Universal.p3d",16,7,48,0],"","Billboard",
    0.001, 1.5 * SPARKLE_LIFE_MULT, [0,0,0], [0,14,0], 0,0.18,0.12,0.2,
    [0.28 * SPARKLE_SIZE_MULT, 0.15 * SPARKLE_SIZE_MULT],
    [[1,0.9,0.6,1 * SPARKLE_BRIGHTNESS], [1,0.8,0.5,0.8 * SPARKLE_BRIGHTNESS], [1,0.7,0.3,0]],
    [-2],1,0,"","",_spark2
];
_spark2 setDropInterval 0.0005; // Mucho m√°s frecuente

// Chispas adicionales - Tipo estrellas brillantes
private _sparkStars = "#particlesource" createVehicleLocal _pos;
_sparkStars setParticleParams [
    ["\\A3\\data_f\\ParticleEffects\\Universal\\Universal.p3d",16,12,8,0],"","Billboard",
    0.005, 2.5 * SPARKLE_LIFE_MULT, [0,0,0], 
    [random [-12,0,12], random [-12,0,12], random [3,6,9]], // Direcci√≥n m√°s aleatoria
    1, 0.1, 0.075, 0.1,
    [0.1 * SPARKLE_SIZE_MULT, 0.15 * SPARKLE_SIZE_MULT, 0.05 * SPARKLE_SIZE_MULT], // Tama√±o variable
    [
        [1,0.9,0.5,1 * SPARKLE_BRIGHTNESS], // Amarillo brillante  
        [1,0.6,0.3,0.8 * SPARKLE_BRIGHTNESS], // Naranja
        [1,0.3,0.2,0.4 * SPARKLE_BRIGHTNESS], // Rojo oscuro
        [0.5,0.1,0.1,0]  // Desvanecimiento
    ],
    [0.3,0.4,0.5,0.4,0.3,0.1], 1, 0, "", "", _sparkStars
];
_sparkStars setDropInterval 0.01;


// Funci√≥n adicional espec√≠fica para chispas intensas
[_pos, 1.8] call createIntenseSparkles; = {
    params ["_pos", ["_count", 25]];
    
    private _particleSource = "Land_HelipadEmpty_F" createVehicleLocal _pos;
    _particleSource setPosATL _pos;
    
    for "_i" from 1 to (_count * SPARKLE_COUNT_MULT) do {
        private _velX = random [-15,0,15];
        private _velY = random [-15,0,15];
        private _velZ = random [1,7,15];
        private _size = random [0.08, 0.15, 0.25] * SPARKLE_SIZE_MULT;
        private _lifeTime = random [1.5, 2.5, 3.5] * SPARKLE_LIFE_MULT;
        
        // Variedad de colores para chispas
        private _sparkColor = selectRandom [
            [[1.0,0.9,0.5,1],[1.0,0.7,0.3,0.6],[1.0,0.3,0.2,0]], // Amarillo-naranja
            [[0.9,0.9,1.0,1],[0.7,0.7,1.0,0.6],[0.3,0.3,0.6,0]], // Azul claro
            [[1.0,0.5,0.1,1],[1.0,0.3,0.0,0.6],[0.6,0.1,0.0,0]]  // Naranja intenso
        ];
        
        // Tama√±o variable durante la vida (crecer y luego encoger)
        private _sizeCoef = random [0.8, 1.0, 1.2];
        
        drop [
            ["\\A3\\data_f\\ParticleEffects\\Universal\\Universal.p3d", 16, 12, 8, 0],
            "", "Billboard", 1, _lifeTime,
            [0,0,0], [_velX, _velY, _velZ], 
            random 3, 0.06, 0.04, 0.05,
            [_size * 0.5, _size * _sizeCoef, _size * 0.2],
            _sparkColor,
            [0.08], 1, 0, "", "", _particleSource
        ];
    };
    
    // A√±adir un destello el√©ctrico visible
    drop [
        ["\\A3\\data_f\\ParticleEffects\\Universal\\Universal.p3d", 16, 2, 0, 0],
        "", "Billboard", 1, 0.3,
        [0,0,0], [0,0,0], 0, 0, 0, 0,
        [0.6 * SPARKLE_SIZE_MULT],
        [[1,1,1,1],[1,1,1,0]],
        [0.08], 1, 0, "", "", _particleSource
    ];
    
    _particleSource spawn { sleep 5; deleteVehicle _this; };
    true
};
    
// Humo oscuro principal - Crece mientras se eleva, menos denso
private _blackSmoke = "#particlesource" createVehicleLocal _pos;
_blackSmoke setParticleParams [
    ["\\A3\\data_f\\ParticleEffects\\Universal\\Universal.p3d",16,7,32,0],"","Billboard",
    0.07, 20.0 * SMOKE_LIFE_MULT, // Duraci√≥n aumentada
    [0,0,0], 
    [0,0,2.5] vectorMultiply SMOKE_WIND_RESISTANCE, // Elevaci√≥n lenta
    0, 0.04, 0.04, 0.05, // Menor turbulencia para mejor forma
    [
        6 * SMOKE_SIZE_MULT,         // Tama√±o inicial
        18 * SMOKE_SIZE_MULT,        // Tama√±o medio
        32 * SMOKE_SIZE_MULT,        // Tama√±o grande
        48 * SMOKE_SIZE_MULT,        // Tama√±o muy grande
        64 * SMOKE_SIZE_MULT         // Tama√±o m√°ximo (doble que antes)
    ], 
    [
        [0.1,0.1,0.1, 0.6],          // Negro inicial m√°s opaco
        [0.15,0.15,0.15, 0.5],       // Primera transici√≥n 
        [0.2,0.2,0.2, 0.4],          // Segunda transici√≥n
        [0.25,0.25,0.25, 0.3],       // Tercera transici√≥n
        [0.3,0.3,0.3, 0.2],          // Cuarta transici√≥n
        [0.35,0.35,0.35, 0.1],       // Quinta transici√≥n
        [0.4,0.4,0.4, 0]             // Final (transparente)
    ], 
    [0.1, 0.2, 0.3, 0.2, 0.1], 0.1, 0.1, "", "", _blackSmoke
];
_blackSmoke setDropInterval 0.05; // Menos part√≠culas para mejor rendimientoe

// Humo oscuro 2 - M√°s duradero y voluminoso
private _blackSmokeBase = "#particlesource" createVehicleLocal _pos;
_blackSmokeBase setParticleParams [
    ["\\A3\\data_f\\ParticleEffects\\Universal\\Universal.p3d",16,7,32,0],"","Billboard",
    0.05, 3.5 * SMOKE_LIFE_MULT,
    [0,0,0], 
    [0,0,1] vectorMultiply SMOKE_WIND_RESISTANCE,
    0, 0.04, 0.04, 0.05,
    [
        10 * SMOKE_SIZE_MULT,        // Base m√°s ancha
        20 * SMOKE_SIZE_MULT,        // Crecimiento medio
        30 * SMOKE_SIZE_MULT         // Tama√±o final
    ],
    [
        [0.05,0.05,0.05, 0.7],       // Casi negro, bastante opaco
        [0.1,0.1,0.1, 0.5],          // Transici√≥n
        [0.15,0.15,0.15, 0.3],       // Transici√≥n
        [0.2,0.2,0.2, 0]             // Desvanecimiento
    ], 
    [0.1], 0.1, 0.1, "", "", _blackSmokeBase
];
_blackSmokeBase setDropInterval 0.08; // Menos frecuente para mejor rendimiento

// Humo duradero 1 - Aumentar dr√°sticamente duraci√≥n y estabilidad
private _smokL1 = "#particlesource" createVehicleLocal _pos;
_smokL1 setParticleParams [
    ["\\A3\\data_f\\ParticleEffects\\Universal\\Universal.p3d",16,7,48,0],"","Billboard",
    0.3, 30 * SMOKE_LIFE_MULT, // Super duradero
    [0,0,0], 
    [0,2.5,0] vectorMultiply (SMOKE_WIND_RESISTANCE * 0.7), // Muy estable, casi no afectado
    0, 0.06, 0.05, 0.03,
    [3.6 * SMOKE_SIZE_MULT, 8.4 * SMOKE_SIZE_MULT, 12 * SMOKE_SIZE_MULT],
    [
        [0.1,0.1,0.1, 0.7 * SMOKE_DENSITY_MULT],
        [0.2,0.2,0.2, 0.5 * SMOKE_DENSITY_MULT],
        [0.3,0.3,0.3, 0.4 * SMOKE_DENSITY_MULT],
        [0.4,0.4,0.4, 0.3 * SMOKE_DENSITY_MULT],
        [0.5,0.5,0.5, 0.2 * SMOKE_DENSITY_MULT],
        [0.6,0.6,0.6, 0.1 * SMOKE_DENSITY_MULT],
        [0.7,0.7,0.7, 0]
    ],
    [0.6, 0.3, 0.1], 0.5, 0, "", "", _smokL1
];
_smokL1 setDropInterval 0.02; // M√°s frecuente

// Funci√≥n adicional para columna de humo persistente
createPersistentSmoke = {
    params ["_pos", ["_duration", 120]];
    
    private _particleSource = "Land_HelipadEmpty_F" createVehicleLocal _pos;
    _particleSource setPosATL _pos;
    
    // Columna principal de humo
    private _smoke = "#particlesource" createVehicleLocal _pos;
    _smoke attachTo [_particleSource, [0,0,0]];
    _smoke setParticleParams [
        ["\\A3\\data_f\\ParticleEffects\\Universal\\Universal.p3d", 16, 7, 48, 1],
        "", "Billboard", 1, 
        15 * SMOKE_LIFE_MULT, // Tiempo de vida extremadamente largo
        [0, 0, 0],
        [0, 0, 1.5] vectorMultiply (SMOKE_WIND_RESISTANCE * 0.5), // Muy poco afectado por viento
        0, 0.05, 0.04, 0.02,
        [1 * SMOKE_SIZE_MULT, 3 * SMOKE_SIZE_MULT, 5 * SMOKE_SIZE_MULT, 7 * SMOKE_SIZE_MULT],
        [
            [0.1, 0.1, 0.1, 0.8 * SMOKE_DENSITY_MULT],
            [0.2, 0.2, 0.2, 0.6 * SMOKE_DENSITY_MULT],
            [0.3, 0.3, 0.3, 0.4 * SMOKE_DENSITY_MULT],
            [0.4, 0.4, 0.4, 0.3 * SMOKE_DENSITY_MULT],
            [0.5, 0.5, 0.5, 0.2 * SMOKE_DENSITY_MULT],
            [0.6, 0.6, 0.6, 0]
        ],
        [0.1, 0.2, 0.3], 0.5, 0.2, "", "", _particleSource
    ];
    _smoke setDropInterval 0.1;
    
    // Humo m√°s ancho en la base
    private _smokeBase = "#particlesource" createVehicleLocal _pos;
    _smokeBase attachTo [_particleSource, [0,0,0]];
    _smokeBase setParticleParams [
        ["\\A3\\data_f\\ParticleEffects\\Universal\\Universal.p3d", 16, 7, 48, 1],
        "", "Billboard", 1,
        20 * SMOKE_LIFE_MULT,
        [0, 0, 0],
        [0, 0, 0.5] vectorMultiply (SMOKE_WIND_RESISTANCE * 0.3),
        0, 0.05, 0.04, 0.02,
        [3 * SMOKE_SIZE_MULT, 5 * SMOKE_SIZE_MULT, 7 * SMOKE_SIZE_MULT],
        [
            [0.1, 0.1, 0.1, 0.7 * SMOKE_DENSITY_MULT],
            [0.2, 0.2, 0.2, 0.5 * SMOKE_DENSITY_MULT],
            [0.3, 0.3, 0.3, 0.3 * SMOKE_DENSITY_MULT],
            [0.4, 0.4, 0.4, 0]
        ],
        [0.1], 0.5, 0.2, "", "", _particleSource
    ];
    _smokeBase setDropInterval 0.2;
    
    // Destruir despu√©s del tiempo especificado
    [_particleSource, _smoke, _smokeBase, _duration] spawn {
        params ["_source", "_smoke1", "_smoke2", "_time"];
        sleep _time;
        deleteVehicle _smoke1;
        deleteVehicle _smoke2;
        sleep 5;
        deleteVehicle _source;
    };
    
    // Retornar el objeto fuente para referencia
    _particleSource
};
    
    // Humo duradero 2
    private _smokL2 = "#particlesource" createVehicleLocal _pos;
    _smokL2 setParticleParams [
        ["\\A3\\data_f\\ParticleEffects\\Universal\\Universal.p3d",16,7,48,0],"","Billboard",
        0.008,185,[0,0,0],[0,12,0],0,12.1,9.5,1.2,[7.2,18],[[0.1,0.1,0.1,0.7],[0.2,0.2,0.2,0.5],[0.3,0.3,0.3,0.4],[0.4,0.4,0.4,0.3],[0.6,0.6,0.6,0]],[0.011],1,0,"","",_smokL2
    ];
    _smokL2 setDropInterval 0.06;
    
    // Humo duradero 3
    private _smokL3 = "#particlesource" createVehicleLocal _pos;
    _smokL3 setParticleParams [
        ["\\A3\\data_f\\ParticleEffects\\Universal\\Universal.p3d",16,7,48,0],"","Billboard",
        0.008,185,[0,0,0],[0,6,0],0,12.1,9.5,1.2,[7.2,18],[[0.1,0.1,0.1,0.7],[0.2,0.2,0.2,0.5],[0.3,0.3,0.3,0.4],[0.4,0.4,0.4,0.3],[0.6,0.6,0.6,0]],[0.011],1,0,"","",_smokL3
    ];
    _smokL3 setDropInterval 0.05;
    
    // Bola de fuego 1
    private _ball1 = "#particlesource" createVehicleLocal _pos;
    _ball1 setParticleParams [
        ["\\A3\\data_f\\ParticleEffects\\Universal\\Universal.p3d",16,2,32,0],"","Billboard",
        0.01,4.2,[0,0,0],[0,12,0],12.1,12.1,9.5,1.2,[0,2.4,4.8,4.8,4.8,4.8,4.8],[[1,1,1,-1],[1,1,1,0]],[0.011],1,0,"","",_ball1
    ];
    _ball1 setDropInterval 0.08;
    
    // Bola de fuego 2
    private _ball2 = "#particlesource" createVehicleLocal _pos;
    _ball2 setParticleParams [
        ["\\A3\\data_f\\ParticleEffects\\Universal\\Universal.p3d",16,2,32,0],"","Billboard",
        0.025,4.2,[0,0,0],[0,12,0],12.1,12.1,9.5,1.2,[1.56,1.56,1.56],[[1,1,1,1],[1,1,1,0]],[0.06],1,0,"","",_ball2
    ];
    _ball2 setDropInterval 0.09;
    
    // Bola de fuego 3
    private _ball3 = "#particlesource" createVehicleLocal _pos;
    _ball3 setParticleParams [
        ["\\A3\\data_f\\ParticleEffects\\Universal\\Universal.p3d",16,2,32,0],"","Billboard",
        0.005,4.2,[0,0,0],[0,18,0],12.1,12.1,9.5,1.2,[1.2,4.8,0],[[1,1,0.2,-2],[1,1,1,0]],[1.8],1,0,"","",_ball3
    ];
    _ball3 setDropInterval 0.04;
    
    // --- LUCES ---
    // Luz principal
    private _light1 = "#lightpoint" createVehicleLocal _pos;
    _light1 setLightBrightness 0.84;
    _light1 setLightAmbient [0.36,0.36,0.36];
    _light1 setLightColor [0.84,0.84,0.84];
    _light1 setLightFlareSize 84;
    _light1 setLightFlareMaxDistance 3600;
    _light1 setLightUseFlare false;
    
    // Luz secundaria (tono c√°lido)
    private _light2 = "#lightpoint" createVehicleLocal _pos;
    _light2 setLightBrightness 0.54;
    _light2 setLightAmbient [0.12,0.048,0.018];
    _light2 setLightColor [1,0.54,0.18];
    _light2 setLightFlareSize 36;
    _light2 setLightFlareMaxDistance 3600;
    _light2 setLightUseFlare false;
    
    // Limpiar entidades despu√©s de tiempo
    [_spark1, _spark2, _smok1, _smok2, _explPar, _smokL1, _smokL2, _smokL3, _ball1, _ball2, _ball3, _light1, _light2] spawn {
        params ["_sp1", "_sp2", "_sm1", "_sm2", "_exp", "_sl1", "_sl2", "_sl3", "_b1", "_b2", "_b3", "_l1", "_l2"];
        sleep 0.3; 
        { deleteVehicle _x } forEach [_sp1, _sp2, _sm1, _sm2, _exp];
        sleep 0.5;
        { deleteVehicle _x } forEach [_l1, _l2];
        sleep 2.0;
        { deleteVehicle _x } forEach [_sl1, _sl2, _sl3, _b1, _b2, _b3];
    };
    
    // Retornar √©xito
    true
};

// ======================================================
// EFECTOS DE VAPOR PARA AERONAVES
// ======================================================

vapourEffect = {
    params ["_v"];
    
    if (typeName _v != "OBJECT" || {isNull _v}) exitWith {false};
    
    sleep (0.1 + random 0.2);
    
    private _trail1 = objNull;
    private _trail2 = objNull;
    private _fusv1 = objNull;
    private _fusv2 = objNull;
    
    // Crear part√≠culas en puntas de ala si existen puntos de memoria
    if (([0,0,0] distance (_v selectionPosition "cerveny pozicni")) != 0) then {
        _trail1 = "#particlesource" createVehicleLocal (_v modelToWorld [0,0,0]);
        _trail1 attachTo [_v, [0,0,0], "cerveny pozicni"];
        _trail1 setParticleRandom [0.25, [0.08,0.08,0.08], [0,0,0], 0, 0, [0,0,0,0], 0, 0];
        
        _trail2 = "#particlesource" createVehicleLocal (_v modelToWorld [0,0,0]);
        _trail2 attachTo [_v, [0,0,0], "zeleny pozicni"];
        _trail2 setParticleRandom [0.25, [0.08,0.08,0.08], [0,0,0], 0, 0, [0,0,0,0], 0, 0];
    };
    if (isNull _trail1) exitWith {false};
    
    // Recoger par√°metros de segmento y validar puntos de memoria
    private _posLS = _v selectionPosition "body_vapour_L_S";
    private _posLE = _v selectionPosition "body_vapour_L_E";
    private _posRS = _v selectionPosition "body_vapour_R_S";
    private _posRE = _v selectionPosition "body_vapour_R_E";
    
    if (_posLS isEqualTo [0,0,0] || _posLE isEqualTo [0,0,0] || _posRS isEqualTo [0,0,0] || _posRE isEqualTo [0,0,0]) exitWith {false};
    
    // Preparar emisores del fuselaje
    _fusv1 = "#particlesource" createVehicleLocal (_v modelToWorld _posLS);
    _fusv2 = "#particlesource" createVehicleLocal (_v modelToWorld _posRS);
    
    _fusv1 attachTo [_v, [0,0,0], "body_vapour_L_S"];
    _fusv2 attachTo [_v, [0,0,0], "body_vapour_R_S"];
    
    private _lgap = _posLS distance _posLE;
    private _rgap = _posRS distance _posRE;
    
    if (_lgap <= 0 || _rgap <= 0) exitWith {false};
    
    private _lemmiters = [_fusv1];
    private _remmiters = [_fusv2];
    
    // Crear emisores intermedios (m√°s densos)
    private _i = 0;
    private _step = 0.8;
    private _xd = (_posLE select 0) - (_posLS select 0);
    private _yd = (_posLE select 1) - (_posLS select 1);
    private _zd = (_posLE select 2) - (_posLS select 2);
    while {_i < _lgap} do {
        private _pe = "#particlesource" createVehicleLocal (_v modelToWorld [0,0,0]);
        _pe setParticleRandom [0.25, [0.08,0.08,0.08], [0,0,0], 0, 0.25, [0,0,0,0], 0, 0];
        _pe attachTo [_v, [_posLS select 0 + _i * (_xd/_lgap), _posLS select 1 + _i * (_yd/_lgap), _posLS select 2 + _i * (_zd/_lgap)]];
        _lemmiters pushBack _pe;
        _i = _i + _step;
    };
    
    _i = 0;
    _xd = (_posRE select 0) - (_posRS select 0);
    _yd = (_posRE select 1) - (_posRS select 1);
    _zd = (_posRE select 2) - (_posRS select 2);
    while {_i < _rgap} do {
        private _pe = "#particlesource" createVehicleLocal (_v modelToWorld [0,0,0]);
        _pe setParticleRandom [0.25, [0.08,0.08,0.08], [0,0,0], 0, 0.25, [0,0,0,0], 0, 0];
        _pe attachTo [_v, [_posRS select 0 + _i * (_xd/_rgap), _posRS select 1 + _i * (_yd/_rgap), _posRS select 2 + _i * (_zd/_rgap)]];
        _remmiters pushBack _pe;
        _i = _i + _step;
    };
    
    // Bucle principal de actualizaci√≥n
    [_v, _trail1, _trail2, _lemmiters, _remmiters] spawn {
        params ["_v", "_t1", "_t2", "_lems", "_rems"];
        
        while {alive _v} do {
            private _vel = velocity _v;
            private _speed = sqrt ((_vel select 0)^2 + (_vel select 1)^2 + (_vel select 2)^2);
            
            if (_speed > 45) then {
                sleep 0.05;
                
                private _pitchvel = abs ((velocity _v select 2) atan2 (_vel select 0 + _vel select 1));
                private _vdir = vectorDir _v;
                private _pitch = abs ((_vdir select 2) atan2 ((_vdir select 0) + (_vdir select 1)));
                private _dirvel = abs ((velocity _v select 0) atan2 (velocity _v select 1));
                private _dir = getDir _v;
                if (_dir > 180) then {_dir = 360 - _dir};
                
                private _aoa = abs(_pitch - _pitchvel) + abs(_dir - _dirvel);
                private _interval = 1 / (_speed * 2.8);
                private _intensity = (_aoa * (_speed / 3500)) min 3.5;
                
                if (_intensity > 0.25) then {
                    private _particleSize = [0.8, 0.5] * (0.7 + (_intensity * 0.3));
                    private _particleLife = 0.65 * _intensity;
                    
                    {
                        _x setDropInterval _interval;
                        _x setParticleParams [
                            ["\A3\data_f\ParticleEffects\Universal\Universal.p3d", 16, 13, 3, 0],
                            "", "Billboard", 1, _particleLife,
                            [0, 0, 0], velocity _v, 0, 1.2, 0.85, 0, 
                            _particleSize, 
                            [[1,1,1,0.1], [1,1,1,0.12], [1,1,1,0.08], [1,1,1,0]], 
                            [1000], 0, 0, "", "", _v
                        ];
                    } forEach (_t1 + _t2);
                    
                    {
                        _x setDropInterval _interval;
                        _x setParticleParams [
                            ["\A3\data_f\ParticleEffects\Universal\Universal.p3d", 16, 13, 3, 0],
                            "", "Billboard", 1, _particleLife * 0.8,
                            [0, 0, 0], velocity _v, 0, 1.1, 0.8, 0, 
                            _particleSize * 0.9, 
                            [[1,1,1,0.1], [1,1,1,0.12], [1,1,1,0.08], [1,1,1,0]], 
                            [1000], 0, 0, "", "", _v
                        ];
                    } forEach (_lems + _rems);
                } else {
                    {_x setDropInterval 0} forEach (_t1 + _t2 + _lems + _rems);
                };
            } else {
                sleep 0.75;
            };
        };
    };
    
    // Limpiar al apagar motor
    _v addEventHandler ["Engine", {
        params ["_veh", "_engineOn"];
        if (!_engineOn) then {
            {
                if !(isNull _x) then {deleteVehicle _x};
            } forEach (_veh getVariable ["vapourSources", []]);
        };
    }];
    
    _v setVariable ["vapourSources", [_trail1, _trail2, _fusv1, _fusv2] + _lemmiters + _remmiters];
    true
};

// ======================================================
// EFECTOS DE REFRACCI√ìN GRANDES
// ======================================================

buchedegatitoRefractLarge = {
    params ["_particlePos"];
    
    private _strength = 1.2;  // Aumentado de 1.0
    
    // Convertir posici√≥n AGL a ASL
    private _particleASL = AGLtoASL _particlePos;
    
    // Crear objeto auxiliar invisible
    private _particleSource = createSimpleObject ["Land_HelipadEmpty_F", _particleASL, true];
    
    // Crear efecto de onda refractiva mejorado
    drop [
        ["\A3\data_f\ParticleEffects\Universal\Refract", 1, 0, 1, 0],
        "", "Billboard", 1, 0.48 * _strength,
        [0, 0, 0], 
        [0, 0, 0],
        0,
        12,
        9.5,
        0.12,
        [2.4, 2.4, 28.8, 72, 126, 180, 252], // Tama√±os aumentados 20%
        [
            [0.15, 0.15, 0.15, 1],
            [0.3, 0.3, 0.3, 1],
            [0.6, 0.6, 0.6, 1],
            [0, 0, 0, 1],
            [0, 0, 0, 0.6],
            [0, 0, 0, 0.4]
        ],
        [1],
        0.24, 0.24,
        "", "",
        _particleSource,
        1, false,
        -1, [],
        [0, 1, 0]
    ];
    
    // Eliminar objeto auxiliar
    deleteVehicle _particleSource;
    true
};

// ======================================================
// EFECTOS DE IMPLOSI√ìN / ANILLOS DE CONVERGENCIA
// ======================================================

bombRefractEffect = {
    // Configuraci√≥n del efecto mejorada
    #define DIST_FROM_CENTER 14.4      // Aumentado de 12.0
    #define DIST_VARIATION 6.0         // Aumentado de 5.0
    #define VELOCITY_REDUCTION 1.4     // Ajustado para velocidad √≥ptima
    #define STARTING_HEIGHT 0.06       // Aumentado ligeramente
    #define VELOCITY_DOWN 0            // Mantener plano
    #define DIR_STEP_SIZE 7            // Reducido de 8 para m√°s part√≠culas
    
    private _expCenter = _this;
    
    // Crear objeto invisible que sirve como fuente de referencia
    private _particleSource = "Land_HelipadEmpty_F" createVehicleLocal [0, 0, 0];
    _particleSource enableSimulation false;
    _particleSource setPosASL (AGLtoASL _expCenter);
    
    // Calcular las direcciones radiales
    private _directions = [];
    for "_i" from 0 to 360 step DIR_STEP_SIZE do {
        _directions pushBack [sin _i, cos _i, 0];
    };
    
    // Generar part√≠culas mejoradas
    {
        private _randomX = random [-DIST_VARIATION, 0, DIST_VARIATION];
        private _randomY = random [-DIST_VARIATION, 0, DIST_VARIATION];
        private _currentPosition = [
            (DIST_FROM_CENTER * (_x # 0)) + _randomX,
            (DIST_FROM_CENTER * (_x # 1)) + _randomY,
            STARTING_HEIGHT
        ];
        private _currentDirection = [
            (_x # 0)/-VELOCITY_REDUCTION,
            (_x # 1)/-VELOCITY_REDUCTION,
            -VELOCITY_DOWN
        ];
        
        drop [
            ["\A3\data_f\ParticleEffects\Universal\smoke_2", 1, 0, 1, 1],
            "", "Billboard", 1, 9.5,
            _currentPosition,
            _currentDirection,
            0, 0.06, 0.05, 0.015,
            [1.2, 6.0],
            [
                [0.33, 0.27, 0.22, 0.42],
                [0.66, 0.55, 0.44, 0]
            ],
            [1],
            1, 0.25,
            "", "",
            _particleSource,
            0, false,
            -1, [],
            [0, 1, 0]
        ];
    } forEach _directions;
    
    deleteVehicle _particleSource;
    true
};

// ======================================================
// EFECTOS DE CALOR / DISTORSI√ìN T√âRMICA
// ======================================================

heatHazeEffect = {
    private _particlePos = _this;
    
    if (player distance _particlePos > 120) exitWith {false}; // Aumentado de 100
    
    // Fuente del efecto
    private _particleSource = createSimpleObject ["Land_HelipadEmpty_F", AGLtoASL _particlePos, true];
    
    // Variaci√≥n de tama√±o aleatoria (aumentada)
    private _sizeVar = random [0.6, 1.2, 1.8];
    
    // Temperatura - efecto m√°s intenso
    private _airTemp = 0.24;
    private _weatherEffect = true;
    
    if (_weatherEffect) then {
        _airTemp = (ambientTemperature # 0) / 90; // Modificado de 100 para m√°s intensidad
    };
    
    // Rango de efecto aumentado
    _airTemp = (_airTemp max 0.18) min 0.54; // Aumentado de 0.15-0.45
    
    // Crear efecto de distorsi√≥n mejorado
    drop [
        ["\A3\data_f\ParticleEffects\Universal\Refract", 1, 0, 1, 0],
        "", "Billboard", 0, 1.0, // Vida aumentada de 0.85
        [0,0,0],
        [0,0,0],
        1, 1.5, 1.2, 0.08, // Valores ajustados
        [_sizeVar],
        [
            [0.07, 0.07, 0.07, _airTemp],
            [0.36, 0.36, 0.36, _airTemp - 0.3],
            [0.36, 0.36, 0.36, _airTemp - 0.6],
            [0.36, 0.36, 0.36, _airTemp - 0.9],
            [0.36, 0.36, 0.36, _airTemp - 0.15]
        ],
        [1],
        0.12, 0.025,
        "", "",
        _particleSource,
        1, false,
        -1, [],
        [0,1,0]
    ];
    
    deleteVehicle _particleSource;
    true
};

// ======================================================
// EFECTOS DE EXPLOSI√ìN CON FRAGMENTOS F√çSICOS
// ======================================================

buchedegatitoRefractWithDebris = {
    params ["_particlePos", "_size"];
    
    private _strength = 1.2; // Aumentado de 1.0
    
    private _particleSource = createSimpleObject ["Land_HelipadEmpty_F", AGLtoASL _particlePos, true];
    
    private _dropParams = switch (_size) do {
        case "medium": {
            [0.36 * _strength, [1.2,1.2,7.2,14.4,28.8,38.4,57.6]] // Aumentados 20%
        };
        case "small": {
            [0.15 * _strength, [1.2,2.4,6.0,9.6,14.4,20.4]] // Aumentados 20%
        };
        case "tiny": {
            [0.12 * _strength, [0.6,1.2,3.0,4.8,7.2,10.2]] // Aumentados 20%
        };
        case "large": {
            [0.48 * _strength, [2.4,2.4,28.8,72,126,180,252]] // Aumentados 20%
        };
        default {
            [0.24 * _strength, [1.2,1.2,7.2,14.4,28.8,38.4,57.6]]
        };
    };
    
    private _lifeTime = _dropParams select 0;
    private _sizeArray = _dropParams select 1;
    
    // Onda de refracci√≥n principal
    drop [
        ["\A3\data_f\ParticleEffects\Universal\Refract", 1, 0, 1, 0],
        "", "Billboard", 1, _lifeTime,
        [0,0,0], [0,0,0],
        0, 12, 9.5, 0.12,
        _sizeArray,
        [
            [0.15,0.15,0.15,1],[0.3,0.3,0.3,1],
            [0.6,0.6,0.6,1],[0,0,0,1],
            [0,0,0,0.6],[0,0,0,0.4]
        ],
        [1], 0.25, 0.25,
        "", "", _particleSource, 1, false, -1, [], [0,1,0]
    ];
    
    // Efectos vanilla complementarios mejorados:
    
    // Fragmentos de piedra (m√°s grandes y veloces)
    drop [
        ["\A3\data_f\ParticleEffects\Pstone\Data\pstone_nohq.paa", 1, 0, 1], 
        "", "Billboard", 1.8, 1.4, 
        [0,0,0], [random 0.5 - 0.25, random 0.5 - 0.25, random 1.5], 
        random 3, 0.6, 0.6, 0.12, 
        [0.24, 0.18, 0.12] * PARTICLE_SIZE_MULT, 
        [[0.7,0.7,0.7,1],[0.4,0.4,0.4,0.6],[0,0,0,0]], 
        [0.8], 0.3, 0.3, "", "", _particleSource
    ];
    
    // Chispa brillante (m√°s intensa)
    drop [
        ["#(argb,8,8,3)color(1,0.2,0.2,1)", 1, 0, 1], 
        "", "Billboard", 0.7, 0.95, 
        [0,0,0], [random 0.5 - 0.25, random 0.5 - 0.25, random 0.8], 
        random 2, 1.2, 1.2, 0.24, 
        [0.12, 0.06] * PARTICLE_SIZE_MULT, 
        [[1,0.2,0.2,1],[1,0.1,0.1,0.6],[0,0,0,0]], 
        [1.2], 0.24, 0.24, "", "", _particleSource
    ];
    
    // Carb√≥n incandescente (m√°s rojo)
    drop [
        ["#(argb,8,8,3)color(1,0.4,0,1)", 1, 0, 1], 
        "", "Billboard", 1.8, 3.0, 
        [0,0,0], [random 0.3 - 0.15, random 0.3 - 0.15, 0.1 + random 0.2], 
        random 2, 0.6, 0.6, 0.12, 
        [0.6, 0.48, 0.36] * PARTICLE_SIZE_MULT, 
        [[1,0.4,0,1],[0.5,0.2,0,0.7],[0,0,0,0]], 
        [1.2], 0.36, 0.36, "", "", _particleSource
    ];
    
    // Glow superficial (m√°s brillante)
    drop [
        ["#(argb,8,8,3)color(1,1,1,0.8)", 1, 0, 1], 
        "", "Billboard", 2.4, 1.4, 
        [0,0,0], [0,0,0], 
        0, 0.12, 0.12, 0.06, 
        [0.48, 0.36, 0.12] * PARTICLE_SIZE_MULT, 
        [[1,1,1,0.85],[1,1,1,0.5],[1,1,1,0]], 
        [1.2], 0.12, 0.12, "", "", _particleSource
    ];
    
    // Fragmentos de carne (m√°s realistas)
    drop [
        ["#(argb,8,8,3)color(0.5,0.1,0.1,1)", 1, 0, 1], 
        "", "Billboard", 1.2, 1.8, 
        [0,0,0], [random 0.5 - 0.25, random 0.5 - 0.25, 0.2 + random 0.3], 
        random 2, 0.36, 0.48, 0.06, 
        [0.24, 0.18, 0.06] * PARTICLE_SIZE_MULT, 
        [[0.5,0.1,0.1,1],[0.2,0.05,0.05,0.6],[0,0,0,0]], 
        [1.0], 0.24, 0.18, "", "", _particleSource
    ];
    
    // Fragmentos de vidrio (m√°s brillantes)
    drop [
        ["#(argb,8,8,3)color(0.5,0.5,1,0.8)", 1, 0, 1], 
        "", "Billboard", 1.2, 1.45, 
        [0,0,0], [random 0.5 - 0.25, random 0.5 - 0.25, 0.1 + random 0.2], 
        random 3, 0.48, 0.48, 0.12, 
        [0.24, 0.12] * PARTICLE_SIZE_MULT, 
        [[0.5,0.5,1,0.85],[0.2,0.2,0.5,0.5],[0,0,0,0]], 
        [1.2], 0.12, 0.12, "", "", _particleSource
    ];
    
    // Luz base explosiva (m√°s intensa)
    drop [
        ["#(argb,8,8,3)color(1,0.5,0,1)", 1, 0, 1], 
        "", "Billboard", 0.6, 0.96, 
        [0,0,0], [0,0,0], 
        0, 0.72, 0.6, 0.12, 
        [0.24, 0.06] * PARTICLE_SIZE_MULT, 
        [[1,0.5,0,1],[1,0.2,0,0.7],[0,0,0,0]], 
        [1.2], 0.36, 0.36, "", "", _particleSource
    ];
    
    // Fragmentos de madera (m√°s voluminosos)
    drop [
        ["#(argb,8,8,3)color(0.4,0.3,0.2,1)", 1, 0, 1], 
        "", "Billboard", 1.8, 2.4, 
        [0,0,0], [random 0.3 - 0.15, random 0.3 - 0.15, 0.05 + random 0.1], 
        random 2, 0.6, 0.48, 0.12, 
        [0.3, 0.24, 0.12] * PARTICLE_SIZE_MULT, 
        [[0.4,0.3,0.2,1],[0.2,0.15,0.1,0.7],[0,0,0,0]], 
        [1.0], 0.24, 0.24, "", "", _particleSource
    ];
    
    deleteVehicle _particleSource;
    true
};

// ======================================================
// EFECTOS DE EXPLOSI√ìN M√öLTIPLES FASES
// ======================================================

multiphasebuchedegatitoEffect = {
    params ["_particlePos", "_size"];
    
    private _strength = 1.2; // Aumentado de 1.0
    
    private _particleSource = createSimpleObject ["Land_HelipadEmpty_F", AGLtoASL _particlePos, true];
    
    private _dropParams = switch (_size) do {
        case "tiny":   {[0.12 * _strength, [0.6,1.2,3.0,4.8,7.2,10.2]]};
        case "small":  {[0.15 * _strength, [1.2,2.4,6.0,9.6,14.4,20.4]]};
        case "medium": {[0.36 * _strength, [1.2,1.2,7.2,14.4,28.8,38.4,57.6]]};
        case "large":  {[0.48 * _strength, [2.4,2.4,28.8,72,126,180,252]]};
        default        {[0.24 * _strength, [1.2,1.2,7.2,14.4,28.8,38.4,57.6]]};
    };
    
    private _lifeTime = _dropParams select 0;
    private _sizeArray = _dropParams select 1;
    
    // ==================================================
    // FASE 1: ONDA REFRACTIVA + LUZ INICIAL
    // ==================================================
    drop [
        ["\A3\data_f\ParticleEffects\Universal\Refract", 1, 0, 1, 0],
        "", "Billboard", 1, _lifeTime,
        [0,0,0], [0,0,0],
        0, 12, 9.5, 0.12,
        _sizeArray,
        [[0.15,0.15,0.15,1],[0.6,0.6,0.6,1],[0,0,0,1],[0,0,0,0.4]],
        [1], 0.25, 0.25, "", "", _particleSource, 1, false, -1, [], [0,1,0]
    ];
    
    // Flash explosivo (m√°s brillante)
    drop [
        ["#(argb,8,8,3)color(1,1,1,0.85)", 1, 0, 1], 
        "", "Billboard", 0.24, 0.12, 
        [0,0,0], [0,0,0], 
        0, 1.2, 1.2, 0, 
        [3.0 * PARTICLE_SIZE_MULT], 
        [[1,1,1,0.85],[1,1,1,0]], 
        [1.2], 0, 0, "", "", _particleSource
    ];
    
    // ==================================================
    // FASE 2: FRAGMENTACI√ìN MEJORADA
    // ==================================================
    private _frags = [
        // Piedra (mejorado)
        ["#(argb,8,8,3)color(0.7,0.7,0.7,1)", [0.24,0.18,0.12] * PARTICLE_SIZE_MULT],
        // Carne (mejorado) 
        ["#(argb,8,8,3)color(0.5,0.1,0.1,1)", [0.24,0.18,0.06] * PARTICLE_SIZE_MULT],
        // Vidrio (mejorado)
        ["#(argb,8,8,3)color(0.5,0.5,1,0.85)", [0.24,0.12] * PARTICLE_SIZE_MULT],
        // Madera (mejorado)
        ["#(argb,8,8,3)color(0.4,0.3,0.2,1)", [0.3,0.24,0.12] * PARTICLE_SIZE_MULT]
    ];
    
    {
        private _tex = _x select 0;
        private _sizes = _x select 1;
        
        for "_i" from 0 to floor(3 * PARTICLE_COUNT_MULT) do {
            drop [
                [_tex, 1, 0, 1], 
                "", "Billboard", 
                1.8, 1.45, 
                [0,0,0], 
                [random 0.3 - 0.15, random 0.3 - 0.15, random 0.5], 
                random 2, 
                0.48, 0.48, 0.12, 
                _sizes, 
                [[1,1,1,1],[0,0,0,0.36],[0,0,0,0]], 
                [1.0], 
                0.24, 0.24, 
                "", "", _particleSource
            ];
        };
    } forEach _frags;
    
    // ==================================================
    // FASE 3: EFECTOS VISUALES MEJORADOS
    // ==================================================
    
    // Glow central (m√°s brillante)
    drop [
        ["#(argb,8,8,3)color(1,1,1,0.7)", 1, 0, 1], 
        "", "Billboard", 
        2.4, 1.8, 
        [0,0,0], [0,0,0], 
        0, 0.12, 0.12, 0.06, 
        [0.36, 0.12] * PARTICLE_SIZE_MULT, 
        [[1,1,1,0.7],[1,1,1,0.36],[1,1,1,0]], 
        [1.2], 
        0.12, 0.12, 
        "", "", _particleSource
    ];
    
    // Chispas tipo T800 (m√°s numerosas)
    for "_i" from 0 to floor(4 * PARTICLE_COUNT_MULT) do {
        drop [
            ["#(argb,8,8,3)color(1,0.2,0.2,1)", 1, 0, 1], 
            "", "Billboard", 
            0.72, 0.95, 
            [0,0,0], 
            [random 0.3 - 0.15, random 0.3 - 0.15, random 0.4], 
            random 2, 
            1.2, 1.2, 0.24, 
            [0.12, 0.06] * PARTICLE_SIZE_MULT, 
            [[1,0.2,0.2,1],[1,0.1,0.1,0.6],[0,0,0,0]], 
            [1.2], 
            0.24, 0.24, 
            "", "", _particleSource
        ];
    };
    
    // Carb√≥n incandescente (m√°s brillante)
    for "_i" from 0 to floor(3 * PARTICLE_COUNT_MULT) do {
        drop [
            ["#(argb,8,8,3)color(1,0.4,0,1)", 1, 0, 1], 
            "", "Billboard", 
            1.8, 3.0, 
            [0,0,0], 
            [random 0.25 - 0.125, random 0.25 - 0.125, random 0.3], 
            random 1.5, 
            0.6, 0.6, 0.12, 
            [0.6, 0.48, 0.36] * PARTICLE_SIZE_MULT, 
            [[1,0.4,0,1],[0.5,0.2,0,0.7],[0,0,0,0]], 
            [1.2], 
            0.36, 0.36, 
            "", "", _particleSource
        ];
    };
    
    // ==================================================
    // FASE 4: SONIDO (MEJORADO)
    // ==================================================
    playSound3D ["A3\Sounds_F\weapons\Explosion\expl_big_2.wss", objNull, false, _particlePos, 3.6, 1, 120];
    
    // Eco a distancia con retardo
    [_particlePos] spawn {
        params ["_pos"];
        sleep 0.6; // Retardo ligeramente superior
        playSound3D ["A3\Sounds_F\weapons\Explosion\expl_big_distance_01.wss", objNull, false, _pos, 2.4, 0.9, 240];
    };
    
    // ==================================================
    // FASE 5: EFECTOS SECUNDARIOS
    // ==================================================
    
    // Polvo residual
    [_particlePos, _particleSource] spawn {
        params ["_pos", "_source"];
        sleep 1.0;
        
        drop [
            ["#(argb,8,8,3)color(0.4,0.4,0.4,0.36)", 1, 0, 1], 
            "", "Billboard", 
            4.8, 2.4, 
            [0,0,0], [0,0,0.24], 
            0, 0.24, 0.24, 0.06, 
            [3.0, 2.4, 1.2] * PARTICLE_SIZE_MULT, 
            [[0.4,0.4,0.4,0.36],[0.2,0.2,0.2,0.12],[0,0,0,0]], 
            [1.0], 
            0.12, 0.12, 
            "", "", _source
        ];
    };
    
    deleteVehicle _particleSource;
    true
};

// ======================================================
// EFECTOS DE EXPLOSI√ìN EXTREMA
// ======================================================

extremeExplosionEffect = {
    params ["_particlePos", "_size"];
    
    private _strength = 1.2;
    
    private _particleSource = createSimpleObject ["Land_HelipadEmpty_F", AGLtoASL _particlePos, true];
    
    private _dropParams = switch (_size) do {
        case "medium": {
            [0.36 * _strength, [1.2,1.2,7.2,14.4,28.8,38.4,57.6]]
        };
        case "small": {
            [0.15 * _strength, [1.2,2.4,6.0,9.6,14.4,20.4]]
        };
        case "tiny": {
            [0.12 * _strength, [0.6,1.2,3.0,4.8,7.2,10.2]]
        };
        case "large": {
            [0.48 * _strength, [2.4,2.4,28.8,72,126,180,252]]
        };
        default {
            [0.24 * _strength, [1.2,1.2,7.2,14.4,28.8,38.4,57.6]]
        };
    };
    
    private _lifeTime = _dropParams select 0;
    private _sizeArray = _dropParams select 1;
    
    // Onda de refracci√≥n extremadamente mejorada
    drop [
        ["\A3\data_f\ParticleEffects\Universal\Refract", 1, 0],
        "", "Billboard", 1, _lifeTime,
        [0,0,0], [0,0,0],
        0, 12, 9.5, 0.12,
        _sizeArray,
        [
            [0.15,0.15,0.15,1],[0.3,0.3,0.3,1],
            [0.6,0.6,0.6,1],[0,0,0,1],
            [0,0,0,0.6],[0,0,0,0.4]
        ],
        [1], 0.25, 0.25,
        "", "", _particleSource, 1, false, -1, [], [0,1,0]
    ];
    
    // Fragmentos de piedra extremadamente mejorados
    for "_i" from 0 to floor(5 * PARTICLE_COUNT_MULT) do {
        drop [
            ["\A3\data_f\ParticleEffects\Pstone\Data\pstone_nohq.paa", 1, 0, 1], 
            "", "Billboard", 
            72, 54, 
            [0,0,0], 
            [random 8 - 4, random 8 - 4, random [4, 8, 12]], 
            random [2, 4, 6], 
            2.4, 2.4, 0.24, 
            [0.48, 0.42, 0.24] * PARTICLE_SIZE_MULT, 
            [[0.7,0.7,0.7,1],[0.4,0.4,0.4,0.6],[0,0,0,0]], 
            [0.8], 
            0.36, 0.36, 
            "", "", _particleSource
        ];
    };
    
    // Chispas extremadamente mejoradas
    for "_i" from 0 to floor(8 * PARTICLE_COUNT_MULT) do {
        drop [
            ["#(argb,8,8,3)color(1,0.2,0.2,1)", 1, 0, 1], 
            "", "Billboard", 
            12, 9.6, 
            [0,0,0], 
            [random [-4, 0, 4], random [-4, 0, 4], random [2, 4, 6]], 
            random [1, 2, 3], 
            2.4, 1.2, 0.24, 
            [0.24, 0.12] * PARTICLE_SIZE_MULT, 
            [[1,0.2,0.2,1],[1,0.1,0.1,0.6],[0,0,0,0]], 
            [1.2], 
            0.24, 0.24, 
            "", "", _particleSource
        ];
    };
    
    // Carb√≥n incandescente extremadamente mejorado
    for "_i" from 0 to floor(6 * PARTICLE_COUNT_MULT) do {
        drop [
            ["#(argb,8,8,3)color(1,0.4,0,1)", 1, 0, 1], 
            "", "Billboard", 
            36, 30, 
            [0,0,0], 
            [random [-1, 0, 1], random [-1, 0, 1], random [0.5, 1, 1.5]], 
            random [0.5, 1, 1.5], 
            0.6, 0.6, 0.12, 
            [0.6, 0.48, 0.36] * PARTICLE_SIZE_MULT, 
            [[1,0.4,0,1],[0.5,0.2,0,0.7],[0,0,0,0]], 
            [1.2], 
            0.36, 0.36, 
            "", "", _particleSource
        ];
    };
    
    // Glow superficial extremadamente mejorado
    drop [
        ["#(argb,8,8,3)color(1,1,1,0.85)", 1, 0, 1], 
        "", "Billboard", 
        6, 3.6, 
        [0,0,0], 
        [0,0,0.12], 
        0.24, 0.36, 0.24, 0.06, 
        [0.72, 0.48, 0.24] * PARTICLE_SIZE_MULT, 
        [[1,1,1,0.85],[1,1,1,0.4],[1,1,1,0]], 
        [1.2], 
        0.24, 0.24, 
        "", "", _particleSource
    ];
    
    // Fragmentos de carne extremadamente mejorados
    for "_i" from 0 to floor(4 * PARTICLE_COUNT_MULT) do {
        drop [
            ["#(argb,8,8,3)color(0.5,0.1,0.1,1)", 1, 0, 1], 
            "", "Billboard", 
            24, 18, 
            [0,0,0], 
            [random [-0.5, 0, 0.5], random [-0.5, 0, 0.5], random [0.5, 1, 1.5]], 
            random [0.25, 0.5, 0.75], 
            0.36, 0.48, 0.06, 
            [0.36, 0.24, 0.12] * PARTICLE_SIZE_MULT, 
            [[0.5,0.1,0.1,1],[0.2,0.05,0.05,0.6],[0,0,0,0]], 
            [1.0], 
            0.24, 0.18, 
            "", "", _particleSource
        ];
    };
    
    // Fragmentos de vidrio extremadamente mejorados
    for "_i" from 0 to floor(5 * PARTICLE_COUNT_MULT) do {
        drop [
            ["#(argb,8,8,3)color(0.5,0.5,1,0.85)", 1, 0, 1], 
            "", "Billboard", 
            30, 24, 
            [0,0,0], 
            [random [-1, 0, 1], random [-1, 0, 1], random [1, 1.5, 2]], 
            random [0.5, 1, 1.5], 
            0.6, 0.48, 0.12, 
            [0.36, 0.24] * PARTICLE_SIZE_MULT, 
            [[0.5,0.5,1,0.85],[0.2,0.2,0.5,0.5],[0,0,0,0]], 
            [1.2], 
            0.12, 0.12, 
            "", "", _particleSource
        ];
    };
    
    // Luz explosiva extremadamente mejorada
    drop [
        ["#(argb,8,8,3)color(1,0.5,0,1)", 1, 0, 1], 
        "", "Billboard", 
        3.6, 6, 
        [0,0,0], 
        [0,0,0], 
        0, 0.95, 0.72, 0.24, 
        [0.48, 0.12] * PARTICLE_SIZE_MULT, 
        [[1,0.5,0,1],[1,0.2,0,0.7],[0,0,0,0]], 
        [1.2], 
        0.36, 0.36, 
        "", "", _particleSource
    ];
    
    // Fragmentos de madera extremadamente mejorados
    for "_i" from 0 to floor(5 * PARTICLE_COUNT_MULT) do {
        drop [
            ["#(argb,8,8,3)color(0.4,0.3,0.2,1)", 1, 0, 1], 
            "", "Billboard", 
            48, 36, 
            [0,0,0], 
            [random [-0.25, 0, 0.25], random [-0.25, 0, 0.25], random [0.25, 0.5, 0.75]], 
            random [0.5, 0.75, 1], 
            0.6, 0.48, 0.12, 
            [0.48, 0.36, 0.24] * PARTICLE_SIZE_MULT, 
            [[0.4,0.3,0.2,1],[0.2,0.15,0.1,0.7],[0,0,0,0]], 
            [1.0], 
            0.24, 0.24, 
            "", "", _particleSource
        ];
    };
    
    // Fuego radiante extremadamente persistente
    drop [
        ["#(argb,8,8,3)color(1,0.3,0,1)", 1, 0, 1], 
        "", "Billboard", 
        18, 14.5, 
        [0,0,0], 
        [random [-0.1, 0, 0.1], random [-0.1, 0, 0.1], random [0.05, 0.1, 0.15]], 
        random [0.25, 0.5, 0.75], 
        0.36, 0.3, 0.06, 
        [0.48, 0.36, 0.24] * PARTICLE_SIZE_MULT, 
        [[1,0.3,0,1],[1,0.2,0,0.7],[0,0,0,0]], 
        [1.2], 
        0.36, 0.36, 
        "", "", _particleSource
    ];
    
    // Humo negro ascendente extremadamente persistente
    for "_i" from 0 to floor(3 * PARTICLE_COUNT_MULT) do {
        drop [
            ["\A3\data_f\ParticleEffects\Universal\Universal", 16, 12, 8, 0], 
            "", "Billboard", 
            30, 24, 
            [0,0,0], 
            [random [-0.1, 0, 0.1], random [-0.1, 0, 0.1], random [0.5, 0.75, 1]], 
            random [0.15, 0.3, 0.45], 
            0.24, 0.24, 0.06, 
            [0.72, 0.96, 1.44] * PARTICLE_SIZE_MULT, 
            [[0.1,0.1,0.1,0.5],[0.1,0.1,0.1,0.4],[0.1,0.1,0.1,0.3],[0.1,0.1,0.1,0.2],[0.1,0.1,0.1,0.1],[0.1,0.1,0.1,0]], 
            [0.1], 
            0.12, 0.12, 
            "", "", _particleSource
        ];
    };
    
    // Sonido explosivo extremadamente impactante
    playSound3D ["A3\\Sounds_F\\weapons\\Explosion\\expl_big_2.wss", objNull, false, _particlePos, 4, 0.9, 150];
    
    // Eco ambiental mejorado
    [_particlePos] spawn {
        params ["_pos"];
        sleep 0.5;
        playSound3D ["A3\\Sounds_F\\weapons\\Explosion\\expl_big_distance_01.wss", objNull, false, _pos, 2.5, 0.9, 300];
    };
    
    // Efectos de luz
    private _light1 = "#lightpoint" createVehicleLocal _particlePos;
    _light1 setLightBrightness 2.5;
    _light1 setLightAmbient [0.8, 0.6, 0.2];
    _light1 setLightColor [1.0, 0.8, 0.3];
    _light1 setLightFlareSize 200;
    _light1 setLightFlareMaxDistance 5000;
    _light1 setLightUseFlare true;
    
    // Eliminaci√≥n retardada de luz
    [_light1] spawn {
        params ["_light"];
        sleep 0.3;
        _light setLightBrightness 1.0;
        sleep 0.2;
        _light setLightBrightness 0.3;
        sleep 0.1;
        deleteVehicle _light;
    };
    
    deleteVehicle _particleSource;
    true
};

// ======================================================
// EFECTOS DE SANGRE Y HERIDAS
// ======================================================

bloodSplatterEffect = {
    params [["_pos", [0,0,0], [[]]], ["_dir", 0, [0]], ["_intensity", 1, [0]]];
    
    // Ajuste de intensidad mejorado
    _intensity = _intensity * PARTICLE_SIZE_MULT;
    
    // Crear objeto emisor
    private _particleSource = createSimpleObject ["Land_HelipadEmpty_F", AGLtoASL _pos, true];
    
    // Spray principal de sangre
    for "_i" from 0 to (round(6 * _intensity * PARTICLE_COUNT_MULT)) do {
        private _particleDir = _dir + (random 40 - 20);
        private _particleSpeed = 3 + random 2;
        
        drop [
            ["\A3\data_f\ParticleEffects\Universal\Universal", 16, 13, 1, 0],
            "", "Billboard", 1, 2.0,
            [0, 0, 0],
            [sin _particleDir * _particleSpeed, cos _particleDir * _particleSpeed, 0.5 + random 1.2],
            1, 0.4, 0.32, 0.06,
            [0.24, 0.36, 0.18] * _intensity,
            [[0.7, 0, 0, 0.8], [0.4, 0, 0, 0.5], [0.2, 0, 0, 0]],
            [0.6], 0.36, 0.24,
            "", "", _particleSource
        ];
    };
    
    // Gotas secundarias
    for "_i" from 0 to (round(9 * _intensity * PARTICLE_COUNT_MULT)) do {
        private _particleDir = _dir + (random 90 - 45);
        private _particleSpeed = 0.5 + random 2.5;
        
        drop [
            ["\A3\data_f\ParticleEffects\Universal\Universal", 16, 13, 1, 0],
            "", "Billboard", 1, 1.5 + random 1,
            [0, 0, 0],
            [sin _particleDir * _particleSpeed, cos _particleDir * _particleSpeed, -0.8 - random 1.4],
            1, 0.35, 0.25, 0.06,
            [0.06, 0.12, 0.03] * _intensity,
            [[0.7, 0, 0, 0.8], [0.4, 0, 0, 0.6], [0.2, 0, 0, 0]],
            [0.6], 0.36, 0.24,
            "", "", _particleSource
        ];
    };
    
    // Charco de sangre
    if (_intensity > 0.6) then {
        drop [
            ["\A3\data_f\ParticleEffects\Universal\Universal", 16, 13, 1, 0],
            "", "Billboard", 1, 9.0,
            [0, 0, 0],
            [0, 0, 0],
            0, 0.25, 0.2, 0,
            [0.36, 0.72, 0.6] * _intensity,
            [[0.6, 0, 0, 0.7], [0.4, 0, 0, 0.5], [0.2, 0, 0, 0]],
            [0.6], 0, 0,
            "", "", _particleSource
        ];
    };
    
    deleteVehicle _particleSource;
};

bloodMistEffect = {
    params [["_pos", [0,0,0], [[]]], ["_intensity", 1, [0]]];
    
    // Ajustar intensidad
    _intensity = _intensity * PARTICLE_SIZE_MULT;
    
    // Crear objeto emisor
    private _particleSource = createSimpleObject ["Land_HelipadEmpty_F", AGLtoASL _pos, true];
    
    // Niebla sangrienta difusa
    for "_i" from 0 to (round(4 * _intensity * PARTICLE_COUNT_MULT)) do {
        drop [
            ["\A3\data_f\ParticleEffects\Universal\Universal", 16, 12, 9, 0],
            "", "Billboard", 1, 3.0,
            [0, 0, 0],
            [random 1 - 0.5, random 1 - 0.5, 0.3 + random 0.8],
            0, 0.2, 0.15, 0.06,
            [0.6, 1.2, 0.6] * _intensity,
            [[0.5, 0, 0, 0.3], [0.3, 0, 0, 0.15], [0.2, 0, 0, 0]],
            [0.6], 0.1, 0.1,
            "", "", _particleSource
        ];
    };
    
    // Gotas de sangre definidas
    for "_i" from 0 to (round(6 * _intensity * PARTICLE_COUNT_MULT)) do {
        drop [
            ["\A3\data_f\ParticleEffects\Universal\Universal", 16, 13, 1, 0],
            "", "Billboard", 1, 1.5 + random 1,
            [0, 0, 0],
            [random 2 - 1, random 2 - 1, random 1 - 0.2],
            1, 0.35, 0.25, 0.06,
            [0.06, 0.12, 0.03] * _intensity,
            [[0.7, 0, 0, 0.8], [0.4, 0, 0, 0.6], [0.2, 0, 0, 0]],
            [0.6], 0.36, 0.24,
            "", "", _particleSource
        ];
    };
    
    deleteVehicle _particleSource;
};

// ======================================================
// EFECTOS DE DISPAROS Y ARMAS
// ======================================================

muzzleFlashEffect = {
    params [["_pos", [0,0,0], [[]]], ["_dir", 0, [0]], ["_size", 1.0, [0]]];
    
    // Ajustar tama√±o
    _size = _size * PARTICLE_SIZE_MULT;
    
    // Crear objeto emisor
    private _particleSource = createSimpleObject ["Land_HelipadEmpty_F", AGLtoASL _pos, true];
    
    // Destello principal
    drop [
        ["#(argb,8,8,3)color(1,0.85,0.4,1)", 1, 0, 1], 
        "", "Billboard", 1, 0.08,
        [0, 0, 0],
        [0, 0, 0],
        0, 1.3, 1.1, 0,
        [0.25, 0.15] * _size,
        [[1, 0.85, 0.4, 1], [1, 0.7, 0.3, 0]],
        [1], 0, 0,
        "", "", _particleSource, _dir
    ];
    
    // Halo secundario
    drop [
        ["#(argb,8,8,3)color(1,0.65,0.2,0.8)", 1, 0, 1], 
        "", "Billboard", 1, 0.1,
        [0, 0, 0],
        [0, 0, 0],
        0, 1.2, 1.0, 0,
        [0.35, 0.15] * _size,
        [[1, 0.7, 0.3, 0.85], [0.8, 0.5, 0.2, 0]],
        [1], 0, 0,
        "", "", _particleSource, _dir
    ];
    
    // Humo (m√°s visible)
    drop [
        ["\A3\data_f\ParticleEffects\Universal\Universal", 16, 7, 48, 0],
        "", "Billboard", 1, 1.8,
        [0, 0, 0],
        [sin _dir * 2.2, cos _dir * 2.2, 0.6],
        0, 0.08, 0.07, 0.025,
        [0.15, 0.3, 0.45] * _size,
        [[0.7, 0.7, 0.7, 0.2], [0.8, 0.8, 0.8, 0.1], [0.9, 0.9, 0.9, 0]],
        [0.6], 0.25, 0.25,
        "", "", _particleSource
    ];
    
    // Chispas (opcional para armas grandes)
    if (_size > 0.9) then {
        for "_i" from 0 to floor(3 * PARTICLE_COUNT_MULT) do {
            private _sparkDir = _dir + (random 35 - 17.5);
            private _sparkVel = 2.5 + random 2;
            drop [
                ["\A3\data_f\ParticleEffects\Universal\Universal", 16, 2, 32, 0],
                "", "Billboard", 1, 0.6 + random 0.6,
                [0, 0, 0],
                [sin _sparkDir * _sparkVel, cos _sparkDir * _sparkVel, random 1.2 - 0.6],
                1, 0.13, 0.11, 0,
                [0.06, 0.03] * _size,
                [[1, 0.85, 0.4, 1], [1, 0.7, 0.3, 0.5], [1, 0.5, 0.2, 0]],
                [0.6], 0, 0,
                "", "", _particleSource
            ];
        };
    };
    
    deleteVehicle _particleSource;
};

bulletImpactEffect = {
    params [["_pos", [0,0,0], [[]]], ["_norm", [0,0,1], [[]]], ["_material", "concrete", [""]]];
    
    // Crear objeto emisor
    private _particleSource = createSimpleObject ["Land_HelipadEmpty_F", AGLtoASL _pos, true];
    
    // Determinar color seg√∫n material
    private _colors = switch (_material) do {
        case "concrete";
        case "stone";
        case "rock": {[[0.8, 0.8, 0.8, 1], [0.7, 0.7, 0.7, 0.5], [0.5, 0.5, 0.5, 0]]};
        
        case "wood";
        case "wooden";
        case "plank": {[[0.7, 0.5, 0.3, 0.8], [0.6, 0.4, 0.2, 0.5], [0.5, 0.3, 0.15, 0]]};
        
        case "metal";
        case "steel";
        case "iron": {[[0.9, 0.9, 1, 1], [0.8, 0.8, 0.9, 0.5], [0.6, 0.6, 0.7, 0]]};
        
        case "dirt";
        case "soil";
        case "ground": {[[0.6, 0.5, 0.4, 0.8], [0.5, 0.4, 0.3, 0.5], [0.4, 0.3, 0.2, 0]]};
        
        case "sand": {[[0.8, 0.7, 0.5, 0.8], [0.7, 0.6, 0.4, 0.5], [0.6, 0.5, 0.3, 0]]};
        
        case "grass": {[[0.5, 0.6, 0.3, 0.8], [0.4, 0.5, 0.3, 0.5], [0.3, 0.4, 0.2, 0]]};
        
        default {[[0.7, 0.7, 0.7, 0.8], [0.6, 0.6, 0.6, 0.5], [0.5, 0.5, 0.5, 0]]};
    };
    
    // Calcular matriz de rotaci√≥n (necesaria para orientar part√≠culas)
    private _zaxis = _norm;
    private _xaxis = [0, 0, 1] vectorCrossProduct _zaxis;
    if (_xaxis isEqualTo [0, 0, 0]) then {_xaxis = [1, 0, 0]};
    private _yaxis = _zaxis vectorCrossProduct _xaxis;
    private _matrix = [_xaxis, _yaxis, _zaxis];
    
    // Funci√≥n auxiliar para multiplicar vector por matriz
    private _fnc_matrixMult = {
        params ["_vector", "_matrix"];
        private _result = [0,0,0];
        for "_i" from 0 to 2 do {
            _result set [_i, ((_vector select 0) * ((_matrix select 0) select _i)) + 
                             ((_vector select 1) * ((_matrix select 1) select _i)) + 
                             ((_vector select 2) * ((_matrix select 2) select _i))];
        };
        _result
    };
    
    // Chispas / fragmentos
    for "_i" from 0 to (4 + floor(random 5)) do {
        private _velVec = [random 2 - 1, random 2 - 1, random 1];
        private _vel = [_velVec, _matrix] call _fnc_matrixMult;
        _vel = _vel vectorMultiply (2.5 + random 1);
        
        drop [
            ["\A3\data_f\ParticleEffects\Universal\Universal", 16, 2, 80, 0],
            "", "Billboard", 1, 0.3 + random 0.3,
            [0, 0, 0],
            _vel,
            random 1.2, 0.09, 0.08, 0,
            [0.09, 0.04, 0.02] * PARTICLE_SIZE_MULT,
            [[1, 0.85, 0.4, 1], [1, 0.65, 0.2, 0.6], [1, 0.5, 0.1, 0]],
            [0.6], 0.25, 0.25,
            "", "", _particleSource, random 360
        ];
    };
    
    // Polvo de impacto
    drop [
        ["\A3\data_f\ParticleEffects\Universal\Universal", 16, 12, 13, 0],
        "", "Billboard", 1, 0.6 + random 0.6,
        [0, 0, 0],
        (_norm vectorMultiply (0.6 + random 0.6)),
        0, 0.08, 0.06, 0.03,
        [0.12, 0.6, 0.96],
        _colors,
        [0.6], 0.18, 0.18,
        "", "", _particleSource
    ];
    
    // Fragmentos del material
    for "_i" from 0 to (2 + floor(random 3)) do {
        private _velVec = [random 1 - 0.5, random 1 - 0.5, random 0.6];
        private _vel = [_velVec, _matrix] call _fnc_matrixMult;
        _vel = _vel vectorMultiply (1.8 + random 0.6);
        
        drop [
            ["\A3\data_f\ParticleEffects\Universal\Universal", 16, 12, 13, 0],
            "", "Billboard", 1, 1.0 + random 1.0,
            [0, 0, 0],
            _vel,
            1, 0.09, 0.08, 0.03,
            [0.04, 0.06, 0.03] * PARTICLE_SIZE_MULT,
            _colors,
            [0.6], 0.18, 0.18,
            "", "", _particleSource
        ];
    };
    
    // Cr√°ter/marca del impacto (m√°s visible)
    if (_material != "metal" && _material != "steel") then {
        drop [
            ["\A3\data_f\ParticleEffects\Universal\Universal", 16, 12, 13, 0],
            "", "Billboard", 1, 12.0,
            [0, 0, 0],
            [0, 0, 0],
            0, 0.06, 0.05, 0,
            [0.1, 0.1],
            [_colors#0, _colors#1, [0,0,0,0]],
            [0.1], 0, 0,
            "", "", _particleSource, 0, true
        ];
    };
    
    // Sonidos seg√∫n material
    private _sound = switch (_material) do {
        case "concrete";
        case "stone";
        case "rock": {"A3\Sounds_F\weapons\hits\concrete_1.wss"};
        
        case "wood";
        case "wooden";
        case "plank": {"A3\Sounds_F\weapons\hits\wood_1.wss"};
        
        case "metal";
        case "steel";
        case "iron": {"A3\Sounds_F\weapons\hits\metal_1.wss"};
        
        case "dirt";
        case "soil";
        case "ground";
        case "sand": {"A3\Sounds_F\weapons\hits\sand_1.wss"};
        
        case "grass": {"A3\Sounds_F\weapons\hits\grass_1.wss"};
        
        default {"A3\Sounds_F\weapons\hits\concrete_1.wss"};
    };
    
    // Reproducir sonido
    playSound3D [_sound, objNull, false, _pos, 0.7, 1, 30];
    
    deleteVehicle _particleSource;
};

// ======================================================
// EFECTOS DE AGUA
// ======================================================

waterSplashEffect = {
    params [["_pos", [0,0,0], [[]]], ["_size", "medium", [""]]];
    
    // Determinar escala seg√∫n tama√±o
    private _scale = switch (_size) do {
        case "tiny":   {0.36};
        case "small":  {0.72};
        case "medium": {1.2};
        case "large":  {2.16};
        case "huge":   {3.6};
        default        {1.2};
    };
    
    // Crear objeto emisor
    private _particleSource = createSimpleObject ["Land_HelipadEmpty_F", AGLtoASL _pos, true];
    
    // Columna central de agua
    drop [
        ["\A3\data_f\ParticleEffects\Universal\Universal", 16, 12, 13, 0],
        "", "Billboard", 1, 1.8 * _scale,
        [0, 0, 0], [0, 0, 4.8 * _scale],
        0, 0.6, 0.5, 0,
        [1.2 * _scale, 2.4 * _scale, 3.6 * _scale],
        [[0.7, 0.8, 1, 0.6], [0.7, 0.8, 1, 0.6], [0.7, 0.8, 1, 0]],
        [0.12], 0, 0, "", "", _particleSource
    ];
    
    // Gotas de agua principales
    for "_i" from 0 to (6 * _scale) do {
        private _dir = random 360;
        private _speed = 3.6 + random 2.4;
        private _height = 1.8 + random 2.4;
        
        drop [
            ["\A3\data_f\ParticleEffects\Universal\Universal", 16, 12, 13, 0],
            "", "Billboard", 1, 1.45 * _scale,
            [0, 0, 0],
            [sin _dir * _speed, cos _dir * _speed, _height],
            1, 0.6, 0.5, 0.06,
            [0.12 * _scale, 0.18 * _scale, 0.18 * _scale],
            [[0.7, 0.8, 1, 0.85], [0.7, 0.8, 1, 0.6], [0.7, 0.8, 1, 0]],
            [0.12], 1, 0, "", "", _particleSource
        ];
    };
    
    // Gotas de agua peque√±as (spray)
    for "_i" from 0 to (18 * _scale) do {
        private _dir = random 360;
        private _speed = 2.4 + random 3.6;
        private _height = 0.6 + random 1.2;
        
        drop [
            ["\A3\data_f\ParticleEffects\Universal\Universal", 16, 12, 13, 0],
            "", "Billboard", 1, 0.95 * _scale,
            [0, 0, 0],
            [sin _dir * _speed, cos _dir * _speed, _height],
            1, 0.6, 0.5, 0.06,
            [0.06 * _scale, 0.12 * _scale, 0.06 * _scale],
            [[0.7, 0.8, 1, 0.6], [0.7, 0.8, 1, 0.4], [0.7, 0.8, 1, 0]],
            [0.12], 1, 0, "", "", _particleSource
        ];
    };
    
    // Anillo de ondas
    drop [
        ["\A3\data_f\ParticleEffects\Universal\Universal", 16, 12, 13, 0],
        "", "Billboard", 1, 3.0 * _scale,
        [0, 0, 0], [0, 0, 0],
        0, 0.6, 0.5, 0,
        [0.6 * _scale, 4.8 * _scale, 9.6 * _scale],
        [[0.7, 0.8, 1, 0.4], [0.7, 0.8, 1, 0.25], [0.7, 0.8, 1, 0]],
        [0.12], 0, 0, "", "", _particleSource
    ];
    
    // Reproducir sonido
    private _soundFile = switch (_size) do {
        case "tiny":   {"A3\Sounds_F\weapons\pools\water_splash_small2.wss"};
        case "small":  {"A3\Sounds_F\weapons\pools\water_splash_small1.wss"};
        case "medium": {"A3\Sounds_F\weapons\pools\battle_splash1.wss"};
        case "large":  {"A3\Sounds_F\weapons\pools\battle_splash2.wss"};
        case "huge":   {"A3\Sounds_F\weapons\pools\battle_splash3.wss"};
        default        {"A3\Sounds_F\weapons\pools\battle_splash1.wss"};
    };
    
    playSound3D [_soundFile, objNull, false, _pos, 2.4, 1, 120];
    
    deleteVehicle _particleSource;
};

underwaterBubblesEffect = {
    params [["_pos", [0,0,0], [[]]], ["_intensity", 1, [0]]];
    
    if (player distance _pos > 80) exitWith {false};
    
    // Crear fuente de emisi√≥n
    private _bubbleEmitter = "#particlesource" createVehicleLocal _pos;
    
    // Configurar el emisor
    _bubbleEmitter setParticleParams [
        ["\A3\data_f\ParticleEffects\Universal\Universal", 16, 12, 13, 0],
        "", "Billboard", 1, 4.8 * _intensity,
        [0, 0, 0], [0, 0, 1.2],
        0, 0.25, 0.2, 0.06,
        [0.06, 0.12, 0.18],
        [[1, 1, 1, 0.25], [1, 1, 1, 0.15], [1, 1, 1, 0]],
        [0.12], 1, 0, "", "", ""
    ];
    
    _bubbleEmitter setParticleRandom [
        1, [0.25, 0.25, 0.25], [0.12, 0.12, 0.12], 0, 0.12, [0, 0, 0, 0], 0, 0
    ];
    
    _bubbleEmitter setDropInterval (0.04 / _intensity);
    
    // Retornar el emisor para eliminaci√≥n posterior
    _bubbleEmitter
};

// ======================================================
// EFECTOS DE FUEGO
// ======================================================

fireEffect = {
    params [["_pos", [0,0,0], [[]]], ["_size", "medium", [""]]];
    
    if (player distance _pos > 200) exitWith {false};
    
    // Determinar escala seg√∫n tama√±o
    private _scale = switch (_size) do {
        case "tiny":   {0.48};
        case "small":  {0.84};
        case "medium": {1.2};
        case "large":  {1.8};
        case "huge":   {3.0};
        default        {1.2};
    };
    
    // Crear emisores
    private _flame = "#particlesource" createVehicleLocal _pos;
    private _smoke = "#particlesource" createVehicleLocal _pos;
    private _sparks = "#particlesource" createVehicleLocal _pos;
    private _light = "#lightpoint" createVehicleLocal _pos;
    
    // Configurar llamas
    _flame setParticleParams [
        ["\A3\data_f\ParticleEffects\Universal\Universal", 16, 1, 12, 0], 
        "", "Billboard",
        1, 0.85 * _scale, 
        [0, 0, 0], 
        [0, 0, 0.6 * _scale], 
        0, 0.07, 0.05, 0.06,
        [0.72 * _scale, 1.8 * _scale, 0.6 * _scale],
        [
            [1, 1, 1, 0], 
            [1, 0.9, 0.6, 0.8], 
            [1, 0.7, 0.3, 0.8], 
            [1, 0.4, 0.2, 0.6], 
            [1, 0, 0, 0]
        ],
        [0.9, 0.4, 0.3], 1, 0, "", "", ""
    ];
    
    _flame setParticleRandom [
        0.6, 
        [0.3 * _scale, 0.3 * _scale, 0.12 * _scale], 
        [0.25, 0.25, 0.6], 
        0.6, 0.4, 
        [0, 0, 0, 0], 
        0, 0
    ];
    
    _flame setDropInterval (0.025 / _scale);
    
    // Configurar humo
    _smoke setParticleParams [
        ["\A3\data_f\ParticleEffects\Universal\Universal", 16, 7, 48, 0], 
        "", "Billboard",
        1, 6 * _scale, 
        [0, 0, 0.6 * _scale], 
        [0, 0, 1.8 * _scale], 
        0, 0.06, 0.05, 0.04,
        [0.6 * _scale, 1.8 * _scale, 3.6 * _scale],
        [
            [0.1, 0.1, 0.1, 0.25], 
            [0.2, 0.2, 0.2, 0.3], 
            [0.3, 0.3, 0.3, 0.25], 
            [0.4, 0.4, 0.4, 0.15], 
            [0.5, 0.5, 0.5, 0.01]
        ],
        [0.3, 0.6], 1, 0, "", "", ""
    ];
    
    _smoke setParticleRandom [
        1.2, 
        [0.3 * _scale, 0.3 * _scale, 0.12 * _scale], 
        [0.25, 0.25, 0.4], 
        0.6, 0.4, 
        [0, 0, 0, 0], 
        0, 0
    ];
    
    _smoke setDropInterval (0.05 / _scale);
    
    // Configurar chispas (para fuegos medianos y grandes)
    if (_scale >= 1.0) then {
        _sparks setParticleParams [
            ["\A3\data_f\ParticleEffects\Universal\Universal", 16, 2, 32, 0], 
            "", "Billboard",
            1, 1.5, 
            [0, 0, 0.3 * _scale], 
            [0, 0, 1.2], 
            1, 0.2, 0.15, 0.05,
            [0.03, 0.015, 0.005],
            [
                [1, 1, 1, 1], 
                [1, 0.85, 0.5, 1], 
                [1, 0.65, 0.1, 0]
            ],
            [0.08], 1, 0, "", "", ""
        ];
        
        _sparks setParticleRandom [
            0.2, 
            [0.15 * _scale, 0.15 * _scale, 0.1 * _scale], 
            [0.6, 0.6, 1.2], 
            0, 0.05, 
            [0, 0, 0, 0], 
            0, 0
        ];
        
        _sparks setDropInterval (0.05 / _scale);
    };
    
    // Configurar luz
    _light setLightBrightness (1.2 * _scale);
    _light setLightColor [1, 0.7, 0.35];
    _light setLightAmbient [0.15, 0.05, 0];
    _light setLightIntensity (60 * _scale);
    _light setLightAttenuation [0, 0, 0, 1.5, 6 * _scale, 12 * _scale];
    _light setLightFlareSize (0.5 * _scale);
    _light setLightFlareMaxDistance (180 * _scale);
    _light setLightUseFlare true;
    _light setLightDayLight true;
    
    // Retornar todas las fuentes para limpieza posterior
    [_flame, _smoke, _sparks, _light]
};

// ======================================================
// EFECTOS DE CLIMA Y AMBIENTE
// ======================================================

dustCloudEffect = {
    params [["_pos", [0,0,0], [[]]], ["_size", 1, [0]]];
    
    if (player distance _pos > 150) exitWith {false};
    
    // Crear emisor
    private _dustEmitter = "#particlesource" createVehicleLocal _pos;
    
    // Configurar par√°metros
    _dustEmitter setParticleParams [
        ["\A3\data_f\ParticleEffects\Universal\Universal", 16, 12, 13, 0],
        "", "Billboard", 1, 12,
        [0, 0, 0], 
        [0, 0, 0.1],
        0, 0.06, 0.05, 0.03,
        [1.2 * _size, 2.4 * _size, 3 * _size, 3.6 * _size],
        [
            [0.6, 0.5, 0.4, 0], 
            [0.6, 0.5, 0.4, 0.2], 
            [0.6, 0.5, 0.4, 0.15],
            [0.6, 0.5, 0.4, 0.1],
            [0.6, 0.5, 0.4, 0.05],
            [0.6, 0.5, 0.4, 0]
        ],
        [0.2], 0.1, 0.05,
        "", "", ""
    ];
    
    _dustEmitter setParticleRandom [
        3, [5 * _size, 5 * _size, 0.3],
        [0.25, 0.25, 0.1], 0.2, 0.1,
        [0, 0, 0, 0.1], 0.2, 0
    ];
    
    _dustEmitter setParticleCircle [
        7 * _size, [0, 0, 0]
    ];
    
    _dustEmitter setDropInterval (0.02 / (_size * 0.5));
    
    // Retornar el emisor
    _dustEmitter
};

// ======================================================
// EFECTOS DE PORTALES Y DISTORSI√ìN
// ======================================================

portalEffect = {
    params [["_pos", [0,0,0], [[]]], ["_radius", 2, [0]], ["_color", [0.3, 0.6, 1], [[]]]];
    
    if (player distance _pos > 150) exitWith {false};
    
    // Crear emisores
    private _outer = "#particlesource" createVehicleLocal _pos;
    private _inner = "#particlesource" createVehicleLocal _pos;
    private _glow = "#particlesource" createVehicleLocal _pos;
    private _light = "#lightpoint" createVehicleLocal _pos;
    
    // Emisor exterior (rotaci√≥n)
    _outer setParticleParams [
        ["\A3\data_f\ParticleEffects\Universal\Universal", 16, 12, 13, 0],
        "", "Billboard", 1, 3.6,
        [0, 0, 0], [0, 0, 0],
        2, 0.06, 0.05, 0,
        [_radius * 0.85, _radius * 1.2, _radius * 1.3, _radius * 1.1],
        [
            [_color select 0, _color select 1, _color select 2, 0],
            [_color select 0, _color select 1, _color select 2, 0.4],
            [_color select 0, _color select 1, _color select 2, 0.6],
            [_color select 0, _color select 1, _color select 2, 0]
        ],
        [0.1], 1, 0, "", "", ""
    ];
    
    _outer setParticleRandom [
        0, [0, 0, 0], [0, 0, 0], 0, 0, [0, 0, 0, 0], 0, 0
    ];
    
    _outer setParticleCircle [
        _radius, [0, 0, 0]
    ];
    
    _outer setDropInterval 0.008;
    
    // Emisor interior (v√≥rtice)
    _inner setParticleParams [
        ["\A3\data_f\ParticleEffects\Universal\Universal", 16, 12, 13, 0],
        "", "Billboard", 1, 2.4,
        [0, 0, 0], [0, 0, 0.6],
        1, 0.06, 0.05, 0.06,
        [_radius * 0.5, _radius * 0.7, _radius * 0.6, _radius * 0.4],
        [
            [_color select 0, _color select 1, _color select 2, 0],
            [_color select 0, _color select 1, _color select 2, 0.6],
            [_color select 0, _color select 1, _color select 2, 0.85],
            [_color select 0, _color select 1, _color select 2, 0]
        ],
        [0.1], 0.1, 0.06, "", "", ""
    ];
    
    _inner setParticleRandom [
        0.6, [_radius * 0.35, _radius * 0.35, _radius * 0.15], [0, 0, 0], 0, 0, [0, 0, 0, 0], 0, 0
    ];
    
    _inner setDropInterval 0.016;
    
    // Emisor de glow
    _glow setParticleParams [
        ["\A3\data_f\ParticleEffects\Universal\Universal", 16, 2, 32, 0],
        "", "Billboard", 1, 1.8,
        [0, 0, 0], [0, 0, 0],
        0, 0.12, 0.1, 0,
        [0.06 * _radius, 0.12 * _radius, 0.06 * _radius],
        [
            [1, 1, 1, 0],
            [1, 1, 1, 1],
            [1, 1, 1, 0]
        ],
        [0.1], 1, 0, "", "", ""
    ];
    
    _glow setParticleRandom [
        2.5, [_radius * 0.6, _radius * 0.6, _radius * 0.25], [0.6, 0.6, 0.6], 0, 0, [0, 0, 0, 0], 0, 0
    ];
    
    _glow setDropInterval 0.04;
    
    // Luz
    _light setLightBrightness 0.6;
    _light setLightColor _color;
    _light setLightAmbient [_color select 0 * 0.5, _color select 1 * 0.5, _color select 2 * 0.5];
    _light setLightFlareSize 6;
    _light setLightFlareMaxDistance 250;
    _light setLightUseFlare true;
    
    // Sonido ambiental
    [_pos] spawn {
        params ["_soundPos"];
        while {true} do {
            playSound3D ["a3\sounds_f\environment\ambient\theme\jazzy1.wss", objNull, false, _soundPos, 0.3, 0.7, 100];
            sleep 12.5;
        };
    };
    
    // Retornar las fuentes
    [_outer, _inner, _glow, _light]
};

// ======================================================
// EFECTOS COMBINADOS PREDEFINIDOS
// ======================================================

// Explosi√≥n completa con todas las fases
fullExplosionSequence = {
    params [["_pos", [0,0,0], [[]]], ["_size", "medium", [""]]];
    
    // 1. Crear onda de choque m√°s intensa
    [_pos, _size] call blastWaveConfigurable;
    sleep 0.05;
    
    // 2. Ejecutar una explosi√≥n completa
    [_pos, _size] call multiphasebuchedegatitoEffect;
    sleep 0.1;
    
    // 3. A√±adir efecto de calor
    [_pos] call heatHazeEffect;
    sleep 0.2;
    
    // 4. Para tama√±os grandes, a√±adir anillo de convergencia
    if (_size in ["large", "huge"]) then {
        [_pos] call bombRefractEffect;
    };
    
    // 5. Para tama√±os peque√±os, ejecutar fragmentos adicionales
    if (_size in ["tiny", "small"]) then {
        [_pos, "metal"] call createDebrisEffect;
    };
    
    true
};

// Efecto de impacto personalizado con fragmentos
createDebrisEffect = {
    params [["_pos", [0,0,0], [[]]], ["_type", "generic", [""]], ["_count", 5, [0]], ["_speed", 1, [0]]];
    
    // Crear objeto emisor
    private _particleSource = createSimpleObject ["Land_HelipadEmpty_F", AGLtoASL _pos, true];
    
    // Definir colores/texturas seg√∫n tipo
    private _info = switch (_type) do {
        case "concrete": {
            ["#(argb,8,8,3)color(0.7,0.7,0.7,1)", 
             [[0.7,0.7,0.7,1],[0.4,0.4,0.4,0.6],[0,0,0,0]], 
             [0.25,0.2,0.15]]
        };
        case "wood": {
            ["#(argb,8,8,3)color(0.4,0.3,0.2,1)", 
             [[0.4,0.3,0.2,1],[0.2,0.15,0.1,0.7],[0,0,0,0]], 
             [0.3,0.25,0.15]]
        };
        case "metal": {
            ["#(argb,8,8,3)color(0.6,0.6,0.7,1)", 
             [[0.6,0.6,0.7,1],[0.4,0.4,0.5,0.7],[0,0,0,0]], 
             [0.22,0.18,0.12]]
        };
        case "glass": {
            ["#(argb,8,8,3)color(0.5,0.5,1,0.85)", 
             [[0.5,0.5,1,0.85],[0.2,0.2,0.5,0.5],[0,0,0,0]], 
             [0.2,0.15,0.1]]
        };
        case "flesh": {
            ["#(argb,8,8,3)color(0.5,0.1,0.1,1)", 
             [[0.5,0.1,0.1,1],[0.2,0.05,0.05,0.6],[0,0,0,0]], 
             [0.15,0.1,0.05]]
        };
        default {
            ["#(argb,8,8,3)color(0.7,0.7,0.7,1)", 
             [[0.7,0.7,0.7,1],[0.4,0.4,0.4,0.6],[0,0,0,0]], 
             [0.25,0.2,0.15]]
        };
    };
    
    _info params ["_tex", "_colors", "_sizes"];
    
    // Generar fragmentos con valores mejorados
    for "_i" from 0 to _count do {
        private _dir = random 360;
        private _angle = 30 + random 60;
        private _vel = [
            sin _dir * cos _angle * _speed * (0.95 + random 0.5),
            cos _dir * cos _angle * _speed * (0.95 + random 0.5),
            sin _angle * _speed * (0.95 + random 0.5)
        ];
        
        drop [
            [_tex, 1, 0, 1], 
            "", "Billboard", 
            1, 3.0 + random 1.8, 
            [0,0,0], _vel, 
            random 1.2, 0.6, 0.5, 0.12, 
            _sizes * PARTICLE_SIZE_MULT, 
            _colors, 
            [1.2], 0.25, 0.25, 
            "", "", _particleSource, random 360
        ];
    };
    
    // Eliminaci√≥n retardada
    [_particleSource] spawn {
        params ["_source"];
        sleep 0.2;
        deleteVehicle _source;
    };
};

// === CHISPAS PARA EXPLOSIONES ===

// Funci√≥n para a√±adir chispas a explosiones
addExplosionSparks = {
    params ["_pos", ["_scale", 1.2], ["_duration", 2]];
    
    // Crear fuente de part√≠culas
    private _sparks = "#particlesource" createVehicleLocal _pos;
    _sparks setParticleParams [
        ["\A3\data_f\ParticleEffects\Universal\Universal", 16, 2, 32, 0], 
        "", "Billboard",
        1, 1.5, 
        [0, 0, 0.3 * _scale], 
        [0, 0, 1.2], 
        1, 0.2, 0.15, 0.05,
        [0.03, 0.015, 0.005],
        [
            [1, 1, 1, 1], 
            [1, 0.85, 0.5, 1], 
            [1, 0.65, 0.1, 0]
        ],
        [0.08], 1, 0, "", "", ""
    ];
    
    // Ajustes aleatorios para explosiones (m√°s expansi√≥n)
    _sparks setParticleRandom [
        0.3,                                       // Tiempo de vida aleatorio
        [0.4 * _scale, 0.4 * _scale, 0.2 * _scale], // Posici√≥n aleatoria (m√°s amplia)
        [1.2, 1.2, 2.4],                           // Velocidad aleatoria (m√°s r√°pida)
        0, 0.05,                                   // Rotaci√≥n
        [0, 0, 0, 0],                              // Color
        0, 0                                       // Otros par√°metros
    ];
    
    // Muchas chispas para explosi√≥n
    _sparks setDropInterval 0.002;
    
    // Detener emisi√≥n despu√©s de tiempo breve
    [_sparks, _duration] spawn {
        params ["_source", "_time"];
        sleep 0.15; // Emisi√≥n muy breve de chispas
        _source setDropInterval 0.01; // Reducir cantidad
        sleep 0.3;
        _source setDropInterval 0.03; // Reducir m√°s
        sleep _time - 0.45;
        deleteVehicle _source;
    };
    
    _sparks
};


// === CHISPAS PARA IMPACTOS DE BALAS ===

// Funci√≥n para a√±adir chispas a impactos de bala
addBulletImpactSparks = {
    params ["_pos", ["_hitNormal", [0,0,1]], ["_surface", ""]];
    
    // Determinar escala y cantidad basado en superficie
    private _scale = 0.4; // Escala base m√°s peque√±a para balas
    private _density = 0.01; // Densidad est√°ndar
    
    // Ajustar seg√∫n superficie
    switch (toLower _surface) do {
        case "metal";
        case "metalgrid";
        case "metalplate": {
            _scale = 0.5;
            _density = 0.005; // M√°s chispas en metal
        };
        case "concrete";
        case "stone";
        case "rock": {
            _scale = 0.4;
            _density = 0.008; // Menos en piedra
        };
        case "wood";
        case "woodenfloor";
        case "softwood": {
            _scale = 0.3;
            _density = 0.02; // Pocas en madera
        };
        default {
            _scale = 0.35;
            _density = 0.015;
        };
    };
    
    // Crear fuente de part√≠culas
    private _sparks = "#particlesource" createVehicleLocal _pos;
    _sparks setParticleParams [
        ["\A3\data_f\ParticleEffects\Universal\Universal", 16, 2, 32, 0], 
        "", "Billboard",
        1, 0.7, // Vida m√°s corta para balas
        [0, 0, 0.05 * _scale], 
        [
            (_hitNormal select 0) * 0.7, 
            (_hitNormal select 1) * 0.7, 
            (_hitNormal select 2) * 0.7
        ], 
        1, 0.2, 0.15, 0.05,
        [0.015, 0.008, 0.002], // Tama√±os m√°s peque√±os
        [
            [1, 1, 1, 1], 
            [1, 0.85, 0.5, 1], 
            [1, 0.65, 0.1, 0]
        ],
        [0.08], 1, 0, "", "", ""
    ];
    
    // Ajustes aleatorios para impactos de bala
    _sparks setParticleRandom [
        0.15, // Menos variaci√≥n en tiempo de vida
        [0.05 * _scale, 0.05 * _scale, 0.05 * _scale], // Posici√≥n inicial m√°s concentrada
        [0.5, 0.5, 0.3], // Velocidad aleatoria menor
        0, 0.05, // Rotaci√≥n
        [0, 0, 0, 0], // Color
        0, 0 // Otros par√°metros
    ];
    
    // Emisi√≥n breve de chispas
    _sparks setDropInterval _density;
    
    // Autolimpieza
    [_sparks] spawn {
        params ["_source"];
        sleep 0.1; // Emisi√≥n muy breve
        deleteVehicle _source;
    };
    
    _sparks
};

// Sistema completo para detectar impactos de bala
// Para usar, a√±ade esto al inicio del script:
if (isNil "bulletImpactHandler") then {
    bulletImpactHandler = true;
    
    player addEventHandler ["Fired", {
        params ["_unit", "_weapon", "_muzzle", "_mode", "_ammo", "_magazine", "_projectile"];
        
        // Ignorar granadas, etc.
        if (_weapon == "Throw" || _weapon == "Put") exitWith {};
        
        // Seguir el proyectil
        [_projectile] spawn {
            params ["_bullet"];
            private _lastPos = getPosATL _bullet;
            private _isAlive = true;
            
            while {_isAlive} do {
                if (isNull _bullet) exitWith {_isAlive = false};
                private _curPos = getPosATL _bullet;
                if (_curPos isEqualTo _lastPos) then {
                    // El proyectil se detuvo, debe haber impactado
                    private _surfaceType = surfaceType (getPosATL _bullet);
                    private _normal = surfaceNormal (getPosATL _bullet);
                    [_curPos, _normal, _surfaceType] call addBulletImpactSparks;
                    _isAlive = false;
                };
                _lastPos = _curPos;
                sleep 0.01;
            };
        };
    }];
    
    // Alternativa: Un enfoque m√°s eficiente usando EH de impacto (si est√° disponible)
    if (!isNil "BIS_fnc_addScriptedEventHandler") then {
        ["bulletImpact", {
            params ["_pos", "_dir", "_shooter", "_caliber", "_ammo", "_speed", "_surfaceType"];
            private _normal = surfaceNormal _pos;
            [_pos, _normal, _surfaceType] call addBulletImpactSparks;
        }] call BIS_fnc_addScriptedEventHandler;
    };
};


/*
    Efectos Ambientales para Explosiones
    Autor: BuchedegatitoSi
    Fecha: 2025-06-10
    
    - √Årboles que caen con explosiones cercanas
    - Arbustos que se incendian con explosiones
*/

// Configuraci√≥n general
#define TREE_FALL_RADIUS 15         // Radio en metros para detecci√≥n de √°rboles
#define TREE_FALL_DAMAGE_MIN 0.5    // Da√±o m√≠nimo para derribar √°rboles
#define BUSH_FIRE_RADIUS 20         // Radio para incendiar arbustos
#define BUSH_FIRE_CHANCE 0.7        // Probabilidad de que un arbusto se incendie
#define FIRE_DURATION_MIN 30        // Duraci√≥n m√≠nima del fuego (segundos)
#define FIRE_DURATION_MAX 60        // Duraci√≥n m√°xima del fuego (segundos)

// Lista de clases de √°rboles comunes en Arma 3
#define TREE_CLASSES ["Land_Woods_pine_tall", "Land_Woods_Tree_pine_01", "Land_Woods_Tree_pine_02", "Land_t_picea1s_F", "Land_t_picea2s_F", "Land_t_picea3f_F", "Land_t_pinusN1s_F", "Land_t_pinusN2s_F", "Land_t_pinusS2f_F", "Land_t_poplar2f_dead_F", "t_fraxinus2s_F", "t_quercus2f_F", "t_quercus3f_F", "t_ficusB1s_F", "t_ficusB2s_F", "t_oleae1s_F", "t_oleae2s_F", "t_phoenixC1s_F", "t_phoenixC3s_F", "t_poplar1s_F", "t_poplar2s_F", "t_poplar3s_F", "b_ficusC1s_F", "b_ficusC2d_F", "b_neriumO2d_F", "b_neriumO2s_F", "b_phoenixC3s_F"]

// Lista de clases de arbustos/vegetaci√≥n
#define BUSH_CLASSES ["Land_b_arundod2s_F", "Land_b_ficusC1s_F", "Land_b_ficusC2d_F", "Land_b_ficusC2s_F", "Land_b_neriumO2d_F", "Land_b_neriumO2s_F", "Land_b_phoenixC3s_F", "Land_c_Brush_Hard_EP1", "Land_c_Brush_Soft_EP1", "Land_c_fern", "Land_c_GrassBunch", "Land_c_GrassTall", "Land_c_leaves", "Land_c_MaxMoth", "Land_c_PlantsSmall1", "Land_c_PlantsSmall2", "Land_c_shrub", "Land_c_TreeSmall", "Land_clutter_grass_small", "Land_clutter_grass_tall"]

// Sistema de ca√≠da de √°rboles
fallTreesNearExplosion = {
    params ["_position", "_radius", "_damage"];
    
    // Buscar √°rboles cercanos
    private _nearTrees = nearestTerrainObjects [_position, ["TREE", "SMALL TREE"], _radius, false, true];
    
    // Si no hay √°rboles cercanos, terminar
    if (count _nearTrees == 0) exitWith {false};
    
    {
        private _tree = _x;
        
        // Calcular da√±o basado en distancia
        private _distance = _position distance _tree;
        private _relativeDamage = linearConversion [_radius, 0, _distance, 0, 1, true];
        
        // Si el da√±o relativo es suficiente, derribar el √°rbol
        if (_relativeDamage >= TREE_FALL_DAMAGE_MIN) then {
            // Calcular direcci√≥n de ca√≠da (alej√°ndose de la explosi√≥n)
            private _treePos = getPosATL _tree;
            private _directionFromExplosion = [_position, _treePos] call BIS_fnc_dirTo;
            
            // A√±adir un poco de aleatoriedad a la direcci√≥n
            _directionFromExplosion = _directionFromExplosion + (random 40) - 20;
            
            // Crear secuencia de ca√≠da de √°rbol
            [_tree, _treePos, _directionFromExplosion] spawn {
                params ["_treeObj", "_pos", "_dir"];
                
                // Efecto de sonido de √°rbol rompi√©ndose
                playSound3D ["A3\Sounds_F\sfx\objects\wood_crack_01.wss", _treeObj, false, _pos, 1.5, 1, 100];
                
                // Efecto de part√≠culas de madera
                private _debris = "#particlesource" createVehicleLocal _pos;
                _debris setParticleParams [
                    ["\A3\data_f\ParticleEffects\Universal\Universal", 16, 9, 1], 
                    "", "Billboard", 1, 2, 
                    [0, 0, 1], [0, 0, 1], 
                    0, 0.5, 0.3, 0.2, 
                    [0.5, 0.5], 
                    [[0.6, 0.5, 0.4, 1], [0.6, 0.5, 0.4, 0]], 
                    [1], 0, 0, "", "", _pos
                ];
                _debris setParticleRandom [0.5, [1, 1, 0.5], [0.5, 0.5, 0.5], 0, 0.5, [0, 0, 0, 0], 0, 0];
                _debris setDropInterval 0.05;
                
                // Simular movimiento de ca√≠da
                private _originalHeight = (getPosATL _treeObj) select 2;
                private _fallingTree = objNull;
                
                // Ocultar √°rbol original y crear uno ca√≠do
                _treeObj hideObjectGlobal true;
                
                // Determinar tipo de √°rbol y seleccionar modelo ca√≠do apropiado
                private _fallenTreeType = "Land_FallenTree_01_F"; // Modelo predeterminado
                
                // Intentar seleccionar un modelo m√°s espec√≠fico basado en el tipo de √°rbol
                private _treeType = typeOf _treeObj;
                
                if (_treeType in ["Land_t_picea1s_F", "Land_t_picea2s_F", "Land_t_picea3f_F"]) then {
                    _fallenTreeType = "Land_FallenPine_01_F";
                };
                
                if (_treeType in ["Land_t_pinusN1s_F", "Land_t_pinusN2s_F", "Land_t_pinusS2f_F"]) then {
                    _fallenTreeType = "Land_FallenPine_01_F";
                };
                
                if (_treeType in ["t_quercus2f_F", "t_quercus3f_F"]) then {
                    _fallenTreeType = "Land_FallenTree_01_F";
                };
                
                // Crear √°rbol ca√≠do
                _fallingTree = createVehicle [_fallenTreeType, _pos, [], 0, "CAN_COLLIDE"];
                _fallingTree setDir _dir;
                _fallingTree setPosATL _pos;
                
                // Esperar un momento antes de limpiar part√≠culas
                sleep 2;
                deleteVehicle _debris;
                
                // √Årbol permanecer√° ca√≠do en la misi√≥n
            };
            
            // Peque√±o retardo para evitar procesamiento simult√°neo
            sleep 0.1;
        };
    } forEach _nearTrees;
    
    true
};

// Sistema de fuego en arbustos
createBushFiresNearExplosion = {
    params ["_position", "_radius"];
    
    // Buscar arbustos y vegetaci√≥n cercana
    private _nearBushes = nearestTerrainObjects [_position, ["BUSH", "SMALL TREE", "HIDE"], _radius, false, true];
    
    // Filtrar para mantener solo ciertos tipos
    _nearBushes = _nearBushes select {typeOf _x in BUSH_CLASSES || {getText (configFile >> "CfgVehicles" >> typeOf _x >> "simulation") == "bush"}};
    
    // Si no hay arbustos cercanos, buscar objetos que podr√≠an ser vegetaci√≥n
    if (count _nearBushes == 0) then {
        _nearBushes = _position nearObjects ["NonStrategic", _radius];
        _nearBushes = _nearBushes select {typeOf _x in BUSH_CLASSES};
    };
    
    // Si sigue sin haber arbustos, terminar
    if (count _nearBushes == 0) exitWith {false};
    
    // N√∫mero de arbustos que se incendiar√°n (basado en densidad)
    private _numBushesToBurn = floor(random [1, 3, 5]);
    _numBushesToBurn = _numBushesToBurn min (count _nearBushes);
    
    // Seleccionar arbustos al azar para incendiar
    private _selectedBushes = [];
    for "_i" from 1 to _numBushesToBurn do {
        if (count _nearBushes > 0) then {
            private _idx = floor(random count _nearBushes);
            _selectedBushes pushBack (_nearBushes select _idx);
            _nearBushes deleteAt _idx;
        };
    };
    
    // Crear fuegos en los arbustos seleccionados
    {
        private _bush = _x;
        
        // Solo incendiar con cierta probabilidad
        if (random 1 < BUSH_FIRE_CHANCE) then {
            private _bushPos = getPosATL _bush;
            
            // Duraci√≥n aleatoria del fuego
            private _fireDuration = random [FIRE_DURATION_MIN, (FIRE_DURATION_MIN + FIRE_DURATION_MAX) / 2, FIRE_DURATION_MAX];
            
            // Crear el efecto de fuego
            [_bushPos, _fireDuration] spawn {
                params ["_pos", "_duration"];
                
                // Crear fuego
                private _fire = "FirePlace_burning_F" createVehicle _pos;
                _fire setPosATL _pos;
                
                // Ajustar tama√±o del fuego (m√°s peque√±o que el predeterminado)
                _fire setDamage 0.7;
                
                // A√±adir humo
                private _smoke = "#particlesource" createVehicleLocal _pos;
                _smoke attachTo [_fire, [0, 0, 0.5]];
                _smoke setParticleParams [
                    ["\A3\data_f\ParticleEffects\Universal\Universal", 16, 7, 48, 1],
                    "", "Billboard", 1, 15,
                    [0, 0, 0], [0, 0, 1.5], 1, 0.05, 0.04, 0.05,
                    [0.5, 2, 4],
                    [[0.5, 0.5, 0.5, 0.15], [0.75, 0.75, 0.75, 0.075], [1, 1, 1, 0]],
                    [0.125], 0.1, 0.05, "", "", _fire
                ];
                _smoke setParticleRandom [2, [0.25, 0.25, 0.5], [0.2, 0.2, 0.5], 0.5, 0.5, [0, 0, 0, 0.1], 0, 0, 0.1];
                _smoke setDropInterval 0.1;
                
                // Esperar la duraci√≥n programada
                sleep _duration;
                
                // Apagar gradualmente
                _fire setDamage 0.9;
                sleep 3;
                deleteVehicle _smoke;
                sleep 2;
                deleteVehicle _fire;
            };
            
            // Peque√±o retardo para evitar procesamiento simult√°neo
            sleep 0.05;
        };
    } forEach _selectedBushes;
    
    true
};

// Detector de explosiones
if (isNil "environmentalEffectsActive") then {
    environmentalEffectsActive = true;
    
    // Event handler para detectar explosiones
    ["Explosion", {
        params ["_explosive", "_pos", "_velocity"];
        
        // Obtener informaci√≥n del explosivo
        private _ammoType = "";
        private _magnitude = 1;
        
        if (!isNull _explosive) then {
            _ammoType = typeOf _explosive;
            
            // Determinar magnitud basada en tipo de explosivo
            switch (true) do {
                // Granadas peque√±as
                case (_ammoType in ["GrenadeHand", "mini_Grenade"]): {
                    _magnitude = 0.6;
                };
                // RPGs y misiles peque√±os
                case (_ammoType in ["R_PG32V_F", "M_NLAW_AT_F"]): {
                    _magnitude = 1.2;
                };
                // Explosivos y minas
                case (_ammoType in ["DemoCharge_Remote_Ammo", "SatchelCharge_Remote_Ammo", "ATMine_Range_Ammo"]): {
                    _magnitude = 1.5;
                };
                // Artiller√≠a y bombas a√©reas
                case (_ammoType in ["Sh_82mm_AMOS", "Sh_155mm_AMOS", "Bo_Mk82"]): {
                    _magnitude = 2.0;
                };
                // Por defecto
                default {
                    _magnitude = 1.0;
                };
            };
        };
        
        // Verificar magnitud m√≠nima para efectos
        if (_magnitude >= 0.5) then {
            // Derribar √°rboles
            [_pos, TREE_FALL_RADIUS * _magnitude, TREE_FALL_DAMAGE_MIN] spawn fallTreesNearExplosion;
            
            // Incendiar arbustos (solo para explosiones m√°s grandes)
            if (_magnitude >= 1.0) then {
                [_pos, BUSH_FIRE_RADIUS * _magnitude] spawn createBushFiresNearExplosion;
            };
        };
    }] call BIS_fnc_addScriptedEventHandler;
    
    systemChat "";
};

// === ESTELAS DE MISILES Y RPGS ===

// Sistema de estela de misil
createMissileTrail = {
    params ["_projectile"];
    
    // Validar que sea un proyectil v√°lido
    if (isNull _projectile) exitWith {};
    
    // Crear objeto auxiliar para seguir al proyectil
    private _trailHelper = "Land_HelipadEmpty_F" createVehicleLocal [0,0,0];
    _trailHelper attachTo [_projectile, [0,0,0]];
    
    // Crear estela de humo principal
    private _trailSmoke = "#particlesource" createVehicleLocal [0,0,0];
    _trailSmoke attachTo [_trailHelper, [0,-0.2,0]];
    
    _trailSmoke setParticleParams [
        ["\A3\data_f\ParticleEffects\Universal\Universal", 16, 7, 48, 1],
        "", "Billboard", 1, MISSILE_TRAIL_LIFE,
        [0, 0, 0], [0, 0, 0], 0, 0.05, 0.04, 0.025,
        [0.5 * MISSILE_TRAIL_SIZE, 1.5 * MISSILE_TRAIL_SIZE, 2.5 * MISSILE_TRAIL_SIZE],
        [
            [0.6, 0.6, 0.6, 0.2],
            [0.7, 0.7, 0.7, 0.15],
            [0.8, 0.8, 0.8, 0.1],
            [0.9, 0.9, 0.9, 0.05],
            [1, 1, 1, 0]
        ],
        [0.25, 0.5], 0.1, 0.1, "", "", _trailHelper
    ];
    
    _trailSmoke setParticleRandom [
        0.2, [0.05, 0.05, 0.05], [0.1, 0.1, 0.1], 0, 0.1, [0, 0, 0, 0], 0, 0
    ];
    
    _trailSmoke setDropInterval 0.005;
    
    // Crear humo denso cerca del motor
    private _engineSmoke = "#particlesource" createVehicleLocal [0,0,0];
    _engineSmoke attachTo [_trailHelper, [0,-0.1,0]];
    
    _engineSmoke setParticleParams [
        ["\A3\data_f\ParticleEffects\Universal\Universal", 16, 7, 48, 1],
        "", "Billboard", 1, 0.6,
        [0, 0, 0], [0, 0, 0], 0, 0.05, 0.04, 0.05,
        [0.5 * MISSILE_TRAIL_SIZE, 1.2 * MISSILE_TRAIL_SIZE],
        [
            [0.1, 0.1, 0.1, 0.8],
            [0.3, 0.3, 0.3, 0.5],
            [0.5, 0.5, 0.5, 0.2],
            [0.7, 0.7, 0.7, 0]
        ],
        [0.5], 0.1, 0.1, "", "", _trailHelper
    ];
    
    _engineSmoke setParticleRandom [
        0.1, [0.02, 0.02, 0.02], [0.05, 0.05, 0.05], 0, 0.1, [0, 0, 0, 0], 0, 0
    ];
    
    _engineSmoke setDropInterval 0.01;
    
    // Sistema de chispas intermitentes
    [_projectile, _trailHelper] spawn {
        params ["_missile", "_helper"];
        
        while {!isNull _missile && alive _missile} do {
            // Generar chispas aleatoriamente
            if (random 1 < MISSILE_SPARK_CHANCE) then {
                private _sparkPos = getPosATL _helper;
                
                // Usar el mismo tipo de chispas que definimos antes
                private _sparks = "#particlesource" createVehicleLocal _sparkPos;
                _sparks setParticleParams [
                    ["\A3\data_f\ParticleEffects\Universal\Universal", 16, 2, 32, 0], 
                    "", "Billboard",
                    1, 0.6, // Vida m√°s corta
                    [0, 0, 0], 
                    [0, 0, 0], // Sin velocidad adicional
                    1, 0.2, 0.15, 0.05,
                    [0.03, 0.015, 0.005], // Tama√±os peque√±os
                    [
                        [1, 1, 1, 1], 
                        [1, 0.85, 0.5, 1], 
                        [1, 0.65, 0.1, 0]
                    ],
                    [0.08], 1, 0, "", "", ""
                ];
                
                _sparks setParticleRandom [
                    0.05, // Tiempo de vida aleatorio
                    [0.1, 0.1, 0.1], // Posici√≥n aleatoria
                    [0.2, 0.2, 0.2], // Velocidad aleatoria
                    0, 0.05, // Rotaci√≥n
                    [0, 0, 0, 0], // Color
                    0, 0 // Otros par√°metros
                ];
                
                _sparks setDropInterval 0.01;
                
                // Eliminar despu√©s de un breve momento
                [_sparks] spawn {
                    params ["_source"];
                    sleep 0.1;
                    deleteVehicle _source;
                };
            };
            
            // Comprobar si el misil est√° en vuelo
            if ((velocity _missile) isEqualTo [0,0,0]) then {
                // El misil probablemente ha impactado
                sleep 0.2;
                if ((velocity _missile) isEqualTo [0,0,0]) exitWith {};
            };
            
            sleep 0.05;
        };
        
        // Limpiar los recursos
        {
            detach _x;
            deleteVehicle _x;
        } forEach attachedObjects _helper;
        
        deleteVehicle _helper;
    };
};

// === EFECTOS AMBIENTALES PARA EXPLOSIONES ===

// Configuraci√≥n general
#define TREE_FALL_RADIUS 15
#define TREE_FALL_DAMAGE_MIN 0.5
#define BUSH_FIRE_RADIUS 20
#define BUSH_FIRE_CHANCE 0.7
#define FIRE_DURATION_MIN 30
#define FIRE_DURATION_MAX 60

// Lista de clases de √°rboles comunes en Arma 3
#define TREE_CLASSES ["Land_Woods_pine_tall", "Land_Woods_Tree_pine_01", "Land_Woods_Tree_pine_02", "Land_t_picea1s_F", "Land_t_picea2s_F", "Land_t_picea3f_F", "Land_t_pinusN1s_F", "Land_t_pinusN2s_F", "Land_t_pinusS2f_F", "Land_t_poplar2f_dead_F", "t_fraxinus2s_F", "t_quercus2f_F", "t_quercus3f_F", "t_ficusB1s_F", "t_ficusB2s_F", "t_oleae1s_F", "t_oleae2s_F", "t_phoenixC1s_F", "t_phoenixC3s_F", "t_poplar1s_F", "t_poplar2s_F", "t_poplar3s_F", "b_ficusC1s_F", "b_ficusC2d_F", "b_neriumO2d_F", "b_neriumO2s_F", "b_phoenixC3s_F"]

// Lista de clases de arbustos/vegetaci√≥n
#define BUSH_CLASSES ["Land_b_arundod2s_F", "Land_b_ficusC1s_F", "Land_b_ficusC2d_F", "Land_b_ficusC2s_F", "Land_b_neriumO2d_F", "Land_b_neriumO2s_F", "Land_b_phoenixC3s_F", "Land_c_Brush_Hard_EP1", "Land_c_Brush_Soft_EP1", "Land_c_fern", "Land_c_GrassBunch", "Land_c_GrassTall", "Land_c_leaves", "Land_c_MaxMoth", "Land_c_PlantsSmall1", "Land_c_PlantsSmall2", "Land_c_shrub", "Land_c_TreeSmall", "Land_clutter_grass_small", "Land_clutter_grass_tall"]

// Sistema de ca√≠da de √°rboles
fallTreesNearExplosion = {
    params ["_position", "_radius", "_damage"];
    
    // Buscar √°rboles cercanos
    private _nearTrees = nearestTerrainObjects [_position, ["TREE", "SMALL TREE"], _radius, false, true];
    
    // Si no hay √°rboles cercanos, terminar
    if (count _nearTrees == 0) exitWith {false};
    
    {
        private _tree = _x;
        
        // Calcular da√±o basado en distancia
        private _distance = _position distance _tree;
        private _relativeDamage = linearConversion [_radius, 0, _distance, 0, 1, true];
        
        // Si el da√±o relativo es suficiente, derribar el √°rbol
        if (_relativeDamage >= TREE_FALL_DAMAGE_MIN) then {
            // Calcular direcci√≥n de ca√≠da (alej√°ndose de la explosi√≥n)
            private _treePos = getPosATL _tree;
            private _directionFromExplosion = [_position, _treePos] call BIS_fnc_dirTo;
            
            // A√±adir un poco de aleatoriedad a la direcci√≥n
            _directionFromExplosion = _directionFromExplosion + (random 40) - 20;
            
            // Crear secuencia de ca√≠da de √°rbol
            [_tree, _treePos, _directionFromExplosion] spawn {
                params ["_treeObj", "_pos", "_dir"];
                
                // Efecto de sonido de √°rbol rompi√©ndose
                playSound3D ["A3\Sounds_F\sfx\objects\wood_crack_01.wss", _treeObj, false, _pos, 1.5, 1, 100];
                
                // Efecto de part√≠culas de madera
                private _debris = "#particlesource" createVehicleLocal _pos;
                _debris setParticleParams [
                    ["\A3\data_f\ParticleEffects\Universal\Universal", 16, 9, 1], 
                    "", "Billboard", 1, 2, 
                    [0, 0, 1], [0, 0, 1], 
                    0, 0.5, 0.3, 0.2, 
                    [0.5, 0.5], 
                    [[0.6, 0.5, 0.4, 1], [0.6, 0.5, 0.4, 0]], 
                    [1], 0, 0, "", "", _pos
                ];
                _debris setParticleRandom [0.5, [1, 1, 0.5], [0.5, 0.5, 0.5], 0, 0.5, [0, 0, 0, 0.1], 0, 0];
                _debris setDropInterval 0.05;
                
                // Simular movimiento de ca√≠da
                private _originalHeight = (getPosATL _treeObj) select 2;
                private _fallingTree = objNull;
                
                // Ocultar √°rbol original y crear uno ca√≠do
                _treeObj hideObjectGlobal true;
                
                // Determinar tipo de √°rbol y seleccionar modelo ca√≠do apropiado
                private _fallenTreeType = "Land_FallenTree_01_F"; // Modelo predeterminado
                
                // Intentar seleccionar un modelo m√°s espec√≠fico basado en el tipo de √°rbol
                private _treeType = typeOf _treeObj;
                
                if (_treeType in ["Land_t_picea1s_F", "Land_t_picea2s_F", "Land_t_picea3f_F"]) then {
                    _fallenTreeType = "Land_FallenPine_01_F";
                };
                
                if (_treeType in ["Land_t_pinusN1s_F", "Land_t_pinusN2s_F", "Land_t_pinusS2f_F"]) then {
                    _fallenTreeType = "Land_FallenPine_01_F";
                };
                
                if (_treeType in ["t_quercus2f_F", "t_quercus3f_F"]) then {
                    _fallenTreeType = "Land_FallenTree_01_F";
                };
                
                // Crear √°rbol ca√≠do
                _fallingTree = createVehicle [_fallenTreeType, _pos, [], 0, "CAN_COLLIDE"];
                _fallingTree setDir _dir;
                _fallingTree setPosATL _pos;
                
                // Esperar un momento antes de limpiar part√≠culas
                sleep 2;
                deleteVehicle _debris;
                
                // √Årbol permanecer√° ca√≠do en la misi√≥n
            };
            
            // Peque√±o retardo para evitar procesamiento simult√°neo
            sleep 0.1;
        };
    } forEach _nearTrees;
    
    true
};

// Sistema de fuego en arbustos
createBushFiresNearExplosion = {
    params ["_position", "_radius"];
    
    // Buscar arbustos y vegetaci√≥n cercana
    private _nearBushes = nearestTerrainObjects [_position, ["BUSH", "SMALL TREE", "HIDE"], _radius, false, true];
    
    // Filtrar para mantener solo ciertos tipos
    _nearBushes = _nearBushes select {typeOf _x in BUSH_CLASSES || {getText (configFile >> "CfgVehicles" >> typeOf _x >> "simulation") == "bush"}};
    
    // Si no hay arbustos cercanos, buscar objetos que podr√≠an ser vegetaci√≥n
    if (count _nearBushes == 0) then {
        _nearBushes = _position nearObjects ["NonStrategic", _radius];
        _nearBushes = _nearBushes select {typeOf _x in BUSH_CLASSES};
    };
    
    // Si sigue sin haber arbustos, terminar
    if (count _nearBushes == 0) exitWith {false};
    
    // N√∫mero de arbustos que se incendiar√°n (basado en densidad)
    private _numBushesToBurn = floor(random [1, 3, 5]);
    _numBushesToBurn = _numBushesToBurn min (count _nearBushes);
    
    // Seleccionar arbustos al azar para incendiar
    private _selectedBushes = [];
    for "_i" from 1 to _numBushesToBurn do {
        if (count _nearBushes > 0) then {
            private _idx = floor(random count _nearBushes);
            _selectedBushes pushBack (_nearBushes select _idx);
            _nearBushes deleteAt _idx;
        };
    };
    
    // Crear fuegos en los arbustos seleccionados
    {
        private _bush = _x;
        
        // Solo incendiar con cierta probabilidad
        if (random 1 < BUSH_FIRE_CHANCE) then {
            private _bushPos = getPosATL _bush;
            
            // Duraci√≥n aleatoria del fuego
            private _fireDuration = random [FIRE_DURATION_MIN, (FIRE_DURATION_MIN + FIRE_DURATION_MAX) / 2, FIRE_DURATION_MAX];
            
            // Crear el efecto de fuego
            [_bushPos, _fireDuration] spawn {
                params ["_pos", "_duration"];
                
                // Crear fuego
                private _fire = "FirePlace_burning_F" createVehicle _pos;
                _fire setPosATL _pos;
                
                // Ajustar tama√±o del fuego (m√°s peque√±o que el predeterminado)
                _fire setDamage 0.7;
                
                // A√±adir humo
                private _smoke = "#particlesource" createVehicleLocal _pos;
                _smoke attachTo [_fire, [0, 0, 0.5]];
                _smoke setParticleParams [
                    ["\A3\data_f\ParticleEffects\Universal\Universal", 16, 7, 48, 1],
                    "", "Billboard", 1, 15,
                    [0, 0, 0], [0, 0, 1.5], 1, 0.05, 0.04, 0.05,
                    [0.5, 2, 4],
                    [[0.5, 0.5, 0.5, 0.15], [0.75, 0.75, 0.75, 0.075], [1, 1, 1, 0]],
                    [0.125], 0.1, 0.05, "", "", _fire
                ];
                _smoke setParticleRandom [2, [0.25, 0.25, 0.5], [0.2, 0.2, 0.5], 0.5, 0.5, [0, 0, 0, 0.1], 0, 0, 0.1];
                _smoke setDropInterval 0.1;
                
                // Esperar la duraci√≥n programada
                sleep _duration;
                
                // Apagar gradualmente
                _fire setDamage 0.9;
                sleep 3;
                deleteVehicle _smoke;
                sleep 2;
                deleteVehicle _fire;
            };
            
            // Peque√±o retardo para evitar procesamiento simult√°neo
            sleep 0.05;
        };
    } forEach _selectedBushes;
    
    true
};

// Detector de explosiones
if (isNil "environmentalEffectsActive") then {
    environmentalEffectsActive = true;
    
    // Event handler para detectar explosiones
    ["Explosion", {
        params ["_explosive", "_pos", "_velocity"];
        
        // Obtener informaci√≥n del explosivo
        private _ammoType = "";
        private _magnitude = 1;
        
        if (!isNull _explosive) then {
            _ammoType = typeOf _explosive;
            
            // Determinar magnitud basada en tipo de explosivo
            switch (true) do {
                // Granadas peque√±as
                case (_ammoType in ["GrenadeHand", "mini_Grenade"]): {
                    _magnitude = 0.6;
                };
                // RPGs y misiles peque√±os
                case (_ammoType in ["R_PG32V_F", "M_NLAW_AT_F"]): {
                    _magnitude = 1.2;
                };
                // Explosivos y minas
                case (_ammoType in ["DemoCharge_Remote_Ammo", "SatchelCharge_Remote_Ammo", "ATMine_Range_Ammo"]): {
                    _magnitude = 1.5;
                };
                // Artiller√≠a y bombas a√©reas
                case (_ammoType in ["Sh_82mm_AMOS", "Sh_155mm_AMOS", "Bo_Mk82"]): {
                    _magnitude = 2.0;
                };
                // Por defecto
                default {
                    _magnitude = 1.0;
                };
            };
        };
        
        // Verificar magnitud m√≠nima para efectos
        if (_magnitude >= 0.5) then {
            // Derribar √°rboles
            [_pos, TREE_FALL_RADIUS * _magnitude, TREE_FALL_DAMAGE_MIN] spawn fallTreesNearExplosion;
            
            // Incendiar arbustos (solo para explosiones m√°s grandes)
            if (_magnitude >= 1.0) then {
                [_pos, BUSH_FIRE_RADIUS * _magnitude] spawn createBushFiresNearExplosion;
            };
        };
    }] call BIS_fnc_addScriptedEventHandler;
    
    systemChat "";
};


// Activar el sistema de estelas de misiles
if (isNil "missileTrailSystemActive") then {
    missileTrailSystemActive = true;
    
    // Event handler para detectar disparos
    player addEventHandler ["Fired", {
        params ["_unit", "_weapon", "_muzzle", "_mode", "_ammo", "_magazine", "_projectile", "_gunner"];
        
        // Verificar si es un misil o RPG
        if (_ammo in MISSILE_TYPES || {getText (configFile >> "CfgAmmo" >> _ammo >> "simulation") == "shotMissile"}) then {
            // Aplicar estela con breve retardo para estabilidad
            [_projectile] spawn {
                params ["_missile"];
                sleep 0.05; // Breve retardo
                [_missile] call createMissileTrail;
            };
        };
    }];
    
    // Detecci√≥n para IA (en radio cercano)
    [] spawn {
        while {missileTrailSystemActive} do {
            // Buscar misiles recientes cerca
            {
                // Verificar si es un misil y si no tiene ya una estela
                if ((_x isKindOf "MissileBase" || _x isKindOf "RocketBase") && 
                    {isNil {_x getVariable "hasTrail"}} && 
                    {vectorMagnitude velocity _x > 10}) then {
                    
                    _x setVariable ["hasTrail", true];
                    [_x] call createMissileTrail;
                };
            } forEach (entities [["MissileBase", "RocketBase"], [], false, true]);
            
            sleep 0.2;
        };
    };
    
    systemChat "";
};

// === EXPLOSI√ìN VISUALMENTE IMPRESIONANTE ===

// A√±adir esta funci√≥n para crear explosiones visualmente impresionantes
createEnhancedExplosion = {
    params ["_pos", ["_size", "medium"], ["_createSmoke", true]];
    
    [_pos, 1.5] call createExplosionFlash;
    [_pos, 1.8] call addExplosionSparks;	
    [_pos, _size] call blastWaveConfigurable;
    [_pos, 30] call createIntenseSparkles;
    [_pos] call explosionBasic;
    [_pos] spawn {
        params ["_p"];
        sleep 0.05;
        [_p, "large"] call blastWaveConfigurable;
    };
    
    // 4. Efecto de luz complementario
    private _light = "#lightpoint" createVehicleLocal _pos;
    _light setLightBrightness 30;
    _light setLightAmbient [0.9, 0.9, 0.9];
    _light setLightColor [1, 0.8, 0.6];
    _light setLightDayLight true;
    _light setLightUseFlare true;
    _light setLightFlareSize 16;
    _light setLightFlareMaxDistance 1000;
    
    [_light] spawn {
        params ["_light"];
        _light setLightBrightness 10;
        sleep 0.1;
        _light setLightBrightness 5;
        sleep 0.1;
        _light setLightBrightness 3;
        sleep 0.2;
        deleteVehicle _light;
    };
    
    // 5. Humo persistente si se solicita
    if (_createSmoke) then {
        // Esperar un momento para que la explosi√≥n termine
        [_pos] spawn {
            params ["_pos"];
            sleep 1;
            [_pos, 120] call createPersistentSmoke;
        };
    };
    
    // 6. Fragmentos voladores adicionales (escombros)
    for "_i" from 1 to 15 do {
        private _vel = [random [-15,0,15], random [-15,0,15], random [3,7,12]];
        private _size = random [0.1, 0.2, 0.3] * SPARKLE_SIZE_MULT;
        
        drop [
            ["\\A3\\data_f\\ParticleEffects\\Universal\\Universal.p3d", 16, 12, 13, 0],
            "", "Billboard", 1, 4 * SPARKLE_LIFE_MULT,
            [0,0,0], _vel, 
            random 3, 0.06, 0.04, 0.05,
            [_size, _size * 0.8],
            [
                [0.5, 0.5, 0.5, 1],
                [0.5, 0.5, 0.5, 0.5], 
                [0.5, 0.5, 0.5, 0]
            ],
            [0.08], 1, 0, "", "", _pos
        ];
    };
    
    true
};

// [position player, "large", true] call createEnhancedExplosion;

// === EXPLOSI√ìN MEJORADA COMPLETA ===

// Nueva funci√≥n completa que incluye todos los efectos
createEnhancedExplosion = {
    params ["_pos", ["_size", "medium"], ["_createSmoke", true]];
    
    // 1. Destello blanco inicial
    private _light = "#lightpoint" createVehicleLocal _pos;
    _light setLightBrightness 150;
    _light setLightAmbient [1,1,1];
    _light setLightColor [1,1,1];
    _light setLightDayLight true;
    
    // Destello blanco primario (intenso pero muy breve)
    private _flash = "#particlesource" createVehicleLocal _pos;
    _flash setParticleParams [
        ["\\A3\\data_f\\ParticleEffects\\Universal\\Universal.p3d", 16, 2, 32, 0],
        "", "Billboard", 1, 0.1,
        [0,0,0], [0,0,0],
        0, 0, 0, 0,
        [10 * 1.5, 15 * 1.5], // Tama√±o grande para cubrir √°rea
        [[1,1,1,1], [1,1,1,0]], // Blanco brillante a transparente
        [1], 0, 0, "", "", _pos
    ];
    _flash setDropInterval 0.001;
    
    // 2. Chispas intensas
    [_pos, 1.8] call createIntenseSparkles;
    
    // 3. Onda expansiva y refracci√≥n
    [_pos, _size] call blastWaveConfigurable;
    
    // 4. Explosi√≥n b√°sica
    [_pos] call explosionBasic;
    
    // 5. Efectos ambientales
    [_pos, TREE_FALL_RADIUS, TREE_FALL_DAMAGE_MIN] spawn fallTreesNearExplosion;
    [_pos, BUSH_FIRE_RADIUS] spawn createBushFiresNearExplosion;
    
    // Limpiar el destello despu√©s de un breve per√≠odo
    [_light, _flash] spawn {
        params ["_light", "_flash"];
        
        // Desvanecimiento r√°pido de luz
        sleep 0.01;
        _light setLightBrightness 100;
        sleep 0.01;
        _light setLightBrightness 75;
        sleep 0.02;
        _light setLightBrightness 50;
        sleep 0.03;
        _light setLightBrightness 25;
        sleep 0.03;
        
        // Eliminar elementos
        deleteVehicle _light;
        deleteVehicle _flash;
    };
    
    true
};

// Configuraci√≥n
#define MIN_UNITS_FIGHTING 10       // N√∫mero m√≠nimo de unidades en combate
#define CHECK_INTERVAL 30           // Intervalo entre comprobaciones (segundos)
#define SOUND_RADIUS 300           // Radio para detectar unidades (metros)
#define BATTLE_SOUND_VOLUME 2.5     // Volumen de los sonidos (1.0 = normal)
#define BATTLE_MIN_DISTANCE 300     // Distancia m√≠nima para reproducir sonidos (metros)
#define BATTLE_MAX_DISTANCE 2500    // Distancia m√°xima para reproducir sonidos (metros)

// Rutas a los sonidos ambientales de batalla
#define BATTLE_AMBIENT_SOUNDS ["\A3\Sounds_F\environment\ambient\battlefield\battlefield_firefight1.wss", "\A3\Sounds_F\environment\ambient\battlefield\battlefield_firefight2.wss", "\A3\Sounds_F\environment\ambient\battlefield\battlefield_firefight3.wss", "\A3\Sounds_F\environment\ambient\battlefield\battlefield_firefight4.wss"]
#define BATTLE_DISTANT_SOUNDS ["\A3\Sounds_F\environment\ambient\battlefield\battlefield_distant1.wss", "\A3\Sounds_F\environment\ambient\battlefield\battlefield_distant2.wss", "\A3\Sounds_F\environment\ambient\battlefield\battlefield_distant3.wss"]

// Variables globales para seguimiento
battle_ambience_active = false;
battle_ambience_last_pos = [0,0,0];

// Funci√≥n para verificar si hay suficientes unidades en combate
checkForBattleConditions = {
    private _unitsFighting = 0;
    private _playerPos = position player;
    private _units = _playerPos nearEntities ["Man", SOUND_RADIUS];
    
    // Filtrar unidades no jugadores
    _units = _units select {!isPlayer _x && {side _x != civilian}};
    
    // Contar unidades en combate
    {
        if (behaviour _x == "COMBAT" || {_x getVariable ["ace_medical_isBleeding", false]}) then {
            _unitsFighting = _unitsFighting + 1;
        };
    } forEach _units;
    
    // Devolver verdadero si hay suficientes unidades luchando
    (_unitsFighting >= MIN_UNITS_FIGHTING)
};

// Funci√≥n para encontrar una posici√≥n adecuada para el sonido
findBattleSoundPosition = {
    private _playerPos = position player;
    private _dir = random 360; // Direcci√≥n aleatoria
    private _distance = random [BATTLE_MIN_DISTANCE, (BATTLE_MIN_DISTANCE + BATTLE_MAX_DISTANCE) / 2, BATTLE_MAX_DISTANCE];
    
    // Crear una posici√≥n en direcci√≥n y distancia aleatorias
    private _targetPos = _playerPos getPos [_distance, _dir];
    _targetPos set [2, 0]; // Asegurar que est√° a nivel del suelo
    
    // Tratar de encontrar una posici√≥n v√°lida en tierra
    private _finalPos = _targetPos;
    if (surfaceIsWater _targetPos) then {
        // Buscar tierra cercana
        private _landPos = _targetPos;
        for "_i" from 1 to 8 do {
            _landPos = _targetPos getPos [(_i * 100), random 360];
            if (!surfaceIsWater _landPos) exitWith {
                _finalPos = _landPos;
            };
        };
    };
    
    _finalPos
};

// Funci√≥n para reproducir sonidos de batalla
playBattleAmbience = {
    // Solo si no est√° ya reproduci√©ndose
    if (battle_ambience_active) exitWith {};
    
    battle_ambience_active = true;
    
    // Iniciar bucle de reproducci√≥n de sonidos
    [] spawn {
        while {[] call checkForBattleConditions} do {
            // Encontrar una posici√≥n para el sonido
            private _soundPos = [] call findBattleSoundPosition;
            battle_ambience_last_pos = _soundPos;
            
            // Elegir un sonido aleatorio
            private _mainSound = selectRandom BATTLE_AMBIENT_SOUNDS;
            private _distantSound = selectRandom BATTLE_DISTANT_SOUNDS;
            
            // Reproducir sonido principal (combate intenso)
            playSound3D [_mainSound, objNull, false, _soundPos, BATTLE_SOUND_VOLUME, 1, BATTLE_MAX_DISTANCE];
            
            // Esperar un poco y reproducir el sonido distante
            sleep (random [8, 12, 15]);
            
            // Si las condiciones a√∫n se cumplen, reproducir sonido distante
            if ([] call checkForBattleConditions) then {
                private _distantPos = _soundPos getPos [random [500, 800, 1200], random 360];
                playSound3D [_distantSound, objNull, false, _distantPos, BATTLE_SOUND_VOLUME * 0.7, 1, BATTLE_MAX_DISTANCE * 1.5];
            };
            
            // Esperar antes del pr√≥ximo ciclo
            sleep (random [15, 25, 35]);
        };
        
        battle_ambience_active = false;
    };
};

// Iniciar el sistema de detecci√≥n
if (isNil "battle_ambience_system_active") then {
    battle_ambience_system_active = true;
    
    // Iniciar bucle principal de verificaci√≥n
    [] spawn {
        while {battle_ambience_system_active} do {
            // Verificar condiciones de batalla
            if ([] call checkForBattleConditions) then {
                [] call playBattleAmbience;
            };
            
            // Esperar antes de la pr√≥xima comprobaci√≥n
            sleep CHECK_INTERVAL;
        };
    };
    
    systemChat "";
};

// Funci√≥n para probar manualmente
testBattleAmbience = {
    params [["_force", false]];
    
    if (_force) then {
        // Forzar reproducci√≥n de sonidos
        systemChat "";
        private _soundPos = [] call findBattleSoundPosition;
        battle_ambience_last_pos = _soundPos;
        private _mainSound = selectRandom BATTLE_AMBIENT_SOUNDS;
        private _distantSound = selectRandom BATTLE_DISTANT_SOUNDS;
        
        playSound3D [_mainSound, objNull, false, _soundPos, BATTLE_SOUND_VOLUME, 1, BATTLE_MAX_DISTANCE];
        
        [_distantSound, _soundPos] spawn {
            params ["_sound", "_pos"];
            sleep 10;
            private _distantPos = _pos getPos [random [500, 800, 1200], random 360];
            playSound3D [_sound, objNull, false, _distantPos, BATTLE_SOUND_VOLUME * 0.7, 1, BATTLE_MAX_DISTANCE * 1.5];
        };
    } else {
        // Mostrar informaci√≥n sobre el sistema
        private _unitsFighting = 0;
        private _playerPos = position player;
        private _units = _playerPos nearEntities ["Man", SOUND_RADIUS];
        
        _units = _units select {!isPlayer _x && {side _x != civilian}};
        
        {
            if (behaviour _x == "COMBAT" || {_x getVariable ["ace_medical_isBleeding", false]}) then {
                _unitsFighting = _unitsFighting + 1;
            };
        } forEach _units;
        
        systemChat format [];
        systemChat format [];
        
        if (battle_ambience_active) then {
            systemChat format [];
        };
    };
};


// ======================================================
// === EXPLOSI√ìN COMPLETA MEJORADA ===
// ======================================================

// Actualiza la funci√≥n createEnhancedExplosion
createEnhancedExplosion = {
    params ["_pos", ["_size", "medium"], ["_createSmoke", true]];
    
    [_pos, 1.5] call createExplosionFlash;
    [_pos, 1.8] call addExplosionSparks;	
    [_pos, _size] call blastWaveConfigurable;
    [_pos, 30] call createIntenseSparkles;
    [_pos] call explosionBasic;
    [_pos] spawn {
        params ["_p"];
        sleep 0.05;
        [_p, "large"] call blastWaveConfigurable;
    };
    
    // 3. Chispas intensas
    [_pos, 30] call createIntenseSparkles;
    
    // 4. Efecto de luz complementario
    private _light = "#lightpoint" createVehicleLocal _pos;
    _light setLightBrightness 10;
    _light setLightAmbient [0.8, 0.6, 0.4];
    _light setLightColor [1, 0.8, 0.6];
    _light setLightDayLight true;
    
    [_light] spawn {
        params ["_light"];
        sleep 0.1;
        _light setLightBrightness 5;
        sleep 0.1;
        _light setLightBrightness 3;
        sleep 0.2;
        deleteVehicle _light;
    };
    
    // 5. Humo con crecimiento mejorado (¬°NUEVO!)
    if (_createSmoke) then {
        // Crear humo negro directamente
        private _blackSmoke = "#particlesource" createVehicleLocal _pos;
        _blackSmoke setParticleParams [
            ["\\A3\\data_f\\ParticleEffects\\Universal\\Universal.p3d",16,7,32,0],"","Billboard",
            0.07, 6.0 * SMOKE_LIFE_MULT,
            [0,0,0], 
            [0,0,3.5] vectorMultiply SMOKE_WIND_RESISTANCE,
            0, 0.04, 0.04, 0.05,
            [
                6 * SMOKE_SIZE_MULT,
                18 * SMOKE_SIZE_MULT, 
                32 * SMOKE_SIZE_MULT, 
                48 * SMOKE_SIZE_MULT,
                64 * SMOKE_SIZE_MULT
            ], 
            [
                [0.1,0.1,0.1, 0.6],
                [0.15,0.15,0.15, 0.5],
                [0.2,0.2,0.2, 0.4],
                [0.25,0.25,0.25, 0.3],
                [0.3,0.3,0.3, 0.2],
                [0.35,0.35,0.35, 0.1],
                [0.4,0.4,0.4, 0]
            ], 
            [0.1, 0.2, 0.3, 0.2, 0.1], 0.1, 0.1, "", "", _pos
        ];
        _blackSmoke setDropInterval 0.05;
        
        // Bola de humo densa inicial
        private _blackSmokeBase = "#particlesource" createVehicleLocal _pos;
        _blackSmokeBase setParticleParams [
            ["\\A3\\data_f\\ParticleEffects\\Universal\\Universal.p3d",16,7,32,0],"","Billboard",
            0.05, 20 * SMOKE_LIFE_MULT,
            [0,0,0], 
            [0,0,2] vectorMultiply SMOKE_WIND_RESISTANCE,
            0, 0.04, 0.04, 0.05,
            [10 * SMOKE_SIZE_MULT, 20 * SMOKE_SIZE_MULT, 30 * SMOKE_SIZE_MULT],
            [[0.05,0.05,0.05, 0.7], [0.1,0.1,0.1, 0.5], [0.15,0.15,0.15, 0.3], [0.2,0.2,0.2, 0]], 
            [0.1], 0.1, 0.1, "", "", _pos
        ];
        _blackSmokeBase setDropInterval 0.08;
        
        // Limpiar el humo despu√©s
        [_blackSmoke, _blackSmokeBase] spawn {
            params ["_smoke1", "_smoke2"];
            sleep (30 * SMOKE_LIFE_MULT);
            deleteVehicle _smoke1;
            deleteVehicle _smoke2;
        };
    };
    
    // 6. Fragmentos voladores y m√°s efectos...
    // [Resto del c√≥digo se mantiene igual]
    
    true
};

// Ejemplo de uso:
// [position player, "large", true] call createEnhancedExplosion;

// ======================================================
// üîµ DURACI√ìN EXTENDIDA DE EFECTOS
// ======================================================

// Aumentar duraci√≥n de agujeros de bala
bulletHoleDuration = 300; // 5 minutos en segundos

// Interceptar la creaci√≥n de agujeros
[] spawn {
    while {true} do {
        {
            if (toLower (typeOf _x) find "bullet" > -1 || toLower (typeOf _x) find "hole" > -1) then {
                _x setVariable ["lifeTime", bulletHoleDuration];
            };
        } forEach (entities [[], [], true, true]);
        sleep 10;
    };
};


