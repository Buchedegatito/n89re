/* 
TPW SKIRMISH - Ambient infantry combat.
Authors: tpw, CB65, dakaodo 
Date: 20230122
Version: 1.65
Compatibility: SP
Requires: Community Base Addons for A3, tpw_core.sqf

Disclaimer: Feel free to use and modify this code, on the proviso that you post back changes and improvements so that everyone can benefit from them, and acknowledge the original author (tpw) in any derivative works.     

To use: 
1 - Save this script into your mission directory as eg tpw_skirmish.sqf
2 - Call it with
0 = [5,2,6,3,4,1,500,2000,1,1,1,[0,1,etc],[0,1,etc],[0,1,etc],30,["str1",etc],["str2",etc],["str3",etc],["str4,etc"],["str5",etc],["str6",etc],["cas_string",etc],["chs_string",etc],["uav_string",etc],["enemy_cas_string",etc],["enemy_chs_string",etc],["enemy_uav_string",etc],["resist_cas_string",etc],["resist_chs_string",etc],["resist_uav_string",etc],300] execvm "tpw_skirmish.sqf";

where
5 = maximum friendly squads around player,
2 = maximum friendly vehicles around player,
6 = maximum enemy squads around player,
3 = maximum enemy vehicles around the player,
4 = maximum resistance squads around player,
1 = maximum resistance vehicles around player,
500 = minimum distance to spawn squads from player,
2000 = maximum distance to spawn squads, squads will be removed past this distance,
1 = NATO friendlies can call support (0 = no support),
1 = CSAT enemy can call support (0 = no support),
1 = AAF can call support (0 = no support),
[0,1,etc] = friendly (BLUFOR) types
	(
		0 = user specified
		1 = NATO
		2 = NATO PACIFIC
		3 = CTRG PACIFIC
		4 = CSAT
		5 = CSAT PACIFIC
		6 = AAF
		7 = FIA
		8 = SYNDIKAT
		9 = LDF
		10 = SPETNAZ 
		11 = NATO WOODLAND	
		empty = NATO default
	),
[0,1,etc] = enemy (OPFOR) types
	(
		0 = user specified
		1 = NATO
		2 = NATO PACIFIC
		3 = CTRG PACIFIC
		4 = CSAT
		5 = CSAT PACIFIC
		6 = AAF
		7 = FIA
		8 = SYNDIKAT
		9 = LDF
		10 = SPETNAZ	
		11 = NATO WOODLAND	
		empty = CSAT default
	),
[0,1,etc] = resistance (INDFOR) types
	(
		0 = user specified
		1 = NATO
		2 = NATO PACIFIC
		3 = CTRG PACIFIC
		4 = CSAT
		5 = CSAT PACIFIC
		6 = AAF
		7 = FIA
		8 = SYNDIKAT
		9 = LDF
		10 = SPETNAZ	
		11 = NATO WOODLAND			
		empty = AAF default
	),
30 = time (sec) between spawning each enemy/friendly squad/vehicle,
str1 = Array containing custom strings to select friendly unit classnames,
str2 = Array containing custom strings to select friendly vehicle classnames,
str3 = Array containing custom strings to select enemy unit classnames,
str4 = Array containing custom strings to select enemy vehicle classnames,
str5 = Array containing custom strings to select resistance unit classnames,
str6 = Array containing custom strings to select resistance vehicle classnames,
cas_string = Array containing classnames of CAS aircraft,
chs_string = Array containing classnames of support heli,
uav_string = Array containing classnames of UAV,
enemy_cas_string = Array containing classnames of CAS aircraft,
enemy_chs_string = Array containing classnames of support heli,
enemy_uav_string = Array containing classnames of UAV,
resist_cas_string = Array containing classnames of CAS aircraft,
resist_chs_string = Array containing classnames of support heli,
resist_uav_string = Array containing classnames of UAV,
300 = Dead units will be removed after this amount of time (sec)

THIS SCRIPT WON'T RUN ON DEDICATED SERVERS.
*/
if (isDedicated) exitWith {};
if (count _this < 31) exitwith {player sidechat "TPW SKIRMISH incorrect/no config, exiting."};
sleep 5;

// CONFIG
tpw_skirmish_version = "1.65";
tpw_skirmish_friendlysquad_max = _this select 0; // Maximum number of friendly squads around player
tpw_skirmish_friendlyvehicles_max = _this select 1; // Maximum number of friendly vehicles around player
tpw_skirmish_enemysquad_max = _this select 2; // Maximum number of enemy squads around player
tpw_skirmish_enemyvehicles_max = _this select 3; // Maximum number of enemy vehicles around player
tpw_skirmish_resistsquad_max = _this select 4; // Maximum number of friendly squads around player
tpw_skirmish_resistvehicles_max = _this select 5; // Maximum number of friendly vehicles around player
tpw_skirmish_minspawnradius = _this select 6; // Minimum distance from player to spawn units/vehicles
tpw_skirmish_maxspawnradius = _this select 7; // Maximum distance from player to spawn units/vehicles. They'll be removed beyond this distance.
tpw_skirmish_support = _this select 8; // NATO units can call support
tpw_skirmish_enemy_support = _this select 9; // CSAT enemy units can call support
tpw_skirmish_resist_support = _this select 10; // AAF units can call support
tpw_skirmish_friendlytype = _this select 11; // 0 = user specified,1 = NATO, 2 = NATO PACIFIC, 3 = CTRG PACIFIC, 4 = CSAT,	5 = CSAT PACIFIC, 6 = AAF, 7 = FIA, 8 = SYNDIKAT, negative values will wear shemaghs. Empty = NATO default 
tpw_skirmish_enemytype = _this select 12; // 0 = user specified,1 = NATO, 2 = NATO PACIFIC, 3 = CTRG PACIFIC, 4 = CSAT,	5 = CSAT PACIFIC, 6 = AAF, 7 = FIA, 8 = SYNDIKAT, negative values will wear shemaghs. Empty = CSAT default 
tpw_skirmish_resisttype = _this select 13; // 0 = user specified,1 = NATO, 2 = NATO PACIFIC, 3 = CTRG PACIFIC, 4 = CSAT,	5 = CSAT PACIFIC, 6 = AAF, 7 = FIA, 8 = SYNDIKAT, negative values will wear shemaghs. Empty = AAF default 
tpw_skirmish_spawntime = _this select 14; // Time (sec) between spawning each enemy/friendly squad/vehicle

// Custom strings 
tpw_skirmish_friendlyunitstring = _this select 15; // Array containing custom strings to select friendly units from config
tpw_skirmish_friendlyvehiclestring = _this select 16; // Array containing custom strings to select friendly vehicles from config
tpw_skirmish_enemyunitstring = _this select 17; // Array containing custom strings to select enemy units from config
tpw_skirmish_enemyvehiclestring = _this select 18; // Array containing custom strings to select enemy vehicles from config
tpw_skirmish_resistunitstring = _this select 19; // Array containing custom strings to select resistance units from config
tpw_skirmish_resistvehiclestring = _this select 20; // Array containing custom strings to select resistance vehicles from config

tpw_skirmish_casstring = _this select 21; // Classname array of custom CAS aircraft
tpw_skirmish_chsstring = _this select 22; // Classname array of custom support heli
tpw_skirmish_uavstring = _this select 23; // Classname array of custom UAV
tpw_skirmish_enemy_casstring = _this select 24; // Classname array of custom enemy CAS aircraft
tpw_skirmish_enemy_chsstring = _this select 25; // Classname array of custom enemy support heli
tpw_skirmish_enemy_uavstring = _this select 26; // Classname array of custom enemy UAV
tpw_skirmish_resist_casstring = _this select 27; // Classname array of custom resistance CAS aircraft
tpw_skirmish_resist_chsstring = _this select 28; // Classname array of custom resistance support heli
tpw_skirmish_resist_uavstring = _this select 29; // Classname array of custom resistance UAV
tpw_skirmish_deadtime = _this select 30; // Dead units will be removed after this amount of time (sec)
// VARS
tpw_skirmish_report = ["Taking casualties at","All units be advised, we are taking heavy fire at","Man down. Repeat, man down grid","Man down. Man down at","All units, taking casualties grid","Under heavy fire, grid"];
tpw_skirmish_shemaglist = ["H_Shemag_khk","H_Shemag_olive","H_Shemag_tan","H_Shemag_olive_hs","H_Shemagopen_khk","H_Shemagopen_tan"];
tpw_skirmish_active = true;
tpw_skirmish_houses = [];
tpw_skirmish_roads = [];
tpw_skirmish_friendlywpflag = true;
tpw_skirmish_enemywpflag = true;
tpw_skirmish_resistwpflag = true;
tpw_skirmish_organic = true;

// ARRAYS OF UNITS AND VEHICLES FOR EACH OF THE PARTICIPATING FACTIONS
tpw_skirmish_friendlyunitarray = [];
tpw_skirmish_friendlyvehiclearray = [];
tpw_skirmish_enemyunitarray = [];
tpw_skirmish_enemyvehiclearray = [];
tpw_skirmish_resistunitarray = [];
tpw_skirmish_resistvehiclearray = [];
tpw_skirmish_deletearray = []; // array of vehicles to be deleted

// UNITS
tpw_skirmish_allunits =[[["B_Soldier_F","B_Soldier_lite_F","B_Soldier_GL_F","B_soldier_AR_F","B_Soldier_SL_F","B_Soldier_TL_F","B_soldier_M_F","B_soldier_LAT_F","B_soldier_repair_F","B_soldier_exp_F","B_Soldier_A_F","B_soldier_AT_F","B_soldier_AA_F","B_soldier_PG_F","B_soldier_UAV_F","B_soldier_AAR_F","B_soldier_AAT_F","B_soldier_AAA_F","B_soldier_UAV_06_F","B_soldier_UAV_06_medical_F","B_soldier_mine_F","B_soldier_LAT2_F"]],[["B_T_Soldier_A_F","B_T_Soldier_AAR_F","B_T_Soldier_AAA_F","B_T_Soldier_AAT_F","B_T_Soldier_AR_F","B_T_Soldier_Exp_F","B_T_Soldier_GL_F","B_T_soldier_M_F","B_T_Soldier_AA_F","B_T_Soldier_AT_F","B_T_Soldier_PG_F","B_T_Soldier_Repair_F","B_T_Soldier_F","B_T_Soldier_LAT_F","B_T_Soldier_SL_F","B_T_Soldier_TL_F","B_T_Soldier_UAV_F","B_T_soldier_UAV_06_F","B_T_soldier_UAV_06_medical_F","B_T_soldier_mine_F","B_T_Soldier_LAT2_F"]],[["B_CTRG_soldier_GL_LAT_F","B_CTRG_soldier_engineer_exp_F","B_CTRG_soldier_M_medic_F","B_CTRG_soldier_AR_A_F","B_CTRG_Sharphooter_F","B_CTRG_Soldier_TL_tna_F","B_CTRG_Soldier_Exp_tna_F","B_CTRG_Soldier_Medic_tna_F","B_CTRG_Soldier_M_tna_F","B_CTRG_Soldier_tna_F","B_CTRG_Soldier_LAT_tna_F","B_CTRG_Soldier_AR_tna_F","B_CTRG_Soldier_JTAC_tna_F","B_CTRG_Miller_F","B_CTRG_Soldier_LAT2_tna_F"]],[["O_Soldier_F","O_Soldier_lite_F","O_Soldier_GL_F","O_Soldier_AR_F","O_Soldier_SL_F","O_Soldier_TL_F","O_soldier_M_F","O_Soldier_LAT_F","O_soldier_repair_F","O_soldier_exp_F","O_Soldier_A_F","O_Soldier_AT_F","O_Soldier_AA_F","O_soldier_PG_F","O_soldier_UAV_F","O_Soldier_AAR_F","O_Soldier_AAT_F","O_Soldier_AAA_F","O_soldierU_F","O_soldierU_AR_F","O_soldierU_AAR_F","O_soldierU_LAT_F","O_soldierU_AT_F","O_soldierU_AAT_F","O_soldierU_AA_F","O_soldierU_AAA_F","O_soldierU_TL_F","O_SoldierU_SL_F","O_soldierU_medic_F","O_soldierU_repair_F","O_soldierU_exp_F","O_soldierU_M_F","O_soldierU_A_F","O_SoldierU_GL_F","O_soldier_UAV_06_F","O_soldier_UAV_06_medical_F","O_soldier_mine_F","O_Soldier_HAT_F","O_Soldier_AHAT_F"]],[["O_T_Soldier_A_F","O_T_Soldier_AAR_F","O_T_Soldier_AAA_F","O_T_Soldier_AAT_F","O_T_Soldier_AR_F","O_T_Soldier_Exp_F","O_T_Soldier_GL_F","O_T_Soldier_M_F","O_T_Soldier_AA_F","O_T_Soldier_AT_F","O_T_Soldier_PG_F","O_T_Soldier_Repair_F","O_T_Soldier_F","O_T_Soldier_LAT_F","O_T_Soldier_SL_F","O_T_Soldier_TL_F","O_T_Soldier_UAV_F","O_T_soldier_UAV_06_F","O_T_soldier_UAV_06_medical_F","O_T_soldier_mine_F","O_T_Soldier_HAT_F","O_T_Soldier_AHAT_F"]],[["I_soldier_F","I_Soldier_lite_F","I_Soldier_A_F","I_Soldier_GL_F","I_Soldier_AR_F","I_Soldier_SL_F","I_Soldier_TL_F","I_Soldier_M_F","I_Soldier_LAT_F","I_Soldier_AT_F","I_Soldier_AA_F","I_Soldier_repair_F","I_Soldier_exp_F","I_soldier_UAV_F","I_Soldier_AAR_F","I_Soldier_AAT_F","I_Soldier_AAA_F","I_soldier_UAV_06_F","I_soldier_UAV_06_medical_F","I_soldier_mine_F","I_Soldier_LAT2_F"]],[["B_G_Soldier_F","B_G_Soldier_lite_F","B_G_Soldier_SL_F","B_G_Soldier_TL_F","B_G_Soldier_AR_F","B_G_Soldier_exp_F","B_G_Soldier_GL_F","B_G_Soldier_M_F","B_G_Soldier_LAT_F","B_G_Soldier_A_F","B_G_Soldier_LAT2_F"]],[["I_C_Soldier_Para_1_F","I_C_Soldier_Para_2_F","I_C_Soldier_Para_3_F","I_C_Soldier_Para_4_F","I_C_Soldier_Para_5_F","I_C_Soldier_Para_6_F","I_C_Soldier_Para_7_F","I_C_Soldier_Para_8_F","I_C_Soldier_Bandit_1_F","I_C_Soldier_Bandit_2_F","I_C_Soldier_Bandit_3_F","I_C_Soldier_Bandit_4_F","I_C_Soldier_Bandit_5_F","I_C_Soldier_Bandit_6_F","I_C_Soldier_Bandit_7_F","I_C_Soldier_Bandit_8_F","I_C_Soldier_Camo_F"]],[["I_E_Soldier_F","I_E_Soldier_A_F","I_E_Soldier_AAR_F","I_E_Soldier_AR_F","I_E_Soldier_GL_F","I_E_soldier_M_F","I_E_Officer_F","I_E_Soldier_SL_F","I_E_Soldier_TL_F","I_E_RadioOperator_F","I_E_Soldier_AA_F","I_E_Soldier_AT_F","I_E_Soldier_LAT_F","I_E_Soldier_LAT2_F","I_E_Soldier_AAA_F","I_E_Soldier_AAT_F","I_E_Support_GMG_F","I_E_Support_MG_F","I_E_Support_Mort_F","I_E_Support_AMG_F","I_E_Support_AMort_F","I_E_Soldier_Pathfinder_F","I_E_Engineer_F","I_E_Soldier_Exp_F","I_E_soldier_Mine_F","I_E_Soldier_Repair_F","I_E_Medic_F","I_E_Soldier_MP_F"]],[["O_R_Soldier_TL_F","O_R_Soldier_GL_F","O_R_soldier_exp_F","O_R_Soldier_AR_F","O_R_soldier_M_F","O_R_medic_F","O_R_Soldier_LAT_F","O_R_JTAC_F","O_R_recon_TL_F","O_R_recon_exp_F","O_R_recon_AR_F","O_R_recon_M_F","O_R_recon_medic_F","O_R_recon_GL_F","O_R_recon_LAT_F","O_R_recon_JTAC_F","O_R_Patrol_Soldier_TL_F","O_R_Patrol_Soldier_AR_F","O_R_Patrol_Soldier_AR2_F","O_R_Patrol_Soldier_GL_F","O_R_Patrol_Soldier_A_F","O_R_Patrol_Soldier_M_F","O_R_Patrol_Soldier_M2_F","O_R_Patrol_Soldier_Medic","O_R_Patrol_Soldier_Engineer_F","O_R_Patrol_Soldier_LAT_F"]],[["B_W_Soldier_A_F","B_W_Soldier_AAR_F","B_W_Support_AMG_F","B_W_Support_AMort_F","B_W_Soldier_AAA_F","B_W_Soldier_AAT_F","B_W_Soldier_AR_F","B_W_Medic_F","B_W_Engineer_F","B_W_Soldier_Exp_F","B_W_soldier_mine_F","B_W_Soldier_GL_F","B_W_Support_GMG_F","B_W_Support_MG_F","B_W_Support_Mort_F","B_W_Helipilot_F","B_W_soldier_M_F","B_W_Soldier_AA_F","B_W_Soldier_AT_F","B_W_Officer_F","B_W_Soldier_Repair_F","B_W_Soldier_F","B_W_Soldier_LAT_F","B_W_Soldier_LAT2_F","B_W_Soldier_SL_F","B_W_Soldier_TL_F","B_W_RadioOperator_F","B_W_Soldier_UAV_F"]]];

tpw_skirmish_allcars = [[["B_MRAP_01_F","B_MRAP_01_gmg_F","B_MRAP_01_hmg_F"]],[["B_T_LSV_01_armed_F","B_T_LSV_01_AT_F","B_T_LSV_01_unarmed_F"]],[["B_T_LSV_01_armed_F","B_T_LSV_01_AT_F","B_T_LSV_01_unarmed_F"]],[["O_MRAP_02_F","O_MRAP_02_hmg_F","O_MRAP_02_gmg_F"]],[["O_T_LSV_02_armed_F","O_T_LSV_02_unarmed_F","O_T_LSV_02_AT_F"]],[["I_MRAP_03_F","I_MRAP_03_hmg_F","I_MRAP_03_gmg_F"]],[["B_G_Offroad_01_repair_F","B_G_Offroad_01_F","B_G_Offroad_01_armed_F","B_G_Offroad_01_AT_F"]],[["I_C_Offroad_02_unarmed_F","I_C_Offroad_02_LMG_F","I_C_Offroad_02_AT_F","I_C_Van_01_transport_F","I_C_Van_02_transport_F","I_C_Van_02_vehicle_F"]]];

tpw_skirmish_acts = ["acts_ambient_relax_1","acts_ambient_relax_2","acts_ambient_relax_3","acts_ambient_relax_4","acts_ambient_gestures_sneeze","acts_ambient_gestures_yawn","acts_ambient_gestures_tired","acts_ambient_stretching","acts_ambient_facepalm_1","acts_ambient_facepalm_2","acts_ambient_rifle_drop","acts_ambient_shoelaces","acts_ambient_picking_up","acts_listeningtoradio_in","acts_peering_left","acts_peering_right","acts_peering_back","acts_peering_front","acts_peering_up","acts_peering_down","acts_rifle_operations_back","acts_rifle_operations_barrel","acts_rifle_operations_front","acts_rifle_operations_left","acts_rifle_operations_checking_chamber","acts_rifle_operations_right","acts_rifle_operations_zeroing","Acts_AidlPercMstpSlowWrflDnon_warmup01","Acts_AidlPercMstpSlowWrflDnon_warmup02","Acts_AidlPercMstpSlowWrflDnon_warmup03","Acts_AidlPercMstpSlowWrflDnon_warmup04","Acts_AidlPercMstpSlowWrflDnon_warmup05","acts_pointing_up","acts_pointing_down","acts_pointing_left","acts_pointing_right","acts_pointing_back""acts_pointing_front","acts_shieldfromsun_loop""Acts_ru_briefing_point","Acts_ru_briefing_move","AidlPercMstpSlowWrflDnon_G01","AidlPercMstpSlowWrflDnon_G02","AidlPercMstpSlowWrflDnon_G03""AidlPercMstpSlowWrflDnon_G04","AidlPercMstpSlowWrflDnon_G05"];

// AI REVIVE
tpw_skirmish_fnc_revive = 
	{
	// Collect info
	_unit = _this select 0;
	_healer = _this select 1;
	_side = _unit getvariable "tpw_side";
	_type = typeof _unit;
	_pos = getposasl _unit;
	_dir = getdir _unit;
	_face = face _unit;
	_glasses = goggles _unit;
	_textures = getobjecttextures _unit;
	_loadout =  _unit getvariable "tpw_loadout";
	_unit setvariable ["tpw_killed",0];

	// Heal
	_healer playmove "ainvpknlmstpslaywrfldnon_medic";

	_medwaste = ["land_bloodbag_f",
	"land_intravenbag_01_empty_f",
	"land_bandage_f",
	"bloodpool_01_medium_new_f",
	"bloodpool_01_medium_new_f",
	"bloodpool_01_medium_new_f",
	"bloodpool_01_medium_new_f",
	"medicalgarbage_01_bandage_f",
	"MedicalGarbage_01_1x1_v2_F",
	"MedicalGarbage_01_1x1_v2_F",
	"MedicalGarbage_01_FirstAidKit_F",
	"MedicalGarbage_01_1x1_v2_F"];

	 for "_i" from 1 to random 3 do
		{
		_obj = selectrandom _medwaste;
		_pos = getposworld _unit;
		_dist = random 2;
		_dir = random 360;
		_vx = _dist * sin _dir;
		_vy = _dist * cos _dir;
		_pos = _pos vectoradd [_vx,_vy,0];
		_rep = createSimpleObject [_obj,_pos];
		_pos set [2,0];	
		_rep setposatl _pos;
		_rep setdir random 360;
		_rep setVectorUp surfaceNormal position _rep;
		_rep enablesimulation false;
		sleep random 2;
	   };
	sleep 5;

	// Respawn
	_sqname = _unit getvariable "tpw_squad";
	_newsquad = creategroup _side;
	_new = _newsquad createUnit [_type, _pos vectoradd [10,10,0], [], 0, "FORM"];
	if !(isnil "_sqname") then 
		{
		[_new] joinsilent _sqname
		} else
		{
		_sqname = _newsquad;
		};
	_new hideobject true;
	_new setcaptive true;
	_new setunconscious true;
	_new setface _face;
	_new addgoggles _glasses;
	_new setvariable ["tpw_side",_side];
	_new setvariable ["tpw_squad",_sqname];
	_new setdamage random 0.5;
	_new setbleedingremaining 60; 
	private _ct = 0;	
	waituntil
		{
		sleep 1;
		_ct = _ct + 1;
		(animationstate _new == "unconsciousrevivedefault" || _ct == 10)
		};
	_new setunitloadout _loadout;
	_new setvariable ["tpw_magazine",primaryweaponmagazine _new];		
	deletevehicle _unit;
	sleep 0.1;
	_ct = 0; 
		{
		_new setobjecttexture [_ct,_x]; 
		_ct = _ct + 1; 
		} foreach _textures; 
	_new setdir _dir;
	_new setposasl _pos;
	_new hideobject false;
	if!(alive _new) exitwith 
		{
		_healer sidechat "Couldn't save him"; 
		_bodybag =  createsimpleobject ["Land_Bodybag_01_black_F",_pos];
		_bodybag setVectorUp surfaceNormal position _bodybag;	
		deletevehicle _unit;
		deletevehicle _new;		
		};
	sleep 5 + random 5;
	_new setcaptive false;
	_new setunconscious false;

	// Behaviours
	_new addeventhandler ["firednear",{(_this select 0) setbehaviour "combat"}];
	[_new] spawn tpw_skirmish_fnc_relax;
	[_new] spawn tpw_skirmish_fnc_lower;
	[_new] spawn tpw_skirmish_fnc_heal;
	_new setvariable ["tpw_magazine",primaryweaponmagazine _new];	
	_new setbehaviour "safe";
	_new setbehaviourstrong "safe";
	_new setcombatbehaviour "safe";
	_new setspeedmode "limited";
	_new setcombatmode "yellow";
	_new addeventhandler ["killed",{
		_unit = _this select 0;
		_unit setvariable ["tpw_killed",1];
		_unit setvariable ["tpw_loadout", getunitloadout _unit];
		_unit addaction [format ["<t color='#aa6600'>Revive %1</t>",_unit],{_this spawn tpw_skirmish_fnc_revive}, nil, 0, false];
		//[_unit] spawn tpw_skirmish_fnc_dead;
		}];
		
	// Side specific behaviours
	switch _side do
		{
		case WEST:
			{
			_new addeventhandler ["killed",
				{
				(_this select 0) setvariable ["tpw_skirmish_removedead",diag_ticktime + tpw_skirmish_deadtime];
				private ["_squad","_leader","_call"];
				if (tpw_skirmish_friendlywpflag) then
					{
					_squad = group (_this select 0);
					if (count units _squad > 0) then
						{
						_call = tpw_skirmish_report select (floor (random (count tpw_skirmish_report)));
						_leader = leader _squad;
						_leader sidechat format ["%1 %2",_call,mapgridposition _leader];
						};
					};
				}]; // other squads will move towards this killed unit
			};
			
		case EAST:	
			{
			_new addeventhandler ["killed",
				{
				(_this select 0) setvariable ["tpw_skirmish_removedead",diag_ticktime + tpw_skirmish_deadtime];
				private ["_squad","_leader","_call"];
				if (tpw_skirmish_enemywpflag) then
					{
					_squad = group (_this select 0);
					if (count units _squad > 0) then
						{
						_call = tpw_skirmish_report select (floor (random (count tpw_skirmish_report)));
						_leader = leader _squad;
						_leader sidechat format ["%1 %2",_call,mapgridposition _leader];
						};
					};
				}];
			};
			
		case RESISTANCE:
			{
			_new addeventhandler ["killed",
				{
				(_this select 0) setvariable ["tpw_skirmish_removedead",diag_ticktime + tpw_skirmish_deadtime];
				private ["_squad","_leader","_call"];
				if (tpw_skirmish_resistwpflag) then
					{
					_squad = group (_this select 0);
					if (count units _squad > 0) then
						{
						_call = tpw_skirmish_report select (floor (random (count tpw_skirmish_report)));
						_leader = leader _squad;
						_leader sidechat format ["%1 %2",_call,mapgridposition _leader];
						};
					};
				}];
			};
		};
	};

// UNITS HEAL OTHER INCAPACITATED / DEAD
tpw_skirmish_fnc_heal =
	{
	_unit = _this select 0;
	while {true} do
		{
		if (vehicle _unit == _unit && tpw_skirmish_organic &&  !(lifestate _unit == "INCAPACITATED") && {_unit getvariable["tpw_core_enabled",1] == 1} && {_unit getvariable["tpw_core_disabled",0] == 0}) then
			{
			private _hurt = ((units group _unit) - [_unit] ) select {(_x getvariable "tpw_core_disabled" == 1)} ;
			private _dead = (alldead) select {_x getvariable ["tpw_killed",0] == 1} select {_x distance _unit < 100} select {_x getvariable "tpw_side" == side _unit};
			_hurt = _hurt + _dead;
			if (count _hurt > 0) then
				{
				_hunit = _hurt select 0;
				_unit domove getposasl _hunit;
				_ct = 0;
				waituntil 
					{
					sleep 1;
					_ct = _ct + 1;
					_unit distance _hunit < 2.5 || _ct > 30
					};
				if (alive _unit && {_unit distance _hunit < 2.5}) then
					{	
					if (_hunit getvariable ["tpw_killed",0] == 1 ) then
						{
						[_hunit,_unit] spawn tpw_skirmish_fnc_revive;
						}
						else
						{
						_unit playmove "ainvpknlmstpslaywrfldnon_medic";
						_hunit setdamage (damage _unit - random 0.5);
						};
					_unit sidechat format ["%1 %2",selectrandom ["Treating","Applying field medication to","Attempting to revive","Attempting to treat","Healing","Applying first aid to","Resuscitating"],typeof _hunit];
					};
				};
			};	
		sleep random 10;	
		};
	};

// UNITS DON'T CONSTANTLY WALK AROUND WITH WEAPONS RAISED
tpw_skirmish_fnc_lower = 
	{
	_unit = _this select 0;
	while {true} do
		{
		if (vehicle _unit == _unit && tpw_skirmish_organic && !(lifestate _unit == "INCAPACITATED") && {_unit getvariable["tpw_core_enabled",1] == 1} && {_unit getvariable["tpw_core_disabled",0] == 0}) then
			{
			if (behaviour _unit in ["SAFE","CARELESS","AWARE"] && {animationstate _unit == "amovpercmwlksraswrfldf"}) then
				{
				_unit playmovenow "amovpercmwlkslowwrfldf_ver2";
				};
			if (animationstate _unit == "amovpknlmwlksraswrfldf") then 
				{
				_unit playmove "amovpknlmwlkslowwrfldf";
				};	
			};	
		sleep random 10;	
		};
	};

// UNITS PLAY AMBIENT ANIMATIONS WHEN RELAXED
tpw_skirmish_fnc_relax = 
	{
	sleep random 30;
	_unit = _this select 0;
	while {true} do
		{
		sleep random 10;
		if (vehicle _unit == _unit && tpw_skirmish_organic && !(lifestate _unit == "INCAPACITATED") && {_unit getvariable["tpw_core_enabled",1] == 1} && {_unit getvariable["tpw_core_disabled",0] == 0}) then
			{
			_leader = leader group _unit;
			group _unit setbehaviour (behaviour _leader);
			group _unit setcombatmode (combatmode _leader);		
			if (stance _unit == "STAND" && {behaviour _unit in ["CARELESS","SAFE","AWARE"]} && {speed _unit ==0} && {!(animationstate _unit in tpw_skirmish_acts)} && {_unit getvariable ["tpw_core_enabled",1]==1} && {_unit getvariable ["tpw_bleedout_writhe",0] == 0} && {_unit getvariable ["tpw_fallstate",0] == 0}) then
				{
				_act = "";
				if (damage _unit < 0.5) then
					{
					_act  = selectrandom tpw_skirmish_acts;
					} else
					{
					_act  = selectrandom ["acts_ambient_gestures_tired","acts_ambient_facepalm_1","acts_ambient_facepalm_2"];
					};
				_unit playmove _act;
				_ct = 0;
				waituntil 
					{
					sleep 1;
					_ct = _ct + 1;
					animationstate _unit != _act || _ct == 15
					};
				_unit switchmove "";
				};
			_unit stop false; sleep 0.1; _unit stop false;
			
			// UNITS MAINTAIN MORE ORGANIC FORMATION	
			if (_unit != _leader && {_leader distance _unit >10}) then
				{
				_pos = getposasl _leader;
				_dir = random 360;
				_dist = random 10;
				_posx = (_pos select 0) + (_dist * sin _dir);
				_posy = (_pos select 1) +  (_dist * cos _dir);
				_movepos = [_posx,_posy,0];
				_unit domove (_movepos);
				if (_unit distance _leader > 50) then 
					{
					_unit forcewalk false;
					_unit setspeedmode "NORMAL";
					} else
					{
					_unit setspeedmode "LIMITED";
					};
				};
			};	
		// AUTOMATICALLY REPLENSIH AMMO	
		_mags = (magazines _unit) select {_x == _unit getvariable "tpw_magazine" select 0};
		if (count _mags < 1) then
			{
			_unit addmagazine (_unit getvariable "tpw_magazine" select 0);
			_unit addmagazine (_unit getvariable "tpw_magazine" select 0);
			_unit addmagazine (_unit getvariable "tpw_magazine" select 0);
			_unit addmagazine (_unit getvariable "tpw_magazine" select 0);
			reload _unit;
			};			
		};
	};

 
// CRATER, HAZE AND GLOWING EMBERS AT FRESH BOMBSITES	
tpw_skirmish_fnc_bombhaze =  
	{
	private ["_crater","_spawnpos","_pos","_end","_colour","_alpha","_lifetime","_rotvel","_size","_weight","_diameter","_height","_source","_haze","_light","_intensity","_firesource","_heat"];
	_pos = _this select 0;
	_crater = (["land_shellcrater_02_large_f","land_shellcrater_02_small_f"] select floor random 2) createvehiclelocal _pos;
	_crater setdir random 360;
	_spawnpos = [_pos select 0, _pos select 1, 0.3]; // always spawn haze at ground level
	_end = diag_ticktime + 180 + random 180;
	_colour = [0.8, 0.75, 0.7]; // dust colour
	_alpha = 0.1; // lower = more transparent haze
	_lifetime = 30; // particle lifetime (sec)
	_rotvel = [0,0,0]; // rotation speed is wind dependent
	_size = 20; // particle size
	_weight = 1.25; // particle weight
	// Volume to spawn particles in
	_diameter = 10; // x and y  
	_height = 1; // z
	_intensity = random 20; // intensity of crater fire light
	
	// Trash nearby objects
		{_x setdamage 1;
		} foreach nearestterrainobjects[_spawnpos,[],30,false];
	
		{_x hideobject true;
		_x enablesimulation false;
		} foreach nearestterrainobjects[_spawnpos,[],15,false];

		{
		if (random 1 > 0.99) then
			{
			_stump = ["a3\vegetation_f_enoch\tree\d_picea_stump.p3d",
			"a3\vegetation_f_enoch\tree\d_fagussylvatica_stumpc.p3d",
			"a3\vegetation_f_enoch\tree\d_betula_pendula_stump.p3d"] select floor random 3;
			_obj = createsimpleobject [_stump,position _x];
			_obj setposatl [position _x select 0,position _x select 1,0];
			_obj setdir random 360;
			_obj enablesimulation false;
			};
		} foreach nearestterrainobjects[_spawnpos,["tree","small tree"],25,false];
	
	while {diag_ticktime < _end} do 
		{
		_firesource = "logic" createVehicleLocal _spawnpos;
		_firesource setpos _spawnpos;
		
		_light = "#lightpoint" createVehiclelocal _spawnpos;   
		_light setLightColor [250,75,0]; //slightly yellow
		_light setLightAmbient [1,0.3,0]; 
		_light setlightattenuation [2,4,4,0,1,2];
		_light setLightIntensity _intensity;
		_light attachto [_firesource,[0,0,0]];
		
		_heat = "#particlesource" createVehicleLocal _spawnpos;
		_heat setParticleClass "Refract";  
		_heat attachto [_firesource,[0,0,0]];	
		
		_source = "logic" createVehicleLocal _spawnpos;
		_source setpos _spawnpos;
		_haze = "#particlesource" createvehiclelocal _spawnpos;
		_haze attachto [_source,[0,0,0]];
		_haze setparticleparams [["a3\data_f\particleeffects\universal\universal.p3d", 16, 12, 8, 0], "", "billboard", 1, _lifetime, [0, 0, 0],_rotvel,1,_weight, 1, 0.01, [_size],[_colour + [0], _colour + [_alpha], _colour + [0]], [1000], 1, 1, "", "", _source];
		_haze setparticlerandom [1, [_diameter, _diameter, _height], [0, 0,-10], 0, 0, [0, 0, 0, 0.1], 0, 0];
		_haze setparticlecircle [0, [0, 0, 0]];
		_haze setdropinterval 0.5; // smaller = more haze
		
		sleep 27.67;
		
		_alpha = _alpha * 0.8; // increase haze transparency over time
		_intensity = _intensity *  0.8;// decrease light brightness over time
		
		deletevehicle _heat;
		deletevehicle _haze;
		deletevehicle _source;	
		deletevehicle _light;
		deletevehicle _firesource;	
		};
	};				

// RANDOM POSITION	
tpw_skirmish_fnc_randpos =
	{
	private ["_thispos","_radius","_dir","_posx","_posy","_randpos"];
	_thispos = _this select 0;
	_radius = _this select 1;
	_dir = random 360;
	_posx = ((_thispos select 0) + (_radius * sin(_dir)));
	_posy = ((_thispos select 1) + (_radius * cos(_dir)));
	_randpos = [_posx,_posy,0]; 
	_randpos
	};	
	
// CAMERA SHAKE FROM DISTANT EXPLOSIONS	
tpw_skirmish_fnc_expshake = 
	{
	private ["_bomb","_dist","_delay","_intensity","_height","_bombpos"];
	_bomb = _this select 0;	
	_bombpos = getposasl _bomb;
	_dist = _bomb distance player;
	tpw_core_battletime = diag_ticktime + 60 + random 120;

	// Wait until bomb hits the ground
	waituntil
		{
		_height = (getposatl _bomb) select 2; 
		_height < 10;
		};
	[_bombpos] spawn tpw_skirmish_fnc_bombhaze; 

	_delay = _dist / 313; // speed of sound delay
	_intensity = (500 / _dist) ^ 2; // greater intensity of closer explosion
	sleep _delay;
	addcamshake [_intensity, 1, 10];
	};	

//ASL - ADVANCED SQUAD LEADER - AI SQUAD LEADER CAN CALL IN CAS OR ARTILLERY
tpw_skirmish_fnc_asl =
	{
	private ["_maxdist","_min","_scantime","_sql","_group","_cancallsupport","_side","_enemyside","_mindist","_groupdist","_allunits","_enemyvehicles","_enemyinfantry","_friendlyunits","_target","_targetset","_assets","_asset","_grid","_hq"];

	_sql = _this select 0; // Squad leader
	_cas = _this select 1; // Can call close air support
	_art = _this select 2; // Can call artillery support
	_group = group _sql; // Group of the squad leader
	_cancallsupport = true; // Squad leader can scan for targets 
	_scantime = 30; // How often will squad leader scan for new targets (sec)
	_hq=[West,"HQ"]; 

	// Asset sharing variables - ensure that AI squads can only call one instance of a given asset
	if (isNil "tpw_asl_cas_west") then 
		{
		tpw_asl_cas_west = true;
		};
	if (isNil "tpw_asl_chs_west") then 
		{
		tpw_asl_chs_west = true;
		};	
	if (isNil "tpw_asl_uav_west") then 
		{
		tpw_asl_uav_west = true;
		};			
	if (isNil "tpw_asl_art_west") then 
		{
		tpw_asl_art_west = true;
		};
	if (isNil "tpw_asl_smoke_west") then 
		{
		tpw_asl_smoke_west = true;
		};
	if (isNil "tpw_asl_flare_west") then 
		{
		tpw_asl_flare_west = true;
		};	

	// Remove squad leader binoculars (stops them from remaining indefinitely rooted to the spot looking through them)
	if ("Binocular" in weapons _sql) then
		{
		_sql removeWeapon "Binocular";
		};
		
	// CAS - plane
	_fnc_casplane =
		{
		private ["_planetype","_target","_pos","_startpos","_endpos","_plane","_pilot","_grp","_wp0","_wp1","_dir","_dist","_posx","_posy","_droppos","_shell"];
		_cancallsupport = false;
		tpw_asl_cas_west = false;
		
		if !(tpw_skirmish_casstring isEqualTo []) then
			{
			_planetype = selectRandom tpw_skirmish_casstring;
			}  else
			{
			_planetype = "B_Plane_CAS_01_F";
			};
	
		_target = _this select 0;
		_grid = mapGridPosition _target;
		if (side player == WEST) then
			{
			_hq SideChat format ["All units be advised: close air support has been dispatched to co-ordinates %1.",_grid];
			createmarker ["tpwcasmarker", position _target] ;
			"tpwcasmarker" setmarkertype "hd_objective";
			"tpwcasmarker" setMarkerAlpha 0.5;
			"tpwcasmarker" setmarkercolor "colorblack";
			"tpwcasmarker" setmarkertext "!!CAS";	
			};
		_pos = position _target;
		_startpos = [(_pos select 0),(_pos select 1) + 5000,100];
		_endpos = [(_pos select 0),(_pos select 1) - 5000,1000];
		_grp = createGroup west; 
		_plane = [_startpos,0,_planetype,_grp] call BIS_fnc_spawnVehicle;
		_plane = _plane select 0;
		_pilot = driver _plane;
		_pilot setcaptive true;
		_pilot setskill 0;
		_pilot disableAI "TARGET";
		_pilot disableAI "AUTOTARGET";
		_grp setBehaviour "COMBAT"; 
		_grp setCombatMode "RED";  
		_wp0 = _grp addwaypoint[_pos,100];
		_wp0 setwaypointtype "move"; 
		_wp1 = _grp addwaypoint[_endpos,0];
		_wp1 setwaypointtype "Move"; 
		// Strafe target
		waitUntil {sleep 0.2;(_plane distance _pos < 1500)};
		_plane fireAtTarget [_target];
		waitUntil {sleep 0.2;(_plane distance _pos < 1000)};
		_plane fireAtTarget [_target];
		waitUntil {sleep 0.2;(_plane distance _pos < 600)};
		_plane fireAtTarget [_target];
	
		// Climb and drop bomb		
		waitUntil {sleep 0.2;(_plane distance _pos < 500)};
		_plane flyinheight 500;		
		sleep 5;
		for "_j" from 1 to 4 do // number of shells per barrage
			{
			// Shells will land randomly around target
			if (!isnull _target && _target distance _pos < 200) then
				{
				_pos = position _target;
				};
			_dir = random 360;
			_dist = random 10;
			_posx = (_pos select 0) + (_dist * sin _dir);
			_posy = (_pos select 1) +  (_dist * cos _dir);
			_droppos = [_posx,_posy,20];
			_shell = "Bo_GBU12_LGB" createVehicle _droppos;
			_shell hideobject true;
			_shell setposatl _droppos;
			[_shell] spawn tpw_skirmish_fnc_expshake;
			sleep random 1;	
			};	
	   _grp setSpeedMode "FULL";
		waitUntil {sleep 2;(_plane distance _target > 4000)};
		
		deleteVehicle _plane;
			{
			deletevehicle _x;
			sleep 0.1;
			} foreach crew _plane;
		deleteGroup _grp; 
		
		_cancallsupport = true;	
		tpw_asl_cas_west = true;
		if (side player == WEST) then
			{
			_hq SideChat format ["All units be advised: close air support at %1 has concluded and aircraft is R.T.B.",_grid];
			deletemarker "tpwcasmarker";
			};
		};
		
	// CAS - heli
	_fnc_casheli =
		{
		private ["_helitype","_target","_pos","_startpos","_startpos2","_endpos","_heli","_heli2","_grp","_wp0","_wp1","_time"];
		_cancallsupport = false;
		tpw_asl_chs_west = false;
		_target = _this select 0;
		_grid = mapGridPosition _target;

		if !(tpw_skirmish_chsstring isEqualTo []) then
			{
			_helitype = selectRandom tpw_skirmish_chsstring;
			}  else
			{
			_helitype = "B_Heli_Attack_01_F";
			};
			
		if (side player == WEST) then
			{
			_hq SideChat format ["All units be advised: gunship support has been dispatched to co-ordinates %1.",_grid];
			createmarker ["tpwchsmarker", position _target] ;
			"tpwchsmarker" setmarkertype "hd_objective";
			"tpwchsmarker" setMarkerAlpha 0.5;
			"tpwchsmarker" setmarkercolor "colorblack";
			"tpwchsmarker" setmarkertext "!!CHS";
			};
		_pos = position _target;
		_startpos = [(_pos select 0),(_pos select 1) - 5000,50];
		_endpos = [(_pos select 0),(_pos select 1) + 5000,500];
		_time = time + 600;
		_grp = createGroup west; 
		_heli = [_startpos,140,_helitype,_grp] call BIS_fnc_spawnVehicle; // Spawn helicopter and crew
		_heli = _heli select 0;
		_heli flyinheight 50;
		_grp setBehaviour "COMBAT";
		_grp setCombatMode "RED";  
		_wp0 = _grp addwaypoint[_pos,50];
		_wp0 setwaypointtype "move"; 

		for "_i" from 1 to 3 do
			{
			_randpos = [_pos, (250 + random 250)] call tpw_skirmish_fnc_randpos;
			_wp = _grp addWaypoint [_randpos, 100];
			_wp setwaypointtype "move"; 
			};
		_wp1 = _grp addwaypoint[_endpos,0];
		_wp1 setwaypointtype "Move"; 
		
		//When to remove heli?
		waitUntil 
			{sleep 5;
			(
			((_heli distance _endpos < 1000) || !(alive _heli)) || 
			time > _time
			)
			};				

		deletevehicle _heli;
			{
			deletevehicle _x;
			sleep 0.1;
			} foreach units _grp;	
		deleteGroup _grp; 

		_cancallsupport = true;	
		tpw_asl_chs_west = true;
		_grid = mapGridPosition _target;
		if (side player == WEST) then
			{
			_hq SideChat format ["All units be advised: gunship support at %1 has concluded.",_grid];
			deletemarker "tpwchsmarker";
			};
		};

	// CAS - UAV
	_fnc_casuav =
		{
		private ["_target","_pos","_startpos","_endpos","_plane","_pilot","_grp","_wp0","_wp1","_dir","_dist","_posx","_posy","_droppos","_shell","_uavtype"];
		_cancallsupport = false;
		tpw_asl_uav_west = false;
		_target = _this select 0;
		_grid = mapGridPosition _target;

		if !(tpw_skirmish_uavstring isEqualTo []) then
			{
			_uavtype = selectRandom tpw_skirmish_uavstring;
			}  else
			{
			_uavtype = "B_UAV_02_CAS_F";
			};

		if (side player == WEST) then
			{
			_hq SideChat format ["All units be advised: UAV support has been dispatched to co-ordinates %1.",_grid];
			createmarker ["tpwuavmarker", position _target] ;
			"tpwuavmarker" setmarkertype "hd_objective";
			"tpwuavmarker" setMarkerAlpha 0.5;
			"tpwuavmarker" setmarkercolor "colorblack";
			"tpwuavmarker" setmarkertext "!!UAV";	
			};
		_pos = position _target;
		_startpos = [(_pos select 0),(_pos select 1) + 2500,50];
		_endpos = [(_pos select 0),(_pos select 1) - 2500,200];
		_grp = createGroup west; 
		_plane = [_startpos,0,_uavtype,_grp] call BIS_fnc_spawnVehicle;
		_plane = _plane select 0;
		_pilot = driver _plane;
		_pilot setcaptive true;
		_pilot setskill 0;
		_pilot disableAI "TARGET";
		_pilot disableAI "AUTOTARGET";
		_grp setBehaviour "COMBAT"; 
		_grp setCombatMode "RED"; 
		_grp setSpeedMode "FULL";		
		_wp0 = _grp addwaypoint[_pos,100];
		_wp0 setwaypointtype "move"; 
		_wp1 = _grp addwaypoint[_endpos,0];
		_wp1 setwaypointtype "Move"; 
		waitUntil {sleep 1;(_plane distance _pos < 500)};
		_plane flyinheight 200;		
		sleep 7;
		for "_j" from 1 to 2 do // number of shells per barrage
			{
			// Shells will land randomly around target
			if (!isnull _target && _target distance _pos < 200) then
				{
				_pos = position _target;
				};
			_dir = random 360;
			_dist = random 10;
			_posx = (_pos select 0) + (_dist * sin _dir);
			_posy = (_pos select 1) +  (_dist * cos _dir);
			_droppos = [_posx,_posy,20];
			_shell = "Bo_Mk82" createVehicle _droppos;
			_shell hideobject true;
			_shell setposatl _droppos;
			[_shell] spawn tpw_skirmish_fnc_expshake;
			sleep random 1;	
			};	
		waitUntil {sleep 2;(_plane distance _target > 2000)};
		deleteVehicle _plane;
		deleteGroup _grp; 
		_cancallsupport = true;	
		tpw_asl_uav_west = true;
		if (side player == WEST) then
			{
			_hq SideChat format ["All units be advised: UAV support at %1 has concluded and aircraft is R.T.B.",_grid];
			deletemarker "tpwuavmarker";
			};
		};			

	// Artillery
	_fnc_arty =
		{
		private ["_target","_pos","_dir","_dist","_posx","_posy","_droppos","_shell"];
		_cancallsupport = false; 
		tpw_asl_art_west = false;
		_target = _this select 0;
		_grid = mapGridPosition _target;
		_pos = position _target;
		if (side player == WEST) then
			{		
			_hq SideChat format ["All units be advised: artillery H.E. inbound on co-ordinates %1.",_grid];
			createmarker ["tpwhemarker", position _target] ;
			"tpwhemarker" setmarkertype "hd_objective";
			"tpwhemarker" setMarkerAlpha 0.5;
			"tpwhemarker" setmarkercolor "colorblack";
			"tpwhemarker" setmarkertext "!!HE";
			};
		sleep 30 + random 60;
		for "_i" from 1 to 6 do // number of barrages
			{
			for "_j" from 1 to 4 do // number of shells per barrage
				{
				// Shells will land randomly around target
				if (!isnull _target && _target distance _pos > 200) then
					{
					_pos = position _target;
					};
				_dir = random 360;
				_dist = random 50;
				_posx = (_pos select 0) + (_dist * sin _dir);
				_posy = (_pos select 1) +  (_dist * cos _dir);
				_droppos = [_posx,_posy,500];
				_shell = createVehicle ["Sh_82mm_AMOS",_droppos,[],0,"FLY"]; // Create shell
				_shell say "shell1";
				_shell setVelocity [0,0,-100];
				[_shell] spawn tpw_skirmish_fnc_expshake;				
				sleep random 1;	
				};
			sleep random 10;	
			};	
		_cancallsupport = true;
		tpw_asl_art_west = true;
		if (side player == WEST) then
			{
			_hq SideChat format ["All units be advised: artillery support at %1 has concluded.",_grid];
			deletemarker "tpwhemarker";
			};
		};
		
	// Smoke
	_fnc_smoke =
		{
		private ["_target","_pos","_dir","_dist","_posx","_posy","_droppos","_shell"];
		_cancallsupport = false;
		tpw_asl_smoke_west = false;
		_target = _this select 0;
		_grid = mapGridPosition _target;
		_pos = position _target;
		if (side player == WEST) then
			{
			_hq SideChat format ["All units be advised: artillery smoke inbound on co-ordinates %1.",_grid];
			createmarker ["tpwsmkmarker", position _target] ;
			"tpwsmkmarker" setmarkertype "hd_objective";
			"tpwsmkmarker" setMarkerAlpha 0.5;
			"tpwsmkmarker" setmarkercolor "colorblack";
			"tpwsmkmarker" setmarkertext "!!SMK";
			};
		sleep 30 + random 60;
		
		for "_i" from 1 to 4 do
			{
			for "_j" from 1 to 4 do
				{
				if (!isnull _target && _target distance _pos < 200) then
					{
					_pos = position _target;
					};
				_dir = random 360;
				_dist = random 100;
				_posx = (_pos select 0) + (_dist * sin _dir);
				_posy = (_pos select 1) +  (_dist * cos _dir);
				_droppos = [_posx,_posy,500];
				_shell = createVehicle ["SmokeShell",_droppos,[],0,"FLY"]; // Create shell
				_shell say "shell1";
				_shell setVelocity [0,0,-100]; 				
				sleep random 1;	
				};
			sleep random 10;	
			};	
		_cancallsupport = true;
		tpw_asl_smoke_west = true;
		if (side player == WEST) then
			{
			_hq SideChat format ["All units be advised: artillery smoke support at %1 has concluded.",_grid];
			deletemarker "tpwsmkmarker";
			};
		};		
		
	// Flare
	_fnc_flare =
		{
		private ["_target","_pos","_dir","_dist","_posx","_posy","_droppos","_shell"];
		_cancallsupport = false;
		tpw_asl_flare_west = false;
		_target = _this select 0;
		_grid = mapGridPosition _target;
		_pos = position _target;
		if (side player == WEST) then
			{
			_hq SideChat format ["All units be advised: artillery flares inbound on co-ordinates %1.",_grid];
			createmarker ["tpwflrmarker", position _target] ;
			"tpwflrmarker" setmarkertype "hd_objective";
			"tpwflrmarker" setMarkerAlpha 0.5;
			"tpwflrmarker" setmarkercolor "colorblack";
			"tpwflrmarker" setmarkertext "!!FLR";
			};
		sleep 30 + random 60;
		for "_i" from 1 to 4 do
			{
			for "_j" from 1 to 4 do
				{
				_dir = random 360;
				_dist = random 100;
				if (!isnull _target && _target distance _pos < 200) then
					{
					_pos = position _target;
					};
				_posx = (_pos select 0) + (_dist * sin _dir);
				_posy = (_pos select 1) +  (_dist * cos _dir);
				_droppos = [_posx,_posy,250];
				_shell = createVehicle ["F_40mm_White",_droppos,[],0,"FLY"]; // Create shell
				// Attach more powerful light to flare shell
				_light = "#lightpoint" createVehiclelocal _droppos;   
				_light setLightColor [200,200,250]; // blueish white
				_light setLightAmbient [.8,.8,1]; 
				_light setlightattenuation [50,4,4,0,1,1000];
				[_light,_shell] spawn
					{
					_light = _this select 0;
					_shell = _this select 1;
					sleep random 2;
					waituntil 
						{
						sleep random 2;
						_light setlightintensity  200 + random 400;
						(position _shell) select 2 < 150;
						};
					deletevehicle _light;
					};
				_shell setVelocity [random 10,random 10 ,random 10]; 
				sleep random 5;	
				};
			sleep random 30;	
			};	
		_cancallsupport = true;
		tpw_asl_flare_west = true;	
		if (side player == WEST) then
			{
			_hq SideChat format ["All units be advised: artillery flare support at %1 has concluded.",_grid];
			deletemarker "tpwflrmarker";
			};
		};	
		
	// Determine which assets are available, pick a random one	
	_fnc_assets =
		{
		_assets = [];
		if (_cas && tpw_asl_cas_west) then 
			{
			_assets pushback _fnc_casplane;
			};
		if (_cas && tpw_asl_chs_west) then 
			{
			_assets pushback _fnc_casheli;
			};	
		if (_cas && tpw_asl_uav_west) then 
			{
			_assets pushback _fnc_casuav;
			};			
		if (_art && tpw_asl_art_west) then
			{
			_assets pushback _fnc_arty;
			};
		if (_art && tpw_asl_smoke_west) then
			{
			_assets pushback _fnc_smoke;
			};		
		if (_art && tpw_asl_flare_west && {tpw_core_sunangle < 0}) then
			{
			_assets pushback _fnc_flare;
			};	
		if (count _assets > 0) then 
			{	
			_asset = _assets select (floor (random (count _assets)));	
			_sql doWatch _target;
			[_target] call _asset;	
			};
		};
		
	// Select potential targets near squad leader
	_fnc_target =
		{	
		private _leaders = [];
			{
			_leaders pushback leader _x;
			} foreach (tpw_skirmish_friendlysquads + tpw_skirmish_resistsquads + tpw_skirmish_enemysquads + tpw_skirmish_friendlyvehicles + tpw_skirmish_resistvehicles + tpw_skirmish_enemyvehicles);

		private _eleaders = ((_leaders select {_x distance _sql> 200 && _x distance _sql < 1500}) select {(side _x) getFriend (side _sql) < 0.5}) select {[objNull, "VIEW"] checkVisibility [eyePos _x, eyepos _sql] > 0}; // all visible enemy leaders > 200m away

		private _fleaders = _leaders select {(side _x) getFriend (side _sql) > 0.5}; // all friendly leaders
		
		private _safetargets = []; // enemy leaders with no nearby friendly within 200m
			{
			_leader = _x;
			if (count (_fleaders select {_x distance _leader < 200}) == 0) then
				{
				_safetargets pushback _leader;
				};
			} foreach _eleaders;
			
		if (count _safetargets > 0) then
			{
			_target = _safetargets select floor random count _safetargets;
			_targetset = true;
			} else
			{
			_targetset = false;
			};		
		};	
		
	// Squad leader periodically scans for targets 
	while {count (units _group) > 0} do
		{
		_sql = leader _group; 
		if (_cancallsupport) then
			{
			[] call _fnc_target;
			
			// If target has been chosen
			if (_targetset) then 
				{
				[] call _fnc_assets;//Call in support
				};
			};
		sleep random _scantime;
		};	
	};

//ENEMY ASL - ADVANCED SQUAD LEADER - OPFOR AI SQUAD LEADER CAN CALL IN CAS OR ARTILLERY 
tpw_skirmish_enemy_fnc_asl =
	{
	private ["_maxdist","_min","_scantime","_sql","_group","_cancallsupport","_side","_enemyside","_mindist","_groupdist","_allunits","_enemyvehicles","_enemyinfantry","_friendlyunits","_target","_targetset","_assets","_asset","_grid","_hq"];

	_sql = _this select 0; // Squad leader
	_cas = _this select 1; // Can call close air support
	_art = _this select 2; // Can call artillery support
	_group = group _sql; // Group of the squad leader
	_cancallsupport = true; // Squad leader can scan for targets 
	_scantime = 30; // How often will squad leader scan for new targets (sec)
	_hq=[East,"HQ"]; 

	// Asset sharing variables - ensure that AI squads can only call one instance of a given asset
	if (isNil "tpw_asl_cas_east") then 
		{
		tpw_asl_cas_east = true;
		};
	if (isNil "tpw_asl_chs_east") then 
		{
		tpw_asl_chs_east = true;
		};	
	if (isNil "tpw_asl_uav_east") then 
		{
		tpw_asl_uav_east = true;
		};			
	if (isNil "tpw_asl_art_east") then 
		{
		tpw_asl_art_east = true;
		};
	if (isNil "tpw_asl_smoke_east") then 
		{
		tpw_asl_smoke_east = true;
		};
	if (isNil "tpw_asl_flare_east") then 
		{
		tpw_asl_flare_east = true;
		};	

	// Remove squad leader binoculars (stops them from remaining indefinietely rooted to the spot looking through them)
	if ("Binocular" in weapons _sql) then
		{
		_sql removeWeapon "Binocular";
		};
		
	// CAS - plane
	_fnc_casplane =
		{
		private ["_planetype","_target","_pos","_startpos","_endpos","_plane","_pilot","_grp","_wp0","_wp1","_dir","_dist","_posx","_posy","_droppos","_shell"];
		_cancallsupport = false;
		tpw_asl_cas_east = false;
		
		if !(tpw_skirmish_enemy_casstring isEqualTo []) then
			{
			_planetype = selectRandom tpw_skirmish_enemy_casstring;
			}  else
			{
			_planetype = "O_Plane_CAS_02_F";
			};
	
		_target = _this select 0;
		_grid = mapGridPosition _target;
		if (side player == EAST) then
			{
			_hq SideChat format ["All units be advised: close air support has been dispatched to co-ordinates %1.",_grid];
			createmarker ["tpwcasmarker", position _target] ;
			"tpwcasmarker" setmarkertype "hd_objective";
			"tpwcasmarker" setMarkerAlpha 0.5;
			"tpwcasmarker" setmarkercolor "colorblack";
			"tpwcasmarker" setmarkertext "!!CAS";	
			};
		_pos = position _target;
		_startpos = [(_pos select 0),(_pos select 1) + 5000,100];
		_endpos = [(_pos select 0),(_pos select 1) - 5000,1000];
		_grp = createGroup east; 
		_plane = [_startpos,0,_planetype,_grp] call BIS_fnc_spawnVehicle;
		_plane = _plane select 0;
		_pilot = driver _plane;
		_pilot setcaptive true;
		_pilot setskill 0;
		_pilot disableAI "TARGET";
		_pilot disableAI "AUTOTARGET";
		_grp setBehaviour "COMBAT"; 
		_grp setCombatMode "RED";  
		_wp0 = _grp addwaypoint[_pos,100];
		_wp0 setwaypointtype "move"; 
		_wp1 = _grp addwaypoint[_endpos,0];
		_wp1 setwaypointtype "Move"; 
		waitUntil {sleep 1;(_plane distance _pos < 500)};
		_plane flyinheight 500;		
		sleep 5;
		for "_j" from 1 to 4 do // number of shells per barrage
			{
			// Shells will land randomly around target
			if (!isnull _target && _target distance _pos < 200) then
				{
				_pos = position _target;
				};
			_dir = random 360;
			_dist = random 10;
			_posx = (_pos select 0) + (_dist * sin _dir);
			_posy = (_pos select 1) +  (_dist * cos _dir);
			_droppos = [_posx,_posy,0];
			_shell = "Bo_GBU12_LGB" createVehicle _droppos;
			[_shell] spawn tpw_skirmish_fnc_expshake;
			sleep random 1;	
			};	
	   _grp setSpeedMode "FULL";
		waitUntil {sleep 2;(_plane distance _target > 4000)};
		
		deleteVehicle _plane;
			{
			deletevehicle _x;
			sleep 0.1;
			} foreach crew _plane;
		deleteGroup _grp; 
		
		_cancallsupport = true;	
		tpw_asl_cas_east = true;
		if (side player == EAST) then
			{
			_hq SideChat format ["All units be advised: close air support at %1 has concluded and aircraft is R.T.B.",_grid];
			deletemarker "tpwcasmarker";
			};
		};
		
	// CAS - heli
	_fnc_casheli =
		{
		private ["_helitype","_target","_pos","_startpos","_startpos2","_endpos","_heli","_heli2","_grp","_wp0","_wp1","_time"];
		_cancallsupport = false;
		tpw_asl_chs_east = false;
		_target = _this select 0;
		_grid = mapGridPosition _target;

		if !(tpw_skirmish_enemy_chsstring isEqualTo []) then
			{
			_helitype = selectRandom tpw_skirmish_enemy_chsstring;
			}  else
			{
			_helitype = "O_Heli_Attack_02_F";
			};
			
		if (side player == EAST) then
			{
			_hq SideChat format ["All units be advised: helicopter support has been dispatched to co-ordinates %1.",_grid];
			createmarker ["tpwchsmarker", position _target] ;
			"tpwchsmarker" setmarkertype "hd_objective";
			"tpwchsmarker" setMarkerAlpha 0.5;
			"tpwchsmarker" setmarkercolor "colorblack";
			"tpwchsmarker" setmarkertext "!!CHS";
			};
		_pos = position _target;
		_startpos = [(_pos select 0),(_pos select 1) - 5000,50];
		_endpos = [(_pos select 0),(_pos select 1) + 5000,500];
		_time = time + 600;
		_grp = createGroup east; 
		_heli = [_startpos,140,_helitype,_grp] call BIS_fnc_spawnVehicle; // Spawn helicopter and crew
		_heli = _heli select 0;
		_heli flyinheight 50;
		_grp setBehaviour "COMBAT";
		_grp setCombatMode "RED";  
		_wp0 = _grp addwaypoint[_pos,50];
		_wp0 setwaypointtype "move"; 

		for "_i" from 1 to 3 do
			{
			_randpos = [_pos, (250 + random 250)] call tpw_skirmish_fnc_randpos;
			_wp = _grp addWaypoint [_randpos, 100];
			_wp setwaypointtype "move"; 
			};
		_wp1 = _grp addwaypoint[_endpos,0];
		_wp1 setwaypointtype "Move"; 
		
		//When to remove helis?
		waitUntil 
			{sleep 5;
			(
			((_heli distance _endpos < 1000) || !(alive _heli))  || 
			time > _time
			)
			};				

		deletevehicle _heli;
		deletevehicle _heli2;	
			{
			deletevehicle _x;
			sleep 0.1;
			} foreach units _grp;	
		deleteGroup _grp; 

		_cancallsupport = true;	
		tpw_asl_chs_east = true;
		_grid = mapGridPosition _target;
		if (side player == EAST) then
			{
			_hq SideChat format ["All units be advised: helicopter support at %1 has concluded.",_grid];
			deletemarker "tpwchsmarker";
			};
		};

	// CAS - UAV
	_fnc_casuav =
		{
		private ["_target","_pos","_startpos","_endpos","_plane","_pilot","_grp","_wp0","_wp1","_dir","_dist","_posx","_posy","_droppos","_shell","_uavtype"];
		_cancallsupport = false;
		tpw_asl_uav_east = false;
		_target = _this select 0;
		_grid = mapGridPosition _target;

		if !(tpw_skirmish_enemy_uavstring isEqualTo []) then
			{
			_uavtype = selectRandom tpw_skirmish_enemy_uavstring;
			}  else
			{
			_uavtype = "O_UAV_02_CAS_F";
			};

		if (side player == EAST) then
			{
			_hq SideChat format ["All units be advised: UAV support has been dispatched to co-ordinates %1.",_grid];
			createmarker ["tpwuavmarker", position _target] ;
			"tpwuavmarker" setmarkertype "hd_objective";
			"tpwuavmarker" setMarkerAlpha 0.5;
			"tpwuavmarker" setmarkercolor "colorblack";
			"tpwuavmarker" setmarkertext "!!UAV";	
			};
		_pos = position _target;
		_startpos = [(_pos select 0),(_pos select 1) + 2500,50];
		_endpos = [(_pos select 0),(_pos select 1) - 2500,200];
		_grp = createGroup east; 
		_plane = [_startpos,0,_uavtype,_grp] call BIS_fnc_spawnVehicle;
		_plane = _plane select 0;
		_pilot = driver _plane;
		_pilot setcaptive true;
		_pilot setskill 0;
		_pilot disableAI "TARGET";
		_pilot disableAI "AUTOTARGET";
		_grp setBehaviour "COMBAT"; 
		_grp setCombatMode "RED"; 
		_grp setSpeedMode "FULL";		
		_wp0 = _grp addwaypoint[_pos,100];
		_wp0 setwaypointtype "move"; 
		_wp1 = _grp addwaypoint[_endpos,0];
		_wp1 setwaypointtype "Move"; 
		waitUntil {sleep 1;(_plane distance _pos < 500)};
		_plane flyinheight 200;		
		sleep 7;
		for "_j" from 1 to 2 do // number of shells per barrage
			{
			// Shells will land randomly around target
			if (!isnull _target && _target distance _pos < 200) then
				{
				_pos = position _target;
				};
			_dir = random 360;
			_dist = random 10;
			_posx = (_pos select 0) + (_dist * sin _dir);
			_posy = (_pos select 1) +  (_dist * cos _dir);
			_droppos = [_posx,_posy,0];
			_shell = "Bo_Mk82" createVehicle _droppos;
			[_shell] spawn tpw_skirmish_fnc_expshake;
			sleep random 1;	
			};	
		waitUntil {sleep 2;(_plane distance _target > 2000)};
		deleteVehicle _plane;
		deleteGroup _grp; 
		_cancallsupport = true;	
		tpw_asl_uav_east = true;
		if (side player == EAST) then
			{
			_hq SideChat format ["All units be advised: UAV support at %1 has concluded and aircraft is R.T.B.",_grid];
			deletemarker "tpwuavmarker";
			};
		};			

	// Artillery
	_fnc_arty =
		{
		private ["_target","_pos","_dir","_dist","_posx","_posy","_droppos","_shell"];
		_cancallsupport = false; 
		tpw_asl_art_east = false;
		_target = _this select 0;
		_grid = mapGridPosition _target;
		_pos = position _target;
		if (side player == EAST) then
			{		
			_hq SideChat format ["All units be advised: artillery H.E. inbound on co-ordinates %1.",_grid];
			createmarker ["tpwhemarker", position _target] ;
			"tpwhemarker" setmarkertype "hd_objective";
			"tpwhemarker" setMarkerAlpha 0.5;
			"tpwhemarker" setmarkercolor "colorblack";
			"tpwhemarker" setmarkertext "!!HE";
			};
		sleep 30 + random 60;
		for "_i" from 1 to 6 do // number of barrages
			{
			for "_j" from 1 to 4 do // number of shells per barrage
				{
				// Shells will land randomly around target
				if (!isnull _target && _target distance _pos > 200) then
					{
					_pos = position _target;
					};
				_dir = random 360;
				_dist = random 50;
				_posx = (_pos select 0) + (_dist * sin _dir);
				_posy = (_pos select 1) +  (_dist * cos _dir);
				_droppos = [_posx,_posy,500];
				_shell = createVehicle ["Sh_82mm_AMOS",_droppos,[],0,"FLY"]; // Create shell
				_shell say "shell1";
				_shell setVelocity [0,0,-100];
				[_shell] spawn tpw_skirmish_fnc_expshake;				
				sleep random 1;	
				};
			sleep random 10;	
			};	
		_cancallsupport = true;
		tpw_asl_art_east = true;
		if (side player == east) then
			{
			_hq SideChat format ["All units be advised: artillery support at %1 has concluded.",_grid];
			deletemarker "tpwhemarker";
			};
		};
		
	// Smoke
	_fnc_smoke =
		{
		private ["_target","_pos","_dir","_dist","_posx","_posy","_droppos","_shell"];
		_cancallsupport = false;
		tpw_asl_smoke_east = false;
		_target = _this select 0;
		_grid = mapGridPosition _target;
		_pos = position _target;
		if (side player == east) then
			{
			_hq SideChat format ["All units be advised: artillery smoke inbound on co-ordinates %1.",_grid];
			createmarker ["tpwsmkmarker", position _target] ;
			"tpwsmkmarker" setmarkertype "hd_objective";
			"tpwsmkmarker" setMarkerAlpha 0.5;
			"tpwsmkmarker" setmarkercolor "colorblack";
			"tpwsmkmarker" setmarkertext "!!SMK";
			};
		sleep 30 + random 60;
		
		for "_i" from 1 to 4 do
			{
			for "_j" from 1 to 2 do
				{
				if (!isnull _target && _target distance _pos < 200) then
					{
					_pos = position _target;
					};
				_dir = random 360;
				_dist = random 100;
				_posx = (_pos select 0) + (_dist * sin _dir);
				_posy = (_pos select 1) +  (_dist * cos _dir);
				_droppos = [_posx,_posy,500];
				_shell = createVehicle ["SmokeShellOrange",_droppos,[],0,"FLY"]; // Create shell
				_shell say "shell1";
				_shell setVelocity [0,0,-100]; 				
				sleep random 1;	
				};
			sleep random 10;	
			};	
		_cancallsupport = true;
		tpw_asl_smoke_east = true;
		if (side player == east) then
			{
			_hq SideChat format ["All units be advised: artillery smoke support at %1 has concluded.",_grid];
			deletemarker "tpwsmkmarker";
			};
		};		
		
	// Flare
	_fnc_flare =
		{
		private ["_target","_pos","_dir","_dist","_posx","_posy","_droppos","_shell"];
		_cancallsupport = false;
		tpw_asl_flare_east = false;
		_target = _this select 0;
		_grid = mapGridPosition _target;
		_pos = position _target;
		if (side player == east) then
			{
			_hq SideChat format ["All units be advised: artillery flares inbound on co-ordinates %1.",_grid];
			createmarker ["tpwflrmarker", position _target] ;
			"tpwflrmarker" setmarkertype "hd_objective";
			"tpwflrmarker" setMarkerAlpha 0.5;
			"tpwflrmarker" setmarkercolor "colorblack";
			"tpwflrmarker" setmarkertext "!!FLR";
			};
		sleep 30 + random 60;
		for "_i" from 1 to 4 do
			{
			for "_j" from 1 to 4 do
				{
				_dir = random 360;
				_dist = random 100;
				if (!isnull _target && _target distance _pos < 200) then
					{
					_pos = position _target;
					};
				_posx = (_pos select 0) + (_dist * sin _dir);
				_posy = (_pos select 1) +  (_dist * cos _dir);
				_droppos = [_posx,_posy,250];
				_shell = createVehicle ["F_40mm_White",_droppos,[],0,"FLY"]; // Create shell
				// Attach more powerful light to flare shell
				_light = "#lightpoint" createVehiclelocal _droppos;   
				_light setLightColor [200,200,250]; // blueish white
				_light setLightAmbient [.8,.8,1]; 
				_light setlightattenuation [50,4,4,0,1,1000];
				[_light,_shell] spawn
					{
					_light = _this select 0;
					_shell = _this select 1;
					sleep random 2;
					waituntil 
						{
						sleep random 2;
						_light setlightintensity  200 + random 400;
						(position _shell) select 2 < 150;
						};
					deletevehicle _light;
					};
				_shell setVelocity [random 10,random 10 ,random 10]; 
				sleep random 5;	
				};
			sleep random 30;	
			};	
		_cancallsupport = true;
		tpw_asl_flare_east = true;	
		if (side player == east) then
			{
			_hq SideChat format ["All units be advised: artillery flare support at %1 has concluded.",_grid];
			deletemarker "tpwflrmarker";
			};
		};	
		
	// Determine which assets are available, pick a random one	
	_fnc_assets =
		{
		_assets = [];
		if (_cas && tpw_asl_cas_east) then 
			{
			_assets pushback _fnc_casplane;
			};
		if (_cas && tpw_asl_chs_east) then 
			{
			_assets pushback _fnc_casheli;
			};	
		if (_cas && tpw_asl_uav_east) then 
			{
			_assets pushback _fnc_casuav;
			};			
		if (_art && tpw_asl_art_east) then
			{
			_assets pushback _fnc_arty;
			};
		if (_art && tpw_asl_smoke_east) then
			{
			_assets pushback _fnc_smoke;
			};		
		if (_art && tpw_asl_flare_east && {tpw_core_sunangle < 0}) then
			{
			_assets pushback _fnc_flare;
			};	
		if (count _assets > 0) then 
			{	
			_asset = _assets select (floor (random (count _assets)));	
			_sql doWatch _target;
			[_target] call _asset;	
			};
		};
		
	// Select potential targets near squad leader
	_fnc_target =
		{	
		private _leaders = [];
			{
			_leaders pushback leader _x;
			} foreach (tpw_skirmish_friendlysquads + tpw_skirmish_resistsquads + tpw_skirmish_enemysquads + tpw_skirmish_friendlyvehicles + tpw_skirmish_resistvehicles + tpw_skirmish_enemyvehicles);

		private _eleaders = ((_leaders select {_x distance _sql> 200 && _x distance _sql < 1500}) select {(side _x) getFriend (side _sql) < 0.5}) select {[objNull, "VIEW"] checkVisibility [eyePos _x, eyepos _sql] > 0}; // all visible enemy leaders > 200m away

		private _fleaders = _leaders select {(side _x) getFriend (side _sql) > 0.5}; // all friendly leaders
		
		private _safetargets = []; // enemy leaders with no nearby friendly within 200m
			{
			_leader = _x;
			if (count (_fleaders select {_x distance _leader < 200}) == 0) then
				{
				_safetargets pushback _leader;
				};
			} foreach _eleaders;
			
		if (count _safetargets > 0) then
			{
			_target = _safetargets select floor random count _safetargets;
			_targetset = true;
			} else
			{
			_targetset = false;
			};		
		};				
		
	// Squad leader periodically scans for targets
	while {count (units _group) > 0} do
		{
		_sql = leader _group; 
		if (_cancallsupport) then
			{
			[] call _fnc_target;
			
			// If target has been chosen
			if (_targetset) then 
				{
				[] call _fnc_assets;//Call in support
				};
			};
		sleep random _scantime;
		};	
	};

//RESISTANCE ASL - ADVANCED SQUAD LEADER - INDFOR AI SQUAD LEADER CAN CALL IN CAS OR ARTILLERY 
tpw_skirmish_resist_fnc_asl =
	{
	private ["_maxdist","_min","_scantime","_sql","_group","_cancallsupport","_side","_enemyside","_mindist","_groupdist","_allunits","_enemyvehicles","_enemyinfantry","_friendlyunits","_target","_targetset","_assets","_asset","_grid","_hq"];

	_sql = _this select 0; // Squad leader
	_cas = _this select 1; // Can call close air support
	_art = _this select 2; // Can call artillery support
	_group = group _sql; // Group of the side leader
	_cancallsupport = true; // Squad leader can scan for targets 
	_scantime = 30; // How often will squad leader scan for new targets (sec)
	_hq=[resistance,"HQ"]; 

	// Asset sharing variables - ensure that AI squads can only call one instance of a given asset
	if (isNil "tpw_asl_cas_resist") then 
		{
		tpw_asl_cas_resist = true;
		};
	if (isNil "tpw_asl_chs_resist") then 
		{
		tpw_asl_chs_resist = true;
		};	
	if (isNil "tpw_asl_uav_resist") then 
		{
		tpw_asl_uav_resist = true;
		};			
	if (isNil "tpw_asl_art_resist") then 
		{
		tpw_asl_art_resist = true;
		};
	if (isNil "tpw_asl_smoke_resist") then 
		{
		tpw_asl_smoke_resist = true;
		};
	if (isNil "tpw_asl_flare_resist") then 
		{
		tpw_asl_flare_resist = true;
		};	

	// Remove squad leader binoculars (stops them from remaining indefinietely rooted to the spot looking through them)
	if ("Binocular" in weapons _sql) then
		{
		_sql removeWeapon "Binocular";
		};
		
	// CAS - plane
	_fnc_casplane =
		{
		private ["_planetype","_target","_pos","_startpos","_endpos","_plane","_pilot","_grp","_wp0","_wp1","_dir","_dist","_posx","_posy","_droppos","_shell"];
		_cancallsupport = false;
		tpw_asl_cas_resist = false;
		
		if !(tpw_skirmish_resist_casstring isEqualTo []) then
			{
			_planetype = selectRandom tpw_skirmish_resist_casstring;
			}  else
			{
			_planetype = "I_Plane_Fighter_03_CAS_F";
			};
	
		_target = _this select 0;
		_grid = mapGridPosition _target;
		if (side player == resistance) then
			{
			_hq SideChat format ["All units be advised: close air support has been dispatched to co-ordinates %1.",_grid];
			createmarker ["tpwcasmarker", position _target] ;
			"tpwcasmarker" setmarkertype "hd_objective";
			"tpwcasmarker" setMarkerAlpha 0.5;
			"tpwcasmarker" setmarkercolor "colorblack";
			"tpwcasmarker" setmarkertext "!!CAS";	
			};
		_pos = position _target;
		_startpos = [(_pos select 0),(_pos select 1) + 5000,100];
		_endpos = [(_pos select 0),(_pos select 1) - 5000,1000];
		_grp = createGroup resistance; 
		_plane = [_startpos,0,_planetype,_grp] call BIS_fnc_spawnVehicle;
		_plane = _plane select 0;
		_pilot = driver _plane;
		_pilot setcaptive true;
		_pilot setskill 0;
		_pilot disableAI "TARGET";
		_pilot disableAI "AUTOTARGET";
		_grp setBehaviour "COMBAT"; 
		_grp setCombatMode "RED";  
		_wp0 = _grp addwaypoint[_pos,100];
		_wp0 setwaypointtype "move"; 
		_wp1 = _grp addwaypoint[_endpos,0];
		_wp1 setwaypointtype "Move"; 
		waitUntil {sleep 1;(_plane distance _pos < 500)};
		_plane flyinheight 500;		
		sleep 5;
		for "_j" from 1 to 4 do // number of shells per barrage
			{
			// Shells will land randomly around target
			if (!isnull _target && _target distance _pos < 200) then
				{
				_pos = position _target;
				};
			_dir = random 360;
			_dist = random 10;
			_posx = (_pos select 0) + (_dist * sin _dir);
			_posy = (_pos select 1) +  (_dist * cos _dir);
			_droppos = [_posx,_posy,0];
			_shell = "Bo_GBU12_LGB" createVehicle _droppos;
			[_shell] spawn tpw_skirmish_fnc_expshake;
			sleep random 1;	
			};	
	   _grp setSpeedMode "FULL";
		waitUntil {sleep 2;(_plane distance _target > 4000)};
		
		deleteVehicle _plane;
			{
			deletevehicle _x;
			sleep 0.1;
			} foreach crew _plane;
		deleteGroup _grp; 
		
		_cancallsupport = true;	
		tpw_asl_cas_resist = true;
		if (side player == resistance) then
			{
			_hq SideChat format ["All units be advised: close air support at %1 has concluded and aircraft is R.T.B.",_grid];
			deletemarker "tpwcasmarker";
			};
		};
		
	// CAS - heli
	_fnc_casheli =
		{
		private ["_helitype","_target","_pos","_startpos","_startpos2","_endpos","_heli","_heli2","_grp","_wp0","_wp1","_time"];
		_cancallsupport = false;
		tpw_asl_chs_resist = false;
		_target = _this select 0;
		_grid = mapGridPosition _target;

		if !(tpw_skirmish_resist_chsstring isEqualTo []) then
			{
			_helitype = selectRandom tpw_skirmish_resist_chsstring;
			}  else
			{
			_helitype = "I_Heli_light_03_F";
			};
			
		if (side player == resistance) then
			{
			_hq SideChat format ["All units be advised: helicopter support has been dispatched to co-ordinates %1.",_grid];
			createmarker ["tpwchsmarker", position _target] ;
			"tpwchsmarker" setmarkertype "hd_objective";
			"tpwchsmarker" setMarkerAlpha 0.5;
			"tpwchsmarker" setmarkercolor "colorblack";
			"tpwchsmarker" setmarkertext "!!CHS";
			};
		_pos = position _target;
		_startpos = [(_pos select 0),(_pos select 1) - 5000,50];
		_endpos = [(_pos select 0),(_pos select 1) + 5000,500];
		_time = time + 600;
		_grp = createGroup resistance; 
		_heli = [_startpos,140,_helitype,_grp] call BIS_fnc_spawnVehicle; // Spawn helicopter1 and crew
		_heli = _heli select 0;
		_heli flyinheight 50;
		_grp setBehaviour "COMBAT";
		_grp setCombatMode "RED";  
		_wp0 = _grp addwaypoint[_pos,50];
		_wp0 setwaypointtype "move"; 

		for "_i" from 1 to 3 do
			{
			_randpos = [_pos, (250 + random 250)] call tpw_skirmish_fnc_randpos;
			_wp = _grp addWaypoint [_randpos, 100];
			_wp setwaypointtype "move"; 
			};
		_wp1 = _grp addwaypoint[_endpos,0];
		_wp1 setwaypointtype "Move"; 
		
		//When to remove helis?
		waitUntil 
			{sleep 5;
			(
			((_heli distance _endpos < 1000) || !(alive _heli)) || 
			time > _time
			)
			};				

		deletevehicle _heli;
			{
			deletevehicle _x;
			sleep 0.1;
			} foreach units _grp;	
		deleteGroup _grp; 

		_cancallsupport = true;	
		tpw_asl_chs_resist = true;
		_grid = mapGridPosition _target;
		if (side player == resistance) then
			{
			_hq SideChat format ["All units be advised: helicopter support at %1 has concluded.",_grid];
			deletemarker "tpwchsmarker";
			};
		};

	// CAS - UAV
	_fnc_casuav =
		{
		private ["_target","_pos","_startpos","_endpos","_plane","_pilot","_grp","_wp0","_wp1","_dir","_dist","_posx","_posy","_droppos","_shell","_uavtype"];
		_cancallsupport = false;
		tpw_asl_uav_resist = false;
		_target = _this select 0;
		_grid = mapGridPosition _target;

		if !(tpw_skirmish_resist_uavstring isEqualTo []) then
			{
			_uavtype = selectRandom tpw_skirmish_resist_uavstring;
			}  else
			{
			_uavtype = "I_UAV_02_CAS_F";
			};

		if (side player == resistance) then
			{
			_hq SideChat format ["All units be advised: UAV support has been dispatched to co-ordinates %1.",_grid];
			createmarker ["tpwuavmarker", position _target] ;
			"tpwuavmarker" setmarkertype "hd_objective";
			"tpwuavmarker" setMarkerAlpha 0.5;
			"tpwuavmarker" setmarkercolor "colorblack";
			"tpwuavmarker" setmarkertext "!!UAV";	
			};
		_pos = position _target;
		_startpos = [(_pos select 0),(_pos select 1) + 2500,50];
		_endpos = [(_pos select 0),(_pos select 1) - 2500,200];
		_grp = createGroup resistance; 
		_plane = [_startpos,0,_uavtype,_grp] call BIS_fnc_spawnVehicle;
		_plane = _plane select 0;
		_pilot = driver _plane;
		_pilot setcaptive true;
		_pilot setskill 0;
		_pilot disableAI "TARGET";
		_pilot disableAI "AUTOTARGET";
		_grp setBehaviour "COMBAT"; 
		_grp setCombatMode "RED"; 
		_grp setSpeedMode "FULL";		
		_wp0 = _grp addwaypoint[_pos,100];
		_wp0 setwaypointtype "move"; 
		_wp1 = _grp addwaypoint[_endpos,0];
		_wp1 setwaypointtype "Move"; 
		waitUntil {sleep 1;(_plane distance _pos < 500)};
		_plane flyinheight 200;		
		sleep 7;
		for "_j" from 1 to 2 do // number of shells per barrage
			{
			// Shells will land randomly around target
			if (!isnull _target && _target distance _pos < 200) then
				{
				_pos = position _target;
				};
			_dir = random 360;
			_dist = random 10;
			_posx = (_pos select 0) + (_dist * sin _dir);
			_posy = (_pos select 1) +  (_dist * cos _dir);
			_droppos = [_posx,_posy,0];
			_shell = "Bo_Mk82" createVehicle _droppos;
			[_shell] spawn tpw_skirmish_fnc_expshake;
			sleep random 1;	
			};	
		waitUntil {sleep 2;(_plane distance _target > 2000)};
		deleteVehicle _plane;
		deleteGroup _grp; 
		_cancallsupport = true;	
		tpw_asl_uav_resist = true;
		if (side player == resistance) then
			{
			_hq SideChat format ["All units be advised: UAV support at %1 has concluded and aircraft is R.T.B.",_grid];
			deletemarker "tpwuavmarker";
			};
		};			

	// Artillery
	_fnc_arty =
		{
		private ["_target","_pos","_dir","_dist","_posx","_posy","_droppos","_shell"];
		_cancallsupport = false; 
		tpw_asl_art_resist = false;
		_target = _this select 0;
		_grid = mapGridPosition _target;
		_pos = position _target;
		if (side player == resistance) then
			{		
			_hq SideChat format ["All units be advised: artillery H.E. inbound on co-ordinates %1.",_grid];
			createmarker ["tpwhemarker", position _target] ;
			"tpwhemarker" setmarkertype "hd_objective";
			"tpwhemarker" setMarkerAlpha 0.5;
			"tpwhemarker" setmarkercolor "colorblack";
			"tpwhemarker" setmarkertext "!!HE";
			};
		sleep 30 + random 60;
		for "_i" from 1 to 6 do // number of barrages
			{
			for "_j" from 1 to 4 do // number of shells per barrage
				{
				// Shells will land randomly around target
				if (!isnull _target && _target distance _pos > 200) then
					{
					_pos = position _target;
					};
				_dir = random 360;
				_dist = random 50;
				_posx = (_pos select 0) + (_dist * sin _dir);
				_posy = (_pos select 1) +  (_dist * cos _dir);
				_droppos = [_posx,_posy,500];
				_shell = createVehicle ["Sh_82mm_AMOS",_droppos,[],0,"FLY"]; // Create shell
				_shell say "shell1";
				_shell setVelocity [0,0,-100];
				[_shell] spawn tpw_skirmish_fnc_expshake;				
				sleep random 1;	
				};
			sleep random 10;	
			};	
		_cancallsupport = true;
		tpw_asl_art_resist = true;
		if (side player == resistance) then
			{
			_hq SideChat format ["All units be advised: artillery support at %1 has concluded.",_grid];
			deletemarker "tpwhemarker";
			};
		};
		
	// Smoke
	_fnc_smoke =
		{
		private ["_target","_pos","_dir","_dist","_posx","_posy","_droppos","_shell"];
		_cancallsupport = false;
		tpw_asl_smoke_resist = false;
		_target = _this select 0;
		_grid = mapGridPosition _target;
		_pos = position _target;
		if (side player == resistance) then
			{
			_hq SideChat format ["All units be advised: artillery smoke inbound on co-ordinates %1.",_grid];
			createmarker ["tpwsmkmarker", position _target] ;
			"tpwsmkmarker" setmarkertype "hd_objective";
			"tpwsmkmarker" setMarkerAlpha 0.5;
			"tpwsmkmarker" setmarkercolor "colorblack";
			"tpwsmkmarker" setmarkertext "!!SMK";
			};
		sleep 30 + random 60;
		
		for "_i" from 1 to 4 do
			{
			for "_j" from 1 to 2 do
				{
				if (!isnull _target && _target distance _pos < 200) then
					{
					_pos = position _target;
					};
				_dir = random 360;
				_dist = random 100;
				_posx = (_pos select 0) + (_dist * sin _dir);
				_posy = (_pos select 1) +  (_dist * cos _dir);
				_droppos = [_posx,_posy,500];
				_shell = createVehicle ["SmokeShellOrange",_droppos,[],0,"FLY"]; // Create shell
				_shell say "shell1";
				_shell setVelocity [0,0,-100]; 				
				sleep random 1;	
				};
			sleep random 10;	
			};	
		_cancallsupport = true;
		tpw_asl_smoke_resist = true;
		if (side player == resistance) then
			{
			_hq SideChat format ["All units be advised: artillery smoke support at %1 has concluded.",_grid];
			deletemarker "tpwsmkmarker";
			};
		};		
		
	// Flare
	_fnc_flare =
		{
		private ["_target","_pos","_dir","_dist","_posx","_posy","_droppos","_shell"];
		_cancallsupport = false;
		tpw_asl_flare_resist = false;
		_target = _this select 0;
		_grid = mapGridPosition _target;
		_pos = position _target;
		if (side player == resistance) then
			{
			_hq SideChat format ["All units be advised: artillery flares inbound on co-ordinates %1.",_grid];
			createmarker ["tpwflrmarker", position _target] ;
			"tpwflrmarker" setmarkertype "hd_objective";
			"tpwflrmarker" setMarkerAlpha 0.5;
			"tpwflrmarker" setmarkercolor "colorblack";
			"tpwflrmarker" setmarkertext "!!FLR";
			};
		sleep 30 + random 60;
		for "_i" from 1 to 4 do
			{
			for "_j" from 1 to 4 do
				{
				_dir = random 360;
				_dist = random 100;
				if (!isnull _target && _target distance _pos < 200) then
					{
					_pos = position _target;
					};
				_posx = (_pos select 0) + (_dist * sin _dir);
				_posy = (_pos select 1) +  (_dist * cos _dir);
				_droppos = [_posx,_posy,250];
				_shell = createVehicle ["F_40mm_White",_droppos,[],0,"FLY"]; // Create shell
				// Attach more powerful light to flare shell
				_light = "#lightpoint" createVehiclelocal _droppos;   
				_light setLightColor [200,200,250]; // blueish white
				_light setLightAmbient [.8,.8,1]; 
				_light setlightattenuation [50,4,4,0,1,1000];
				[_light,_shell] spawn
					{
					_light = _this select 0;
					_shell = _this select 1;
					sleep random 2;
					waituntil 
						{
						sleep random 2;
						_light setlightintensity  200 + random 400;
						(position _shell) select 2 < 150;
						};
					deletevehicle _light;
					};
				_shell setVelocity [random 10,random 10 ,random 10]; 
				sleep random 5;	
				};
			sleep random 30;	
			};	
		_cancallsupport = true;
		tpw_asl_flare_resist = true;	
		if (side player == resistance) then
			{
			_hq SideChat format ["All units be advised: artillery flare support at %1 has concluded.",_grid];
			deletemarker "tpwflrmarker";
			};
		};	
		
	// Determine which assets are available, pick a random one	
	_fnc_assets =
		{
		_assets = [];
		if (_cas && tpw_asl_cas_resist) then 
			{
			_assets pushback _fnc_casplane;
			};
		if (_cas && tpw_asl_chs_resist) then 
			{
			_assets pushback _fnc_casheli;
			};	
		if (_cas && tpw_asl_uav_resist) then 
			{
			_assets pushback _fnc_casuav;
			};			
		if (_art && tpw_asl_art_resist) then
			{
			_assets pushback _fnc_arty;
			};
		if (_art && tpw_asl_smoke_resist) then
			{
			_assets pushback _fnc_smoke;
			};		
		if (_art && tpw_asl_flare_resist && {tpw_core_sunangle < 0}) then
			{
			_assets pushback _fnc_flare;
			};	
		if (count _assets > 0) then 
			{	
			_asset = _assets select (floor (random (count _assets)));	
			_sql doWatch _target;
			[_target] call _asset;	
			};
		};
		
	// Select potential targets near squad leader
	_fnc_target =
		{	
		private _leaders = [];
			{
			_leaders pushback leader _x;
			} foreach (tpw_skirmish_friendlysquads + tpw_skirmish_resistsquads + tpw_skirmish_enemysquads + tpw_skirmish_friendlyvehicles + tpw_skirmish_resistvehicles + tpw_skirmish_enemyvehicles);

		private _eleaders = ((_leaders select {_x distance _sql> 200 && _x distance _sql < 1500}) select {(side _x) getFriend (side _sql) < 0.5}) select {[objNull, "VIEW"] checkVisibility [eyePos _x, eyepos _sql] > 0}; // all visible enemy leaders > 200m away

		private _fleaders = _leaders select {(side _x) getFriend (side _sql) > 0.5}; // all friendly leaders
		
		private _safetargets = []; // enemy leaders with no nearby friendly within 200m
			{
			_leader = _x;
			if (count (_fleaders select {_x distance _leader < 200}) == 0) then
				{
				_safetargets pushback _leader;
				};
			} foreach _eleaders;
			
		if (count _safetargets > 0) then
			{
			_target = _safetargets select floor random count _safetargets;
			_targetset = true;
			} else
			{
			_targetset = false;
			};		
		};	
		
	// Squad leader periodically scans for targets (only if in combat/stealth mode)
	while {count (units _group) > 0} do
		{
		_sql = leader _group; 
		if (_cancallsupport) then
			{
			[] call _fnc_target;
			
			// If target has been chosen
			if (_targetset) then 
				{
				[] call _fnc_assets;//Call in support
				};
			};
		sleep random _scantime;
		};	
	};

// SELECT UNITS FROM UNIT POOL
tpw_skirmish_fnc_types =
	{
	private ["_str","_cfg","_side"];
	// Pseudo pattern matching
	_str = (_this select 0) splitstring "*";
	if (count _str == 1) then {_str = _str + _str};
	_side = _this select 1;
	_unitlist = [];
	_unitlist = tpw_skirmish_unitpool select {[_str select 0,str _x] call BIS_fnc_inString && {[_str select 1,str _x] call BIS_fnc_inString} && {!(["civ",str _x] call BIS_fnc_inString)}};	
	
	// Default to NATO/CSAT/AAF if no units found	
	if (count _unitlist == 0) then
		{
		switch _side do
			{
			case EAST:
				{
				["o_soldier"] call tpw_skirmish_fnc_types;
				};
			case WEST:		
				{
				["b_soldier"] call tpw_skirmish_fnc_types;
				};
			case RESISTANCE:	
				{
				["i_soldier"] call tpw_skirmish_fnc_types;
				};
			};
		};
	_unitlist	
	};

// GET VEHICLES FROM CONFIG
tpw_skirmish_fnc_cartypes =
	{
	private ["_str","_side"];
	_str = (_this select 0) splitstring "*";
	if (count _str == 1) then {_str = _str + _str};
	_side = _this select 1;
	_carlist = [];
	_carlist = tpw_skirmish_carpool select {[_str select 0,str _x] call BIS_fnc_inString && {[_str select 1,str _x] call BIS_fnc_inString} && {!(["civ",str _x] call BIS_fnc_inString)}};

	// Default to NATO/CSAT/AAF if no vehicles found	
	if (count _carlist == 0) then
		{
		switch _side do
			{
			case EAST:
				{
				["o_mrap"] call tpw_skirmish_fnc_cartypes;
				};
			case WEST:		
				{
				["b_mrap"] call tpw_skirmish_fnc_cartypes;
				};
			case RESISTANCE:	
				{
				["i_mrap"] call tpw_skirmish_fnc_cartypes;
				};
			};
		};	
	_carlist
	};	

// RANDOM POSITION
tpw_skirmish_fnc_randomspawnpos = 
	{
	private _pos = getposasl player;
	private _spawnpos = getposasl player;

	// Road
	private _roads = _pos nearroads tpw_skirmish_maxspawnradius;
	private _nearroads = _roads select {_x distance _pos > tpw_skirmish_minspawnradius};
	if (count _nearroads > 50 && random 1 < 0.75) then
		{
		waituntil
			{
			sleep 0.1;
			_road = selectrandom _nearroads;
			_spawnpos = getposasl _road;
			_spawnpos distance player > tpw_skirmish_minspawnradius
			};
		}	else
	// Random flat area	
		{
		waituntil
			{
			sleep 0.1;
			private _dir = random 360;
			private _dist = tpw_skirmish_minspawnradius + random (tpw_skirmish_maxspawnradius - tpw_skirmish_minspawnradius);
			private _posx = (_pos select 0) + (_dist * sin _dir);
			private _posy = (_pos select 1) +  (_dist * cos _dir);
			_spawnpos = [_posx,_posy,0];
			!(surfaceiswater _spawnpos) && {_posx > 0 && _posy > 0 && _posx < worldsize && _posy < worldsize} && {!([_posx,_posy] isFlatEmpty  [-1, -1, 0.4, 1, -1] isEqualTo []) || isonroad _spawnpos} 
			};			
		};
	_spawnpos	
	};	
	
// HOUSES FOR INFANTRY SPAWNING
tpw_skirmish_fnc_houses =
	{
	private ["_houses"];
	if (player distance tpw_skirmish_lasthousepos > (tpw_skirmish_minspawnradius / 2))then 
		{
		tpw_skirmish_lasthousepos = position player;
		_houses = [tpw_skirmish_minspawnradius] call tpw_core_fnc_screenhouses;
		tpw_skirmish_houses = _houses select {_x distance player > (tpw_skirmish_minspawnradius / 2)};		
		};
	};

// ROADS FOR VEHICLE SPAWNING
tpw_skirmish_fnc_roads =
	{
	if (player distance tpw_skirmish_lastroadpos > (tpw_skirmish_maxspawnradius / 2)) then 
		{
		tpw_skirmish_lastroadpos = position player;
		tpw_skirmish_roads = (player nearroads tpw_skirmish_maxspawnradius) select {isonroad _x && {_x distance player > tpw_skirmish_minspawnradius}};
		};
	};

//SPAWN INFANTRY
tpw_skirmish_squadspawn = 
	{
	private ["_side","_units","_num","_spawnpos","_max","_unit","_house","_spawnpos","_sqname","_leader","_shemag","_formations","_form"];
	_side = _this select 0;
	_units = _this select 1;
	_num = _this select 2;
	
	// Spawn position in nearby houses or otherwise a random location 
	[] call tpw_skirmish_fnc_houses;
	_spawnpos = [] call tpw_skirmish_fnc_randomspawnpos; 
	
	
	// Pick random members for squad	
	_sqname = creategroup [_side,true];
	_max = 2 + floor random 5;
	for "_i" from 0 to _max do 
		{
		_unit = _units select (floor (random (count _units)));
		_unit = _unit createUnit [_spawnpos,_sqname,"this enablesimulation false;this setvariable ['tpw_skirmish',1];this setskill 0.05 + random 0.15;this setAnimSpeedCoef 0.8 + random 0.2; this removeweapon 'binocular';this removeweapon 'rangefinder'"];	
		sleep random 1;
		};
		
		
	// Civilian clothes
	if ((abs(_num) - floor(abs(_num))) > 0) then
		{
		tpw_civ_clothes = [] call tpw_core_fnc_clothes;
			{
			removeuniform _x;
			_x forceadduniform (tpw_civ_clothes select  (floor random count tpw_civ_clothes));
			if (headgear _x in tpw_skirmish_shemaglist) then
				{
				removeheadgear _x;
				};
			_x addItem "Firstaidkit";	
			} foreach units _sqname;		
		};		

	// Shemaghs	
	if (_num < 0 || str _num == "-0") then
		{
			{
			_shemag = tpw_skirmish_shemaglist select (floor (random (count tpw_skirmish_shemaglist)));
			_x linkItem "NVGoggles";
			_x unlinkItem "NVGoggles";
			_x addheadgear _shemag;	
			_x addgoggles selectrandom [
				"G_Spectacles",
				"G_Spectacles_Tinted",
				"G_Shades_Black",
				"G_Shades_Green",
				"G_Shades_Red",
				"G_Squares",
				"G_Squares_Tinted",
				"G_Sport_BlackWhite",
				"G_Sport_Blackyellow",
				"G_Sport_Greenblack",
				"G_Sport_Checkered",
				"G_Sport_Red",
				"G_Aviator"
				];
			} foreach units _sqname;
		};
	
	// Believable behaviours	
		{
		_x setvariable ["tpw_side",_side];
		_x setvariable ["tpw_squad",_sqname];
		_x addeventhandler ["firednear",{(_this select 0) setbehaviour "combat"}];
		[_x] spawn tpw_skirmish_fnc_relax;
		[_x] spawn tpw_skirmish_fnc_lower;
		[_x] spawn tpw_skirmish_fnc_heal;
		_x domove ((getposasl _x) vectoradd[random 10,random 10,0]); // Give them initial kick!
		} foreach units _sqname;	
	
	// Initial speed and position	
	_leader = leader _sqname;
	_leader move ([] call tpw_skirmish_fnc_randomspawnpos);
	_leader setbehaviour "CARELESS";
	_sqname setSpeedMode "LIMITED";
	
	
	// Killed units can be revived
	{
	_x addeventhandler ["killed",{
		_unit = _this select 0;
		_unit setvariable ["tpw_loadout", getunitloadout _unit];
		_unit setvariable ["tpw_killed", 1];
		_unit addaction [format ["<t color='#aa6600'>Revive %1</t>",_unit],{_this spawn tpw_skirmish_fnc_revive}, nil, 0, false];
		//[_unit] spawn tpw_skirmish_fnc_dead;
		}];
	} foreach units _sqname;
	
	// Side specific behaviours
	switch _side do
		{
		case WEST:
			{
			if (tpw_skirmish_support == 1 && {_num in [0,1,2,3,-1,-2,-3]}) then 
				{
				0 = [_leader, true, true] spawn tpw_skirmish_fnc_asl;
				};
			
			// Add WEST killed eventhandlers
				{
				_x addeventhandler ["killed",
					{
					(_this select 0) setvariable ["tpw_skirmish_removedead",diag_ticktime + tpw_skirmish_deadtime];
					private ["_squad","_leader","_call"];
					if (tpw_skirmish_friendlywpflag) then
						{
						_squad = group (_this select 0);
						if (count units _squad > 0) then
							{
							_call = tpw_skirmish_report select (floor (random (count tpw_skirmish_report)));
							_leader = leader _squad;
							_leader sidechat format ["%1 %2",_call,mapgridposition _leader];
							};
						};
					}]; // other squads will move towards this killed unit
				sleep 0.2;
				_x enablesimulation true;
				} foreach units _sqname;

			// Add to friendly squad array	
			tpw_skirmish_friendlysquads pushback _sqname;			
			};
			
		case EAST:	
			{
			if (tpw_skirmish_enemy_support == 1 && {_num in [0,4,5,-4,-5]}) then
				{
				0 = [_leader, true, true] spawn tpw_skirmish_fnc_asl;
				};
				// Add EAST killed eventhandler
				{
				_x addeventhandler ["killed",
					{
					(_this select 0) setvariable ["tpw_skirmish_removedead",diag_ticktime + tpw_skirmish_deadtime];
					private ["_squad","_leader","_call"];
					if (tpw_skirmish_enemywpflag) then
						{
						_squad = group (_this select 0);
						if (count units _squad > 0) then
							{
							_call = tpw_skirmish_report select (floor (random (count tpw_skirmish_report)));
							_leader = leader _squad;
							_leader sidechat format ["%1 %2",_call,mapgridposition _leader];
							};
						};
					}];
				_x enablesimulation true;
				} foreach units _sqname;
				
			//Add to enemy squad array	
			tpw_skirmish_enemysquads pushback _sqname;
			};
			
		case RESISTANCE:
			{
			if (tpw_skirmish_resist_support == 1 && {_num in [0,6,-6]}) then
				{
				0 = [_leader, true, true] spawn tpw_skirmish_resist_fnc_asl;
				};
				// Add RESISTANCE killed eventhandler
				{
				_x addeventhandler ["killed",
					{
					(_this select 0) setvariable ["tpw_skirmish_removedead",diag_ticktime + tpw_skirmish_deadtime];
					private ["_squad","_leader","_call"];
					if (tpw_skirmish_resistwpflag) then
						{
						_squad = group (_this select 0);
						if (count units _squad > 0) then
							{
							_call = tpw_skirmish_report select (floor (random (count tpw_skirmish_report)));
							_leader = leader _squad;
							_leader sidechat format ["%1 %2",_call,mapgridposition _leader];
							};
						};
					}];
				_x enablesimulation true;
				} foreach units _sqname;

				//Add to resistance squad array	
				tpw_skirmish_resistsquads pushback _sqname;
			};
		};
	};
	
//SPAWN VEHICLES
tpw_skirmish_vehspawn = 
	{
	private ["_side","_units","_cars","_spawnpos","_unit","_roadlist","_farroads","_road","_spawncar","_car","_leader","_wppos","_wp","_shemag","_uniform","_crewcount"];
	_side = _this select 0;
	_units = _this select 1;	
	_cars = _this select 2;	
	_num = _this select 3;
	
	// Spawn position - on road if available
	[] call tpw_skirmish_fnc_roads;
	if (count tpw_skirmish_roads > 50) then
		{
		waituntil
			{
			sleep 0.2;
			_spawnpos = position (tpw_skirmish_roads select floor (random (count tpw_skirmish_roads)));
			_spawnpos distance player > tpw_skirmish_minspawnradius;
			};
		} else
		{
		_spawnpos = [] call tpw_skirmish_fnc_randomspawnpos;
		};
	
	// Spawn car	
	_sqname = creategroup [_side,true];
	_car = _cars select (floor (random (count _cars)));
	_spawncar = _car createVehicle _spawnpos;
	_spawncar setvariable ["tpw_veh",1];
	[_spawncar] joinsilent _sqname;	
	_crewcount = [_car,true] call BIS_fnc_crewCount;

	// Pick random crew for vehicle	
	for "_i" from 1 to (2 + floor (random (_crewcount - 1))) do 
		{
		_unit = _units select (floor (random (count _units)));
		_unit createUnit [_spawnpos,_sqname];
		sleep random 1;
		};
		{
		_x setvariable ["tpw_skirmish",2];	
		// Shemaghs	
		if (_num < 0) then
			{
			_shemag = tpw_skirmish_shemaglist select (floor (random (count tpw_skirmish_shemaglist)));
			_x linkItem "NVGoggles";
			_x unlinkItem "NVGoggles";
			_x addheadgear _shemag;
			};
		_x moveinany _spawncar;
		_x setAnimSpeedCoef 0.8 + random 0.2;
		_x addeventhandler ["killed",{(_this select 0) setvariable ["tpw_skirmish_removedead",diag_ticktime + tpw_skirmish_deadtime];}];// delete dead units after 5 min	
		_x setskill 0.05 + random 0.15;
		} foreach units _sqname;	
	
	// Add patrol waypoints to car. New ones will be calculated every minute or so, to prevent cars loitering around waypoint	
	[_spawncar] call tpw_skirmish_fnc_waypoint;

	(driver _spawncar) disableAI 'FSM';	

	// Add to the vehicle array	
		switch _side do
		{
		case EAST: 
			{
			tpw_skirmish_enemyvehicles pushback _spawncar;
			};
		case WEST: 
			{
			tpw_skirmish_friendlyvehicles pushback _spawncar;
			};
		case RESISTANCE: 
			{
			tpw_skirmish_resistvehicles pushback _spawncar;
			};
		};	

	// Timer for stuck vehicle - vehicle will be removed if still for more than 60 sec	
	_spawncar setvariable ["tpw_skirmish_stucktime", diag_ticktime + 60]; 
	};
	
// ADD SINGLE WAYPOINT
tpw_skirmish_fnc_waypoint =
	{
	private ["_car","_group","_wp","_wppos"];
	_car = _this select 0;
	_group  = group _car;
	[] call tpw_skirmish_fnc_roads;
	tpw_skirmish_roads = tpw_skirmish_roads select {_x distance player > tpw_skirmish_minspawnradius};
	if (count tpw_skirmish_roads > 50) then
		{
		_wppos = getposasl (tpw_skirmish_roads select floor (random (count tpw_skirmish_roads)));
		} else
		{
		_wppos = [] call tpw_skirmish_fnc_randomspawnpos;
		};
		
	// Delete existing waypoints
	while {(count (waypoints _group)) > 0} do 
		{ 
		deleteWaypoint ((waypoints _group) select 0); 
		};
	
	// Add waypoint
	[_group, _wppos, 5, 1, "SAD", "AWARE", "YELLOW", "NORMAL", "STAG COLUMN", "", [0,0,0]] call CBA_fnc_taskPatrol;
	
	// Timer til next waypoint created
	_car setvariable ["tpw_skirmish_wptime",(diag_ticktime + random 60)];	
	};	

// NO UNARMED, PILOT, VR, DIVERS, SURVIVORS, ZEUS CURATOR, OR ZOMBIES
tpw_skirmish_fnc_noncom =
	{
	private ["_list","_i","_unit"];
	_list = _this select 0;
	for "_i" from 0 to (count _list - 1) do	
		{	
		_unit = _list select _i;
		if ((["unarmed",str _unit] call BIS_fnc_inString) ||(["pilot",str _unit] call BIS_fnc_inString)||(["diver",str _unit] call BIS_fnc_inString)||(["vr",str _unit] call BIS_fnc_inString)||(["survivor",str _unit] call BIS_fnc_inString)||(["zomb",str _unit] call BIS_fnc_inString)||(["curator",str _unit] call BIS_fnc_inString)) then
			{
			_list set [_i, -1];
			};
		};
	_list = _list - [-1];	
	_list;
	};
	
// REMOVE SQUADS AS APPROPRIATE
tpw_skirmish_fnc_squadremove =
	{
	private ["_squads","_squad","_ct","_i"];
	_squads = _this select 0;
	_squads = _squads - [-1];
	for "_ct" from 0 to (count _squads - 1) do	
		{	
		_squad = _squads select _ct;
		if ((leader _squad) distance player > tpw_skirmish_maxspawnradius) then
			{
				{
				deletevehicle _x;
				sleep 0.1;
				} foreach units _squad;
			deletegroup _squad;	
			_squads set [_ct,-1];
			};
					
			// Delete stuck units
			{
			private _unit = _x;
			if (position _unit distance (_unit getvariable "lastpos") > 0.5) then
				{
				_unit setvariable ["tpw_skirmish_stucktime",diag_ticktime + 89];
				};
			if (diag_ticktime > _unit getvariable "tpw_skirmish_stucktime") then
				{
				if (animationstate _unit != "acts_InjuredLyingRifle02_180") then
					{
					// Unfreeze and kill any inappropriately frozen units
					{_unit enableai _x} count ["anim","move","fsm","target","autotarget"];
					_unit setunconscious false;
					[_unit] spawn
						{
						_unit = _this select 0;
						waituntil
							{
							sleep 1;
							lineintersects [eyepos _unit,eyePos player]
							};
						deletevehicle _unit;	
						};
					};
				// Delete if distant	
				if (_unit distance player > tpw_skirmish_minspawnradius) then
					{
					deletevehicle _unit;
					};	
				};
				
			// Running if not in combat
			if (!(behaviour _unit == "combat") && {speed _unit > 11}) then
				{
				_unit forcewalk true;
				};
				
			// Slow down exhausted units
			if (getstamina _unit < 12) then
				{
				_unit forcewalk true;
				};				
				
			_unit setvariable ["lastpos",position _unit];	
			} foreach units _squad select {alive _x};		
			
		private _alive = (units _squad) select {alive _x}; 
		if (count _alive == 0) then
			{
			deletegroup _squad;
			_squads set [_ct,-1];
			};	
		};
	_squads = _squads - [-1];
	_squads
	};

// CONSOLIDATE SQUADS AS APPROPRIATE
tpw_skirmish_fnc_consolidate =
	{
	private ["_singletons","_squads","_squad","_unit"];
	_squads = _this select 0;
	_squads = _squads select {count (units _x) > 0};
	if (count _squads < 2 && {count (units (_squads select 0)) < 2}) exitwith 
		{
			{
			deletevehicle _x;
			sleep 0.1;
			} foreach units (_squads select 0);
		};
	_singletons = _squads select {count (units _x) == 1};
	_squads = _squads - _singletons;
	if (count _squads > 0) then
		{
			{
			_squad = _squads select 0;
			_unit = (units _x) select 0;
			[_unit] joinsilent _squad;
			_unit sidechat format ["Joining up with %1",_squad];
			} foreach _singletons;
		};
	_squads
	};

// MOVE AND REMOVE VEHICLES AS APPROPRIATE
tpw_skirmish_fnc_vehicleremove =
	{
	private ["_vehicles","_car","_ct","_group","_i","_wp","_stopflag"];
	_vehicles = _this select 0;
	for "_ct" from 0 to (count _vehicles - 1) do	
		{	
		_car = _vehicles select _ct;
		_group = group driver _car;
		
		if (isnull _car) exitwith {_vehicles set [_ct,-1]};
		
		// Give car a new waypoint if enough time has passed
		if (diag_ticktime > _car getvariable "tpw_skirmish_wptime") then
			{
			[_car] spawn tpw_skirmish_fnc_waypoint;
			};

		// Stop car if any of its crew are distant, so they can get back in
		_stopflag = 0;
			{
			if (_x distance _car > 5) then
				{
				_x domove position _car;
				_stopflag = 1;
				};
			} foreach units _group;
		
		if (_stopflag == 1) then
			{
			dostop driver _car;
			} else
			{
			driver _car setspeedmode "NORMAL";	
			driver _car domove waypointPosition [_group,1];
			};
		
		// Stuck or incapacitated car? 
		if (abs(speed _car) > 5) then
			{
			_car setvariable ["tpw_skirmish_stucktime", diag_ticktime + 120]; 
			};	
			
		if (diag_ticktime > _car getvariable "tpw_skirmish_stucktime" || // car has been still for > 2 min
		_car distance player > tpw_skirmish_maxspawnradius || // car too distant
		!(alive driver _car) || // no-one around to drive it
		!(alive _car) // car is fucked
		) then 
			{
			// Mark car for deletion
			tpw_skirmish_deletearray pushback _car;
			deletegroup group _car;
			_vehicles set [_ct,-1];
			};			
		};
	_vehicles = _vehicles - [-1];
	_vehicles
	};

// MAKE INFANTRY MOVE TOWARDS ENEMIES
tpw_skirmish_fnc_moveto = 
	{
	while {true} do
		{
		sleep tpw_skirmish_spawntime;
		
		// Squad leaders
		private _leaders = [];
			{
			_leaders pushback leader _x;
			} foreach (tpw_skirmish_friendlysquads + tpw_skirmish_resistsquads + tpw_skirmish_enemysquads + [group player]);
		
		// Only footbound
		_leaders = _leaders select {_x == vehicle _x};
		private _otherleaders = _leaders select {true};
		_otherleaders deleteat (_leaders find (leader (group player))); // doesn't include leader of player squad
		
			
			{
			// Nearest enemies to each squad
			private _leader = _x;
			private _enemies = (_leaders select {side _x getfriend side _leader < 0.6}) apply {[_x distance _leader, _x]}; 
			_enemies sort true;
			private _closest = (_enemies select 0) select 1;
			
			// Default behaviour
			_leader setbehaviour "SAFE";	
			_leader setbehaviourstrong "SAFE";
			_leader setCombatBehaviour "SAFE";
			_leader setSpeedMode "LIMITED";
			_leader setCombatMode "YELLOW";
			_leader setunitpos "UP";
			
			// Aware if battle
			if (tpw_core_battle) then
				{
				_leader setbehaviour "AWARE";	
				_leader setbehaviourstrong "AWARE";
				_leader setCombatBehaviour "AWARE";
				_leader setCombatMode "YELLOW";
				};			

			// Move squad	
			_movepos = (getposasl _leader) vectoradd [random 10, random 10,0];
			if (count _enemies > 0) then
				{	
				// Aware if nearby  enemies 
				if (_leader distance _closest < tpw_skirmish_minspawnradius/2) then
					{
					_leader setbehaviourstrong "AWARE";
					_leader setbehaviour "AWARE";
					_leader setCombatBehaviour "AWARE";
					_leader setCombatMode "YELLOW";
					};
				
				// Combat mode if they have line of sight or really close
				_eyepa = eyepos _leader; 
				_eyepb = eyepos _closest; 
				_tint = terrainintersectasl [_eyepa, _eyepb]; 
				_lint = lineintersects [_eyepa, _eyepb]; 				
				if ((!_lint && !_tint && {_leader distance _closest < tpw_skirmish_minspawnradius*2}) || _leader distance _closest < 25) then
					{
					_leader setbehaviour "COMBAT";
					_leader setbehaviourstrong "COMBAT";
					_leader setCombatBehaviour "COMBAT";
					_leader setcombatmode "RED";
						{
						_x forcewalk false
						} foreach units (group _leader);
					};
			
				// Move towards nearest enemies
				_movepos = getposasl _closest;
				} else
				{
				// move randomly
				_movepos = call tpw_skirmish_fnc_randomspawnpos;
				};
			_leader move _movepos;
			[group _leader,0] setwaypointposition[_movepos,0]; 
			[group _leader,0] setwaypointspeed "limited"; 
			[group _leader,0] setwaypointtype "move"; 
				
	
			// Periodically stop if not in the open
			if (random 1 > 0.75 && {!(nearestTerrainObjects [_leader, ["tree","small tree","house","building"], 20, false] isequalto [])}) then 
				{[_leader] spawn
					{
					_unit = _this select 0;
					_unit stop true; sleep 0.1; _unit stop true;
					sleep random tpw_skirmish_spawntime/2;
					_unit stop false; sleep 0.1; _unit stop false
					};
				};
			} foreach _otherleaders;
		};		
	};
	
// MAIN FRIENDLY LOOP
tpw_skirmish_allgroups = [];	
tpw_skirmish_fnc_friendlyloop =	
	{
	private ["_rnd","_friendlyunitlist","_friendlycarlist","_num","_friendlysquads","_friendlyvehicles","_car"];
	tpw_skirmish_friendlysquads = [];	
	tpw_skirmish_friendlyvehicles = [];
	while {true} do
		{
		if (tpw_skirmish_active && {speed vehicle player < 50}) then
			{
			// Spawn new squads
			if (count tpw_skirmish_friendlysquads < tpw_skirmish_friendlysquad_max) then
				{
				_rnd = tpw_skirmish_friendlytype select floor random count tpw_skirmish_friendlytype;
				_friendlyunitarray = tpw_skirmish_friendlyunitarray select abs _rnd; 
				_friendlyunitlist = _friendlyunitarray select floor random count _friendlyunitarray;
				[WEST,_friendlyunitlist,_rnd] call tpw_skirmish_squadspawn;
				};
			
			// Spawn new vehicles
			if (count tpw_skirmish_friendlyvehicles < tpw_skirmish_friendlyvehicles_max) then
				{
				_rnd = tpw_skirmish_friendlytype select floor random count tpw_skirmish_friendlytype;
				_friendlyunitarray = tpw_skirmish_friendlyunitarray select (abs _rnd); 
				_friendlyunitlist = _friendlyunitarray select floor random count _friendlyunitarray;
				_friendlycararray = tpw_skirmish_friendlyvehiclearray select (abs _rnd);
				_friendlycarlist = _friendlycararray select floor random count _friendlycararray;
				[WEST,_friendlyunitlist,_friendlycarlist,_rnd] call tpw_skirmish_vehspawn;
				};	
			sleep 5;
			
			// Delete distant squads
			_friendlysquads = [];
			_friendlysquads = [tpw_skirmish_friendlysquads] call tpw_skirmish_fnc_squadremove;
			tpw_skirmish_friendlysquads = _friendlysquads;

			// Any squads with only one member - consolidate with nearest squad from same side 
			tpw_skirmish_friendlysquads = [tpw_skirmish_friendlysquads] call tpw_skirmish_fnc_consolidate;
			tpw_skirmish_friendlysquads = _friendlysquads;

			// Flag distant or incapacitated vehicles
			_friendlyvehicles = [];
			_friendlyvehicles = [tpw_skirmish_friendlyvehicles] call tpw_skirmish_fnc_vehicleremove;
			tpw_skirmish_friendlyvehicles = _friendlyvehicles;
			};
		sleep random tpw_skirmish_spawntime;
		};
	};
	
// MAIN ENEMY LOOP	
tpw_skirmish_fnc_enemyloop =	
	{
	private ["_rnd","_enemyunitlist","_enemycarlist","_num","_enemysquads","_enemyvehicles"];
	tpw_skirmish_enemysquads = [];	
	tpw_skirmish_enemyvehicles = [];
	while {true} do
		{
		if (tpw_skirmish_active && {speed vehicle player < 50}) then
			{
		
			// Spawn new squads
			if (count tpw_skirmish_enemysquads < tpw_skirmish_enemysquad_max) then
				{
				_rnd = tpw_skirmish_enemytype select floor random count tpw_skirmish_enemytype;
				_enemyunitarray = tpw_skirmish_enemyunitarray select (abs _rnd); 
				_enemyunitlist = _enemyunitarray select floor random count _enemyunitarray;
				[EAST,_enemyunitlist,_rnd] call tpw_skirmish_squadspawn;
				};
			
			// Spawn new vehicles
			if (count tpw_skirmish_enemyvehicles < tpw_skirmish_enemyvehicles_max) then
				{
				_rnd = tpw_skirmish_enemytype select floor random count tpw_skirmish_enemytype;
				_enemyunitarray = tpw_skirmish_enemyunitarray select (abs _rnd); 
				_enemyunitlist = _enemyunitarray select floor random count _enemyunitarray;
				_enemycararray = tpw_skirmish_enemyvehiclearray select (abs _rnd);
				_enemycarlist = _enemycararray select floor random count _enemycararray;
				[EAST,_enemyunitlist,_enemycarlist,_rnd] call tpw_skirmish_vehspawn;
				};		
			sleep 5;
			// Delete distant squads
			_enemysquads = [];
			_enemysquads = [tpw_skirmish_enemysquads] call tpw_skirmish_fnc_squadremove;
			tpw_skirmish_enemysquads = _enemysquads;

			// Any squads with only one member - consolidate with nearest squad from same side 
			tpw_skirmish_enemysquads = [tpw_skirmish_enemysquads] call tpw_skirmish_fnc_consolidate;
			tpw_skirmish_enemysquads = _enemysquads;

			//Delete distant or incapacitated vehicles
			_enemyvehicles = [];
			_enemyvehicles = [tpw_skirmish_enemyvehicles] call tpw_skirmish_fnc_vehicleremove;
			tpw_skirmish_enemyvehicles = _enemyvehicles;
			};
		sleep random tpw_skirmish_spawntime;
		};
	};	
	
// MAIN RESISTANCE LOOP	
tpw_skirmish_fnc_resistloop =	
	{
	private ["_rnd","_resistunitlist","_resistcarlist","_num","_resistsquads","_resistvehicles"];
	tpw_skirmish_resistsquads = [];	
	tpw_skirmish_resistvehicles = [];
	while {true} do
		{
		if (tpw_skirmish_active && {speed vehicle player < 50}) then
			{
			// Spawn new squads
			if (count tpw_skirmish_resistsquads < tpw_skirmish_resistsquad_max) then
				{
				_rnd = tpw_skirmish_resisttype select floor random count tpw_skirmish_resisttype;
				_resistunitarray = tpw_skirmish_resistunitarray select (abs _rnd); 
				_resistunitlist = _resistunitarray select floor random count _resistunitarray;
				[RESISTANCE,_resistunitlist,_rnd] call tpw_skirmish_squadspawn;
				};
			
			// Spawn new vehicles
			if (count tpw_skirmish_resistvehicles < tpw_skirmish_resistvehicles_max) then
				{
				_rnd = tpw_skirmish_resisttype select floor random count tpw_skirmish_resisttype;
				_resistunitarray = tpw_skirmish_resistunitarray select (abs _rnd); 
				_resistunitlist = _resistunitarray select floor random count _resistunitarray;
				_resistcararray = tpw_skirmish_resistvehiclearray select (abs _rnd);
				_resistcarlist = _resistcararray select floor random count _resistcararray;
				[RESISTANCE,_resistunitlist,_resistcarlist,_rnd] call tpw_skirmish_vehspawn;
				};	
			sleep 5;
			// Delete distant squads
			_resistsquads = [];
			_resistsquads = [tpw_skirmish_resistsquads] call tpw_skirmish_fnc_squadremove;
			tpw_skirmish_resistsquads = _resistsquads;

			// Any squads with only one member - consolidate with nearest squad from same side 
			tpw_skirmish_resistsquads = [tpw_skirmish_resistsquads] call tpw_skirmish_fnc_consolidate;
			tpw_skirmish_resistsquads = _resistsquads;

			//Delete distant or incapacitated vehicles
			_resistvehicles = [];
			_resistvehicles = [tpw_skirmish_resistvehicles] call tpw_skirmish_fnc_vehicleremove;
			tpw_skirmish_resistvehicles = _resistvehicles;
			};
		sleep random tpw_skirmish_spawntime;
		};
	};	
	
// CLEAN UP 
tpw_skirmish_fnc_cleanup =
	{
	while {true} do
		{
		// Clean up any stragglers (passengers out of vehicles for more than 60 sec)
			{
			if (_x getvariable ["tpw_skirmish",0] == 2 && {_x == vehicle _x} && {_x distance player > tpw_skirmish_minspawnradius}) then
				{
				if (_x getvariable ["tpw_skirmish_deletetime",-1] == -1) then
					{
					_x setvariable ["tpw_skirmish_deletetime",diag_ticktime + 60];
					} else
					{
					if (_x getvariable "tpw_skirmish_deletetime" < diag_ticktime) then
						{
						deletevehicle _x;
						sleep 0.1;
						};
					};
				};
			} foreach allunits;
		
		// Delete dead bodies after 5 min
			{
			if (_x getvariable "tpw_skirmish_removedead" < diag_ticktime && {[objNull, "VIEW"] checkVisibility [eyePos _x, eyepos player] == 0}) then
				{
				deletevehicle _x;
				sleep 0.1;
				};
			} count alldead;
		
		// Delete flagged vehicles
		for "_i" from 0 to count tpw_skirmish_deletearray - 1 do
			{
			_car = tpw_skirmish_deletearray select _i;
			if (_car distance player > tpw_skirmish_minspawnradius) then
				{
					{
					deletevehicle _x;
					sleep 0.1;
					} foreach units group _car;
				deletevehicle _car;
				tpw_skirmish_deletearray set [_i,-1];
				};
			};
		tpw_skirmish_deletearray = 	tpw_skirmish_deletearray - [-1];
		sleep 30;

		// 	Orphaned units
		_blufor = allunits select {_x getvariable "tpw_side" == WEST};
			{
			if !(group _x in tpw_skirmish_friendlysquads) then
				{
				tpw_skirmish_friendlysquads pushback group _x;
				};
			} foreach _blufor;
		_opfor = allunits select {_x getvariable "tpw_side" == EAST};
			{
			if !(group _x in tpw_skirmish_enemysquads) then
				{
				tpw_skirmish_enemysquads pushback group _x;
				};
			} foreach _opfor;
		_indfor = allunits select {_x getvariable "tpw_side" == RESISTANCE};
			{
			if !(group _x in tpw_skirmish_resistsquads) then
				{
				tpw_skirmish_resistsquads pushback group _x;
				};
			} foreach _indfor;			
		};
	};

// PRESCAN CONFIG FOR POTENTIAL UNITS AND CARS - Thanks to Larrow for the code idea
tpw_skirmish_unitpool = [];
_cfg = (configFile >> "CfgVehicles");
for "_i" from 0 to ((count _cfg) -1) do 
	{
	if (isClass ((_cfg select _i) ) ) then 
		{
		_cfgName = configName (_cfg select _i);
		if ((_cfgName isKindOf "camanbase") && {getNumber ((_cfg select _i) >> "scope") == 2}) then 
			{
			tpw_skirmish_unitpool pushback _cfgname;
			};
		};
	};	
		
tpw_skirmish_carpool = [];
_cfg = (configFile >> "CfgVehicles");
for "_i" from 0 to ((count _cfg) -1) do 
	{
	if (isClass ((_cfg select _i) ) ) then 
		{
		_cfgName = configName (_cfg select _i);
		if (((_cfgName isKindOf "car") || (_cfgName isKindOf "tank"))&& {getNumber ((_cfg select _i) >> "scope") == 2}) then 
			{
			tpw_skirmish_carpool  pushback _cfgname;
			};
		};
	};		

// BLUFOR
private ["_unitstrings","_carstrings"];
if !(tpw_skirmish_friendlyunitstring isequalto []) then 
	{
	_unitstrings = tpw_skirmish_friendlyunitstring; 
	} else
	{
	_unitstrings = ["b_soldier"];
	};
	
if !(tpw_skirmish_friendlyvehiclestring isequalto []) then
	{
	_carstrings = tpw_skirmish_friendlyvehiclestring; 
	} else
	{
	_carstrings = ["b_mrap"];
	};
// Units
_unitarray = [];
	{
	_unitlist = [_x,WEST] call tpw_skirmish_fnc_types;
	_unitlist = [_unitlist] call tpw_skirmish_fnc_noncom;
	_unitarray pushback _unitlist;
	} foreach _unitstrings; 	
tpw_skirmish_friendlyunitarray =  [_unitarray] + tpw_skirmish_allunits;
// Vehicles
_cararray = [];
	{
	_carlist = [_x,WEST] call tpw_skirmish_fnc_cartypes;
	_cararray pushback _carlist;
	} foreach _carstrings;
tpw_skirmish_friendlyvehiclearray = [_cararray] + tpw_skirmish_allcars;		
	
// OPFOR	
if !(tpw_skirmish_enemyunitstring isequalto []) then 
	{
	_unitstrings = tpw_skirmish_enemyunitstring; 
	} else	
	{
	_unitstrings = ["o_soldier"];
	};
if !(tpw_skirmish_enemyvehiclestring isequalto []) then
	{
	_carstrings = tpw_skirmish_enemyvehiclestring; 
	} else
	{
	_carstrings = ["o_mrap"];
	};
// Units
_unitarray = [];
	{
	_unitlist = [_x,EAST] call tpw_skirmish_fnc_types;
	_unitlist = [_unitlist] call tpw_skirmish_fnc_noncom;
	_unitarray pushback _unitlist;
	} foreach _unitstrings; 	
tpw_skirmish_enemyunitarray =  [_unitarray] + tpw_skirmish_allunits;
// Vehicles
_cararray = [];
	{
	_carlist = [_x,EAST] call tpw_skirmish_fnc_cartypes;
	_cararray pushback _carlist;
	} foreach _carstrings;
tpw_skirmish_enemyvehiclearray = [_cararray] + tpw_skirmish_allcars;	
	
// INDFOR	
if !(tpw_skirmish_resistunitstring isequalto []) then 
	{
	_unitstrings = tpw_skirmish_resistunitstring; 
	} else	
	{
	_unitstrings = ["i_soldier"];
	};
if !(tpw_skirmish_resistvehiclestring isequalto []) then
	{
	_carstrings = tpw_skirmish_resistvehiclestring; 
	} else
	{
	_carstrings = ["i_mrap"];
	};
// Units
_unitarray = [];
	{
	_unitlist = [_x,RESISTANCE] call tpw_skirmish_fnc_types;
	_unitlist = [_unitlist] call tpw_skirmish_fnc_noncom;
	_unitarray pushback _unitlist;
	} foreach _unitstrings; 	
tpw_skirmish_resistunitarray =  [_unitarray] + tpw_skirmish_allunits;
// Vehicles
_cararray = [];
	{
	_carlist = [_x,RESISTANCE] call tpw_skirmish_fnc_cartypes;
	_cararray pushback _carlist;
	} foreach _carstrings;
tpw_skirmish_resistvehiclearray = [_cararray] + tpw_skirmish_allcars;	
	
// CREATE AI CENTRES SO SPAWNED GROUPS KNOW WHO'S AN ENEMY
private ["_centerW", "_centerE", "_centerR", "_centerC"];
_centerW = createCenter west;
_centerE = createCenter east;
_centerR = createCenter resistance;
_centerC = createCenter civilian;

// INITIAL POSITIONS FOR ROAD AND HOUSE SCANNING 
tpw_skirmish_lasthousepos = [-2000,-2000,0];
tpw_skirmish_lastroadpos = [-2000,-2000,0];

//sleep tpw_skirmish_spawntime;
[] spawn tpw_skirmish_fnc_friendlyloop;
sleep 0.1;
[] spawn tpw_skirmish_fnc_enemyloop;
sleep 0.1;
[] spawn tpw_skirmish_fnc_resistloop;
sleep 1;
[] spawn tpw_skirmish_fnc_cleanup;
sleep 1;
[] spawn tpw_skirmish_fnc_moveto;
while {true} do
	{
	// dummy loop so script doesn't terminate
	sleep 10;
	};
